{
  "features": [
    {
      "given": "A new user wants to sign up for Scribl",
      "when": "The user attempts to authenticate their account",
      "then": "The user is redirected to LinkedIn OAuth for authentication",
      "and": "A Scribl user record is created or updated based on the LinkedIn profile"
    },
    {
      "given": "A newly authenticated user is starting their first Scribl session",
      "when": "The user proceeds through the onboarding flow",
      "then": "The user is presented with a guided, multi-step process",
      "and": "The system automatically saves progress throughout the onboarding flow to prevent drop-offs"
    },
    {
      "given": "A 'Marketing Manager (Team Admin)' persona is managing team subscriptions",
      "when": "The admin selects the number of seats and a subscription plan for their team",
      "then": "A real-time calculator displays the pricing and associated features for the selected plan",
      "and": "Access to Scribl is provisioned for the specified number of seats"
    },
    {
      "given": "A user is in the content creation section of Scribl",
      "when": "The user inputs an idea or prompt into the AI Assistant's conversational interface",
      "then": "The AI generates multiple variations of posts, articles, or captions",
      "and": "The user can refine the generated drafts through iterative feedback within the interface"
    },
    {
      "given": "A user is interacting with the AI Assistant for content generation",
      "when": "The user utilizes the Chat Canvas interface",
      "then": "The user can interact with the AI through a dedicated chat panel",
      "and": "The user can simultaneously use a visual editor to modify the generated content"
    },
    {
      "given": "A user is creating or editing a post",
      "when": "The user drags a text block, image, or design element onto the canvas",
      "then": "The element is placed on the canvas, allowing visual content arrangement"
    },
    {
      "given": "A user is editing text within a post",
      "when": "The user selects text and applies formatting options (e.g., bold, italics)",
      "then": "The selected text is formatted according to the user's selection"
    },
    {
      "given": "A user is creating or editing a post",
      "when": "The user accesses the preview functionality",
      "then": "The system displays a realistic preview of how the post will appear on LinkedIn"
    },
    {
      "given": "A user is creating a new post, carousel, or article",
      "when": "The user selects a pre-designed template categorized by use case or industry",
      "then": "The system loads the template structure, providing a starting point for content creation"
    },
    {
      "given": "A user has designed a custom post structure",
      "when": "The user saves this custom structure as a template",
      "then": "The custom template becomes available for team-wide reuse"
    },
    {
      "given": "A user wants to create a multi-slide LinkedIn carousel",
      "when": "The user uses the Carousel Creator to add and arrange multiple slides",
      "then": "The system allows the creation of a multi-slide carousel compliant with LinkedIn's format"
    },
    {
      "given": "A user is creating a carousel in the Carousel Creator",
      "when": "The user selects a specific carousel template (e.g., for storytelling, step-by-step guides)",
      "then": "The Carousel Creator populates the slides with the structure of the selected template"
    },
    {
      "given": "A user is creating a carousel in the Carousel Creator",
      "when": "The user makes changes to a carousel slide",
      "then": "The system provides a live preview showing how the carousel will appear on LinkedIn"
    },
    {
      "given": "A user is creating a carousel in the Carousel Creator",
      "when": "The carousel is being prepared for publishing",
      "then": "The system ensures the carousel complies with LinkedIn’s format requirements"
    },
    {
      "given": "A user navigates to the Content Library",
      "when": "The Content Library loads",
      "then": "The system displays a centralized repository of all content items"
    },
    {
      "given": "A user is viewing the Content Library",
      "when": "The user applies a filter for content status (e.g., 'draft', 'scheduled', 'published')",
      "then": "The Content Library displays only content items matching the selected status"
    },
    {
      "given": "A user is viewing the Content Library",
      "when": "The user applies a filter for content type or tags",
      "then": "The Content Library displays only content items matching the selected type or tags"
    },
    {
      "given": "A user is viewing the Content Library and has selected multiple content items",
      "when": "The user selects the 'Delete' bulk action",
      "then": "All selected content items are deleted from the library"
    },
    {
      "given": "A user is viewing the Content Library and has selected multiple content items",
      "when": "The user selects the 'Duplicate' bulk action",
      "then": "Duplicate copies of all selected content items are created"
    },
    {
      "given": "A user is viewing the Content Library and has selected multiple content items",
      "when": "The user selects the 'Export' bulk action",
      "then": "The selected content items are exported in a chosen format"
    },
    {
      "given": "An editor has finished drafting content",
      "when": "The editor submits the content for review",
      "then": "The content status changes to 'Pending Review' and is made available to approvers"
    },
    {
      "given": "An approver is reviewing content",
      "when": "The approver adds comments to the content",
      "then": "The comments are saved and associated with the content for the editor to see"
    },
    {
      "given": "An approver is reviewing content",
      "when": "The approver requests changes to the content",
      "then": "The content status reverts to 'Draft' or 'Changes Requested', and the editor is notified"
    },
    {
      "given": "An approver is reviewing content",
      "when": "The approver approves the content",
      "then": "The content status changes to 'Approved' and it becomes available for scheduling"
    },
    {
      "given": "Changes are made to content during the approval workflow",
      "when": "Any action (e.g., comment, request change, approval) is performed on the content",
      "then": "All changes and actions are tracked in the content's version history"
    },
    {
      "given": "A user is editing content",
      "when": "The user saves a draft of the content",
      "then": "A new version of the content is created and recorded in the version history"
    },
    {
      "given": "A user is viewing the version history of content",
      "when": "The user selects a prior version and chooses to roll back",
      "then": "The content reverts to the state of the selected prior version, recovering lost work"
    },
    {
      "given": "A user is viewing the version history of content",
      "when": "The user compares different versions of the content",
      "then": "The system highlights the differences between the selected iterations"
    },
    {
      "given": "A user has approved content ready for scheduling",
      "when": "The user uses the visual calendar to assign content to a future date",
      "then": "The content is scheduled for publication on the selected date"
    },
    {
      "given": "Content is scheduled on the visual calendar",
      "when": "The user drags and drops scheduled content to a different date or time on the calendar",
      "then": "The content's publication schedule is updated accordingly"
    },
    {
      "given": "A user is scheduling content",
      "when": "The user configures the content to be a recurring post with specified frequency",
      "then": "The system schedules the content to be published repeatedly as configured"
    },
    {
      "given": "A user is scheduling content",
      "when": "The user sets or adjusts the time zone for a scheduled post",
      "then": "The content is published at the correct local time based on the selected time zone"
    },
    {
      "given": "Content is scheduled for publication",
      "when": "The scheduled publication time arrives",
      "then": "The system automatically publishes the content to LinkedIn via API"
    },
    {
      "given": "Content is scheduled for publication, and the initial attempt to publish via LinkedIn API fails",
      "when": "The system encounters a publishing failure",
      "then": "The system automatically retries publishing the content after a short delay"
    },
    {
      "given": "Content is scheduled for publication, and publishing repeatedly fails",
      "when": "The system is unable to publish content after retries",
      "then": "The system sends an alert to the user indicating the publishing error"
    },
    {
      "given": "Content has been successfully published to LinkedIn",
      "when": "The publishing process completes",
      "then": "The user receives a confirmation notification both in-app and via email"
    },
    {
      "given": "Content failed to publish to LinkedIn after retries",
      "when": "The publishing process encounters an unrecoverable failure",
      "then": "The user receives an alert notification both in-app and via email"
    },
    {
      "given": "A user accesses the Engage Feed",
      "when": "The Engage Feed loads",
      "then": "The system displays an aggregation of relevant LinkedIn posts from the user's network and industry"
    },
    {
      "given": "A user is viewing the Engage Feed",
      "when": "The system displays aggregated posts",
      "then": "Posts that are most suitable for engagement are prioritized and displayed prominently"
    },
    {
      "given": "A user is viewing a LinkedIn post in the Engage Feed",
      "when": "The user clicks the 'Like' button for that post",
      "then": "The post is liked on LinkedIn via API, and the user remains in Scribl"
    },
    {
      "given": "A user is viewing a LinkedIn post in the Engage Feed",
      "when": "The user clicks the 'Share' button for that post",
      "then": "The post is shared on LinkedIn via API, and the user remains in Scribl"
    },
    {
      "given": "A user is viewing a LinkedIn post in the Engage Feed",
      "when": "The user enters a comment and submits it",
      "then": "The comment is posted on LinkedIn via API, and the user remains in Scribl"
    },
    {
      "given": "A user is about to comment or reply to a LinkedIn post in Scribl",
      "when": "The user accesses the comment/reply input field",
      "then": "Scribl generates suggested comments or replies that maintain a professional tone and brand voice"
    },
    {
      "given": "Scribl has generated AI-suggested comments or replies",
      "when": "The user selects one of the suggestions or edits a suggestion",
      "then": "The selected or edited suggestion is used as the comment/reply for posting"
    },
    {
      "given": "A user is engaging with connections on LinkedIn via Scribl",
      "when": "The user performs actions like liking, commenting, or sharing",
      "then": "Scribl tracks the engagement levels with these connections"
    },
    {
      "given": "Scribl is tracking engagement levels with connections",
      "when": "The user reviews networking metrics",
      "then": "Scribl highlights connections that represent opportunities for relationship-building (e.g., prospects, influencers)"
    },
    {
      "given": "A user is in the Discovery section",
      "when": "The system analyzes LinkedIn data and market signals",
      "then": "Scribl surfaces trending themes that are relevant to the user’s niche"
    },
    {
      "given": "A user has configured competitor accounts",
      "when": "The user accesses the Competitor Analysis feature",
      "then": "Scribl benchmarks the user's content performance against the configured similar accounts or competitors"
    },
    {
      "given": "A user is using the Gap Analysis feature",
      "when": "The system compares user and competitor activities",
      "then": "Scribl identifies content areas where competitors are active but the user is not, suggesting new content directions"
    },
    {
      "given": "Scribl suggests new topics (e.g., from Gap Analysis or Trending Topics)",
      "when": "The user reviews these suggested topics",
      "then": "Scribl uses AI to forecast the expected engagement for each suggested topic before the content is created"
    },
    {
      "given": "A user accesses the Analytics Dashboard",
      "when": "The dashboard loads",
      "then": "The system displays visual reports on impressions, clicks, engagement rates, and follower growth"
    },
    {
      "given": "A user is viewing the Analytics Dashboard",
      "when": "The user applies a filter for a specific time range",
      "then": "The analytics reports update to show data only for the selected time range"
    },
    {
      "given": "A user is viewing the Analytics Dashboard",
      "when": "The user applies a filter for content type or a specific team member",
      "then": "The analytics reports update to show data only for the selected content type or team member"
    },
    {
      "given": "Scribl has historical content performance data",
      "when": "A user accesses the AI Insights section",
      "then": "Scribl analyzes past performance and generates tailored recommendations, such as best posting times or content types with the highest engagement"
    },
    {
      "given": "A user is viewing analytics reports",
      "when": "The user selects to export the analytics",
      "then": "The system provides options to export the analytics data in CSV or PDF formats"
    },
    {
      "given": "An admin is in the Team Management section",
      "when": "The admin invites new members via email",
      "then": "The new members receive an invitation to join the team"
    },
    {
      "given": "An admin is managing team members",
      "when": "The admin assigns roles (e.g., editor, approver) and customizes permissions for team members",
      "then": "Team members are granted specific access levels and capabilities based on their assigned roles and permissions"
    },
    {
      "given": "Team members are added to the workspace",
      "when": "The admin reviews team management settings",
      "then": "The system tracks and displays the current seat usage"
    },
    {
      "given": "An enterprise account user",
      "when": "The user creates new workspaces for different teams or regions",
      "then": "Multiple distinct workspaces are provisioned, each with separate content, analytics, and templates"
    },
    {
      "given": "Multiple workspaces exist for an enterprise account",
      "when": "A user operates within a specific workspace",
      "then": "The content, analytics, and templates are isolated and specific to that workspace, ensuring data separation"
    },
    {
      "given": "A user performs a key action (e.g., creates, edits, approves, publishes content)",
      "when": "The action is completed",
      "then": "The system records the action in audit and activity logs with a timestamp and the actor's identity"
    },
    {
      "given": "An admin needs to review historical actions",
      "when": "The admin accesses the Audit & Activity Logs",
      "then": "The admin can review all recorded key actions for compliance and accountability purposes"
    },
    {
      "given": "A user accesses the Billing Management section",
      "when": "The billing page loads",
      "then": "The user can view their current subscription status"
    },
    {
      "given": "A user is in the Billing Management section",
      "when": "The user requests to download invoices",
      "then": "The system provides access to download past and current invoices"
    },
    {
      "given": "A user is in the Billing Management section",
      "when": "The user attempts to update their payment method",
      "then": "The system allows the user to securely update their payment information"
    },
    {
      "given": "A user wants to upgrade their subscription",
      "when": "The user selects a higher-tier plan",
      "then": "The system applies prorated billing for the upgrade, and the subscription is updated"
    },
    {
      "given": "A user wants to downgrade their subscription",
      "when": "The user selects a lower-tier plan",
      "then": "The system applies prorated billing for the downgrade, and the subscription is updated"
    },
    {
      "given": "A user is an editor of a post awaiting approval",
      "when": "An approval request is pending for the post",
      "then": "The user receives an in-app alert for the pending approval."
    },
    {
      "given": "A user successfully publishes content",
      "when": "The publishing process is completed",
      "then": "The user receives an in-app confirmation alert."
    },
    {
      "given": "A user attempts an action that results in a system error",
      "when": "The system encounters an error",
      "then": "The user receives an in-app error alert explaining the issue."
    },
    {
      "given": "A user's payment for their subscription fails",
      "when": "The system detects a failed payment",
      "then": "The user receives a critical email alert regarding the failed payment."
    },
    {
      "given": "A user attempts to publish content, but the publishing process encounters a critical error",
      "when": "The system detects a critical publishing error",
      "then": "The user receives a critical email alert regarding the publishing error."
    },
    {
      "given": "A user has enabled Slack or Microsoft Teams integration",
      "when": "A critical team-related notification (e.g., approval, publishing status) is triggered",
      "then": "The team receives a real-time notification in the integrated Slack/Teams channel."
    },
    {
      "given": "A user is on their profile page",
      "when": "The user updates their name or title and saves the changes",
      "then": "Their profile name and title are updated successfully."
    },
    {
      "given": "A user is on their profile page",
      "when": "The user uploads a new profile picture and saves the changes",
      "then": "Their profile picture is updated successfully."
    },
    {
      "given": "A user is on their profile page",
      "when": "The user modifies their brand voice preferences and saves the changes",
      "then": "Their brand voice preferences are updated successfully."
    },
    {
      "given": "A user is in their account settings",
      "when": "The user adjusts their notification frequency settings and saves the changes",
      "then": "Their notification frequency preferences are updated successfully."
    },
    {
      "given": "A user is in their account settings",
      "when": "The user modifies their privacy controls (e.g., data visibility) and saves the changes",
      "then": "Their privacy controls are updated successfully."
    },
    {
      "given": "A user is in their account settings",
      "when": "The user enables or disables dark mode or other UI customization options",
      "then": "The user interface reflects the chosen customization."
    },
    {
      "given": "A user complies with GDPR regulations",
      "when": "The user requests an export of their personal data",
      "then": "The system initiates the process to export the user's data."
    },
    {
      "given": "A user complies with GDPR regulations",
      "when": "The user requests the deletion of their account",
      "then": "The system initiates the process for account deletion."
    },
    {
      "given": "A user is creating or editing a post",
      "when": "The user uses the stock image search feature",
      "then": "The user can search and insert images from Unsplash/Pexels directly into the post."
    },
    {
      "given": "A user has inserted a stock image from the integrated library",
      "when": "The post containing the image is published or saved",
      "then": "The system automatically adds the required attribution for the image."
    },
    {
      "given": "Multiple users frequently use the same stock images",
      "when": "Images are requested by users",
      "then": "Frequently used images are cached to improve loading performance."
    },
    {
      "given": "A user is looking for specific information within the platform",
      "when": "The user enters a query into the unified search bar",
      "then": "The system returns relevant results across content, templates, analytics, and opportunities."
    },
    {
      "given": "A user has performed a search query",
      "when": "The user applies filters such as tags, status, roles, or content type to the search results",
      "then": "The search results are narrowed down based on the applied filters."
    },
    {
      "given": "A user accesses the web application on a mobile device",
      "when": "The application loads on the mobile browser",
      "then": "The layouts are optimized and responsive for the mobile screen."
    },
    {
      "given": "A user is on a mobile device",
      "when": "The user wants to quickly draft a new piece of content",
      "then": "The user can utilize the 'Quick create' feature designed for small screens."
    },
    {
      "given": "A user is on a mobile device",
      "when": "The user needs to review or approve pending content",
      "then": "The user can access and manage approval workflows optimized for small screens."
    },
    {
      "given": "A user is on a mobile device",
      "when": "The user wants to schedule content for future publication",
      "then": "The user can access and manage scheduling workflows optimized for small screens."
    },
    {
      "given": "A user wants to retrieve their data",
      "when": "The user initiates an export of posts, analytics, or templates",
      "then": "The system generates and provides the data in CSV or JSON format."
    },
    {
      "given": "An Enterprise user is setting up their account",
      "when": "The user performs a bulk upload of templates or team member lists",
      "then": "The system processes the bulk upload, facilitating faster setup."
    },
    {
      "given": "A user needs assistance or information",
      "when": "The user accesses the in-app help section",
      "then": "The user can find links to FAQs and support documentation."
    },
    {
      "given": "A new user logs in for the first time",
      "when": "The user starts the onboarding process",
      "then": "The system provides an interactive walkthrough explaining each module."
    },
    {
      "given": "A user encounters an issue within the platform",
      "when": "The user decides to report the issue",
      "then": "The user can access an integrated helpdesk platform (e.g., Zendesk, Intercom) to report the issue directly."
    },
    {
      "given": "A user has a 'Normal' subscription tier",
      "when": "The user attempts to create content",
      "then": "The user can perform basic content creation tasks."
    },
    {
      "given": "A user has a 'Normal' subscription tier",
      "when": "The user attempts to use AI features",
      "then": "The user is subject to a limited number of AI credits."
    },
    {
      "given": "A user has a 'Pro' subscription tier",
      "when": "The user accesses the analytics dashboard",
      "then": "The user can view advanced analytics data and reports."
    },
    {
      "given": "A user has a 'Pro' subscription tier",
      "when": "The user utilizes AI features for content generation",
      "then": "The user has unlimited AI credit usage."
    },
    {
      "given": "A user has a 'Pro' subscription tier",
      "when": "The user interacts with other team members on content projects",
      "then": "The user can access and utilize team collaboration features."
    },
    {
      "given": "A user has an 'Enterprise' subscription tier",
      "when": "The user needs to manage content for different brands or clients",
      "then": "The user can create and manage multiple workspaces."
    },
    {
      "given": "A user has an 'Enterprise' subscription tier",
      "when": "The user explores new content ideas or trends",
      "then": "The user can access advanced discovery features."
    },
    {
      "given": "A user has an 'Enterprise' subscription tier",
      "when": "The user requires assistance with the platform",
      "then": "The user has access to dedicated support channels."
    },
    {
      "given": "A user is authenticated via LinkedIn",
      "when": "Their LinkedIn access token expires",
      "then": "The system prompts the user to re-authenticate with LinkedIn."
    },
    {
      "given": "A user's subscription payment fails",
      "when": "The system detects the payment failure",
      "then": "The user's plan is downgraded, and the account administrator is notified."
    },
    {
      "given": "A user attempts to generate AI content",
      "when": "The AI generation service encounters an error",
      "then": "The system provides fallback templates and allows the user to retry the AI generation."
    },
    {
      "given": "Content requires approval from a specific user",
      "when": "The approval deadline is missed by the approver",
      "then": "The system sends reminders and escalates notifications to relevant parties."
    },
    {
      "given": "A user has a specific role (e.g., Viewer, Editor, Admin)",
      "when": "The user attempts to perform an action outside their assigned permissions (e.g., a Viewer tries to publish content)",
      "then": "The system restricts the action and displays an appropriate access denied message."
    },
    {
      "given": "a user is on the login page",
      "when": "they choose to log in with LinkedIn",
      "then": "they should be authenticated successfully via LinkedIn OAuth."
    },
    {
      "given": "a newly authenticated user",
      "when": "they complete the guided onboarding by setting goals, brand voice, frequency, and niches",
      "then": "their profile preferences should be saved and applied to future content generation."
    },
    {
      "given": "a user has completed onboarding",
      "when": "they select a seat and subscription plan",
      "then": "they should be prompted to complete payment via Stripe, and their subscription should be activated upon successful payment."
    },
    {
      "given": "a user is in the content creation editor",
      "when": "they provide a prompt to the AI assistant",
      "then": "the AI assistant should generate multiple content variations based on the prompt."
    },
    {
      "given": "a user is creating content",
      "when": "they use the chat and canvas editor to add text and visuals",
      "then": "they should be able to preview their content in real-time."
    },
    {
      "given": "a user wants to create content",
      "when": "they select a template from an industry category (e.g., posts, articles, carousels)",
      "then": "the editor should load with the pre-designed template, ready for customization."
    },
    {
      "given": "a user is building a carousel",
      "when": "they create multiple slides and preview them",
      "then": "the carousel content should be presented for review and adhere to compliance guidelines."
    },
    {
      "given": "a user is browsing the Template Marketplace",
      "when": "they select a premium template",
      "then": "they should be able to purchase and use it within their content creation flow."
    },
    {
      "given": "a user has created a template",
      "when": "they share it to the community marketplace",
      "then": "other users should be able to discover and use the shared template."
    },
    {
      "given": "a user has created content",
      "when": "they navigate to the content library",
      "then": "they should see all their created content centralized and easily accessible."
    },
    {
      "given": "a user has submitted content for approval",
      "when": "an approver reviews the content and approves it",
      "then": "the content status should change to 'Approved' and become eligible for publishing."
    },
    {
      "given": "a user has submitted content for approval",
      "when": "an approver reviews the content and rejects it",
      "then": "the content status should change to 'Rejected', and the original user should be notified with feedback."
    },
    {
      "given": "a user has made multiple edits to a piece of content",
      "when": "they need to revert to a previous version",
      "then": "they should be able to select an earlier version and roll back the content to that state."
    },
    {
      "given": "a user has created content",
      "when": "they use the calendar to drag-and-drop the content for scheduling, set it as recurring, and specify a timezone",
      "then": "the content should be scheduled according to these settings and appear on the calendar."
    },
    {
      "given": "content is scheduled for publishing",
      "when": "the scheduled time arrives",
      "then": "the system should attempt to publish the content automatically, apply retry logic in case of initial failure, and send alerts if publishing fails."
    },
    {
      "given": "content has been published or attempted to be published",
      "when": "the publishing process completes",
      "then": "the user should receive a notification confirming the success or failure of the publishing action."
    },
    {
      "given": "a user navigates to the 'Engage' section",
      "when": "they view the engagement feed",
      "then": "they should see prioritized posts from their network relevant for interaction."
    },
    {
      "given": "a user is viewing a post in the engagement feed",
      "when": "they click the 'like' or 'share' button",
      "then": "their action should be registered on the post with a single click."
    },
    {
      "given": "a user is about to comment or reply to a post",
      "when": "they activate AI comment/reply suggestions",
      "then": "the AI should provide relevant and context-aware comment/reply options."
    },
    {
      "given": "a user has connected their LinkedIn account",
      "when": "they view their networking metrics",
      "then": "they should see tracking data for their connection engagement and performance."
    },
    {
      "given": "a user is in the 'Discovery' section",
      "when": "they look for trending topics",
      "then": "the system should display trending topics identified by AI and LinkedIn signals relevant to their niches."
    },
    {
      "given": "a user has configured competitors",
      "when": "they view the competitor analysis dashboard",
      "then": "the system should display insights into competitor performance and identify content gaps for opportunities."
    },
    {
      "given": "a user is creating new content",
      "when": "they request a predicted performance forecast",
      "then": "the AI should provide an estimated performance (e.g., impressions, engagement) before publishing."
    },
    {
      "given": "a user navigates to the Analytics dashboard",
      "when": "they view the dashboard",
      "then": "they should see key metrics like impressions, clicks, engagement, and follower growth."
    },
    {
      "given": "a user is reviewing their analytics",
      "when": "they access AI insights",
      "then": "the AI should suggest best posting times and highlight high-performing content based on their data."
    },
    {
      "given": "a user is viewing analytics data",
      "when": "they choose an export option (CSV, PDF, or JSON)",
      "then": "the analytics data should be exported in the selected format."
    },
    {
      "given": "an admin user",
      "when": "they assign a specific role (e.g., Editor, Approver) to a team member",
      "then": "that team member should only have permissions aligned with their assigned role."
    },
    {
      "given": "an admin user",
      "when": "they set up multiple workspaces (e.g., for different regions or brands)",
      "then": "team members should be able to access and manage content specific to their assigned workspaces."
    },
    {
      "given": "an administrator needs to review system activities",
      "when": "they access the audit and activity logs",
      "then": "they should see a chronological record of all significant user and system actions."
    },
    {
      "given": "a user has a specific role (e.g., 'analytics-only')",
      "when": "they attempt an action outside their allowed scope (e.g., publishing content)",
      "then": "their permission to perform that action should be denied based on their role-based access control (RBAC), aligning with compliance."
    },
    {
      "given": "content requires multi-step approval",
      "when": "a user submits content for review",
      "then": "it should proceed through the defined approval hierarchy, requiring review from multiple designated approvers before final approval."
    },
    {
      "given": "content or data has reached its retention expiry",
      "when": "the system processes data retention policies",
      "then": "the content/data should be automatically archived or deleted according to the defined retention policies."
    },
    {
      "given": "a user is operating in a specific region (e.g., EU)",
      "when": "they create or store content/data",
      "then": "that content/data should be segregated and stored in data centers compliant with that region's regulations."
    },
    {
      "given": "a user is on the 'Normal' plan",
      "when": "they try to access a feature exclusive to 'Pro' plans",
      "then": "they should be prompted to upgrade their subscription to access the feature."
    },
    {
      "given": "a user navigates to the billing dashboard",
      "when": "they view their billing information",
      "then": "they should see their subscription status, access invoices, and manage configured payment methods."
    },
    {
      "given": "a user wants to change their subscription plan",
      "when": "they upgrade or downgrade their plan mid-billing cycle",
      "then": "their billing should be prorated accordingly, reflecting the change accurately."
    },
    {
      "given": "a user is on the 'Pro' tier",
      "when": "they use AI features (e.g., generating content)",
      "then": "their usage should be deducted from the credit allocation specific to the 'Pro' tier."
    },
    {
      "given": "a user generates an AI article",
      "when": "the system calculates credit usage",
      "then": "the credit cost should reflect the content type (e.g., an article costs more than a short post)."
    },
    {
      "given": "an admin user",
      "when": "they view the AI usage dashboard",
      "then": "they should see credit usage tracked per user and per team."
    },
    {
      "given": "a user's AI credit balance is low",
      "when": "the system detects the low balance",
      "then": "an alert should be triggered, and the user should be presented with top-up options (e.g., extra packs, auto top-ups)."
    },
    {
      "given": "an admin user",
      "when": "they access team credit controls",
      "then": "they should be able to manually allocate or adjust AI credits for individual team members or the entire team."
    },
    {
      "given": "an important event occurs (e.g., content approval, publishing failure)",
      "when": "the event is processed",
      "then": "the user should receive a notification via their preferred channels (in-app, email, Slack/Teams)."
    },
    {
      "given": "a user navigates to Profile & Settings",
      "when": "they update their brand voice preferences",
      "then": "their content generation and AI suggestions should reflect the new brand voice."
    },
    {
      "given": "a user requests data export or deletion under GDPR",
      "when": "they initiate the request in their settings",
      "then": "their personal data should be exported or deleted accordingly and promptly."
    },
    {
      "given": "a user is creating content",
      "when": "they search for an image in the stock image library",
      "then": "they should be able to select an image from Unsplash/Pexels, and proper attribution should be handled automatically."
    },
    {
      "given": "a user needs to find specific content",
      "when": "they use the global search bar with advanced filters",
      "then": "they should be able to quickly locate the desired content by various criteria."
    },
    {
      "given": "a user accesses the platform on a mobile device",
      "when": "they use the responsive PWA to quickly create, approve, or publish content",
      "then": "the experience should be optimized for mobile, ensuring full functionality and ease of use."
    },
    {
      "given": "an enterprise user needs to onboard a large amount of data",
      "when": "they use the data import feature with a CSV or JSON file",
      "then": "the data should be imported efficiently for bulk setup."
    },
    {
      "given": "a new user is onboarding",
      "when": "they activate an onboarding tour",
      "then": "they should be guided through the platform's key features and functionalities."
    },
    {
      "given": "a user encounters an issue",
      "when": "they submit a support ticket via the help center",
      "then": "their issue should be logged and addressed by the support team in a timely manner."
    },
    {
      "given": "a user sets their UI language preference to Spanish",
      "when": "they interact with the platform and generate AI content",
      "then": "the UI should be displayed in Spanish, and the AI should generate content in Spanish."
    },
    {
      "given": "a user wants to connect with Slack",
      "when": "they configure the Slack integration",
      "then": "notifications and updates should be able to be sent to their specified Slack channels."
    },
    {
      "given": "a developer wants to build a custom integration",
      "when": "they use the provided REST/GraphQL API with their API key",
      "then": "they should be able to interact with the platform's features, respecting defined rate limits."
    },
    {
      "given": "A user has created a new content item.",
      "when": "The user submits the content item for a plagiarism check.",
      "then": "The system should analyze the content for uniqueness and report any potential plagiarism or similarity, leveraging content compliance checks."
    },
    {
      "given": "A user has created a new content item.",
      "when": "The user submits the content item for an AI safety check.",
      "then": "The system should scan the content for AI-generated patterns and flag it if it detects non-human authorship or unsafe content."
    },
    {
      "given": "A user is assigned a specific role (e.g., 'Editor') within a workspace, with permissions defined in 'roles' and 'role_permissions' tables.",
      "when": "The user attempts to access or modify a content item in that workspace.",
      "then": "The system should grant or deny access based on the Role-Based Access Control (RBAC) permissions associated with their assigned role."
    },
    {
      "given": "An administrator user is logged into the system.",
      "when": "The administrator attempts to define new roles or assign permissions to existing roles within a team or workspace.",
      "then": "The system should allow the administrator to manage roles and permissions, which are stored in the 'roles', 'permissions', and 'role_permissions' tables."
    },
    {
      "given": "A user performs an action that modifies a content item in a workspace.",
      "when": "The user saves the changes or the action is completed.",
      "then": "The system should record the action, the actor, the target, and a timestamp in the 'audit_logs' table for traceability."
    },
    {
      "given": "A user provides sensitive information such as API keys or social media access tokens (e.g., 'access_token_enc' in 'linked_in_profiles').",
      "when": "This sensitive data is stored in the database.",
      "then": "The system should encrypt the data at rest to protect it from unauthorized access, ensuring data security."
    },
    {
      "given": "A workspace has a data retention policy defined in the 'retention_policies' table.",
      "when": "Data subject to the policy reaches its predefined retention limit.",
      "then": "The system should automatically anonymize or delete the data according to the policy rules, in compliance with GDPR."
    },
    {
      "given": "A team has a specific data residency configuration specified in the 'region_data_config' table.",
      "when": "New data is generated or stored for that team.",
      "then": "The system should ensure the data is stored and processed within the designated geographical region to comply with data residency requirements."
    },
    {
      "given": "An enterprise user attempts to log in to the application.",
      "when": "The user selects the Single Sign-On (SSO) option and successfully authenticates via their configured identity provider (configured in 'identity_providers' and 'idp_links').",
      "then": "The user should be successfully logged into the application without needing a separate password, leveraging enterprise SSO capabilities."
    },
    {
      "given": "An enterprise user has access to custom reporting features within a workspace.",
      "when": "The user defines specific criteria for a report and requests an export.",
      "then": "The system should generate a report containing the requested data (potentially leveraging 'report_exports' table) and make it available for download or viewing."
    },
    {
      "given": "An enterprise team requires specific compliance standards.",
      "when": "An administrator applies a 'compliance pack' to their workspace.",
      "then": "The system should automatically configure relevant settings (e.g., data retention policies, audit log settings) according to the pack's requirements, ensuring adherence to compliance."
    },
    {
      "given": "A user has linked their LinkedIn profile (stored in 'linked_in_profiles') to their account and created a content item.",
      "when": "The user schedules or publishes the content item to their LinkedIn profile.",
      "then": "The system should successfully publish the content to LinkedIn (v1) and record the activity in 'publish_jobs' and 'platform_posts'."
    },
    {
      "given": "The platform is designed with extensibility for social media platforms, including 'platform_profiles' for configuration.",
      "when": "A new social media platform (e.g., X, Instagram, YouTube) is integrated.",
      "then": "The system should allow users to connect their profiles for that platform and enable publishing functionality, demonstrating multi-platform readiness."
    },
    {
      "given": "A new data model is defined within the system",
      "when": "The schema is validated or a model instance is persisted",
      "then": "The model must be directly or indirectly related to a User, Team, or Workspace entity"
    },
    {
      "given": "A new User account is being created",
      "when": "No 'role' is explicitly provided during creation",
      "then": "The User's 'role' should default to 'EDITOR'"
    },
    {
      "given": "A new Team is being created",
      "when": "No 'plan' tier is explicitly provided during creation",
      "then": "The Team's 'plan' should default to 'NORMAL'"
    },
    {
      "given": "A new Team is being created",
      "when": "No 'seatCount' is explicitly provided during creation",
      "then": "The Team's 'seatCount' should default to '1'"
    },
    {
      "given": "A new Team is being created",
      "when": "No specific owner is designated through 'ownerId'",
      "then": "The 'ownerId' field of the new team should be allowed to remain null"
    },
    {
      "given": "A user needs to be assigned a specific role within the system",
      "when": "The UserRoleRelation mechanism is utilized for role assignment",
      "then": "The assigned role must be explicitly linked to a Team or Workspace entity"
    },
    {
      "given": "A new translation entry is created",
      "when": "The translation is being stored",
      "then": "The translation must be linked to a specific locale and optionally to a Workspace"
    },
    {
      "given": "A User with a specific email address already exists in the database",
      "when": "An attempt is made to create another User with the same email address",
      "then": "The system should prevent the creation of the duplicate user due to the unique email constraint"
    },
    {
      "given": "A Team with a non-null slug already exists in the database",
      "when": "An attempt is made to create another Team with the same non-null slug",
      "then": "The system should prevent the creation of the duplicate team due to the unique slug constraint"
    },
    {
      "given": "Advanced database constructs like tsvector or GIN indexes are required for application functionality",
      "when": "The core schema is deployed using Prisma migrations",
      "then": "These advanced constructs must be implemented through separate raw SQL migration scripts"
    },
    {
      "given": "The system is designed to manage teams and their associated entities.",
      "when": "A new team is established",
      "then": "It should have an owner, and can hold references to team members, seats, workspaces, AI allocations, credit top-ups, region configurations, subscriptions, and roles."
    },
    {
      "given": "A team and a user exist in the system.",
      "when": "The user is invited to join the team",
      "then": "A TeamMember record is created, associating the user with the team, with a 'status' of 'invited' and 'invitedAt' timestamp."
    },
    {
      "given": "A user has been invited to a team.",
      "when": "The user accepts the team invitation",
      "then": "The 'status' of the corresponding TeamMember record is updated to reflect acceptance, and 'acceptedAt' timestamp is recorded."
    },
    {
      "given": "A user is already a member of a specific team.",
      "when": "An attempt is made to add the same user to the same team again",
      "then": "The system prevents the creation of a duplicate TeamMember record, ensuring unique membership for each team and user."
    },
    {
      "given": "A team and a user are available in the system.",
      "when": "A seat of a particular type is assigned to the user within that team",
      "then": "A Seat record is created, linking the user to the team, specifying the 'seatType', and recording the 'assignedAt' timestamp."
    },
    {
      "given": "A user already has a seat assigned within a specific team.",
      "when": "An attempt is made to assign another seat to the same user within the same team",
      "then": "The system prevents the creation of a duplicate Seat record, ensuring unique seat assignments for each team and user."
    },
    {
      "given": "A team exists in the system.",
      "when": "A new workspace is created for the team with a given name",
      "then": "A Workspace record is created, associating it with the team, setting its name, 'createdAt' timestamp, and leaving 'deletedAt' as null."
    },
    {
      "given": "A workspace exists and is active.",
      "when": "The workspace is marked for deletion",
      "then": "The 'deletedAt' field of the Workspace record is populated with a timestamp, indicating a soft deletion rather than permanent removal."
    },
    {
      "given": "A user and a workspace exist in the system.",
      "when": "The user is granted access to the workspace",
      "then": "A UserWorkspace record is created, linking the user to the workspace, recording the 'createdAt' timestamp, and optionally defining a 'permissionSet'."
    },
    {
      "given": "A user is already associated with a specific workspace.",
      "when": "An attempt is made to create another association for the same user and workspace",
      "then": "The system prevents the creation of a duplicate UserWorkspace record, ensuring unique access associations for each user and workspace."
    },
    {
      "given": "The system requires managing external identity providers.",
      "when": "A new identity provider configuration is saved",
      "then": "An IdentityProvider record is created, storing its 'providerType', optional 'configJson' settings, and 'createdAt' timestamp."
    },
    {
      "given": "A team and an identity provider are configured in the system.",
      "when": "The identity provider is linked to the team",
      "then": "An IdpLink record is created, associating the team with the identity provider and recording the 'createdAt' timestamp."
    },
    {
      "given": "A user successfully authenticates through LinkedIn.",
      "when": "The system captures the user's LinkedIn profile details and access tokens",
      "then": "A LinkedInProfile record is created for the user, storing their 'linkedinProfileId', optional 'displayName', and encrypted 'accessTokenEnc' and 'refreshTokenEnc'."
    },
    {
      "given": "a user exists in the system",
      "when": "the user connects their LinkedIn profile",
      "then": "a 'LinkedInProfile' record should be created, linked to the user, with a unique 'linkedinProfileId', current scope, and creation timestamp."
    },
    {
      "given": "a 'LinkedInProfile' record exists with an 'expiresAt' timestamp",
      "when": "the current date and time pass the 'expiresAt' timestamp",
      "then": "the LinkedIn profile connection should be considered expired, potentially limiting its functionality."
    },
    {
      "given": "a user has an existing 'LinkedInProfile' connected with a specific 'linkedinProfileId'",
      "when": "an attempt is made to connect another LinkedIn profile for the same user with the identical 'linkedinProfileId'",
      "then": "the system should prevent the creation of a duplicate 'LinkedInProfile' entry for that user and LinkedIn profile ID combination."
    },
    {
      "given": "a team exists in the system",
      "when": "a new brand voice is defined for that team with a name and optional description and voice JSON",
      "then": "a 'BrandVoice' record should be created, linked to the team, with the provided details and a creation timestamp."
    },
    {
      "given": "a user and optionally a team exist in the system",
      "when": "a new onboarding profile is created for the user",
      "then": "an 'OnboardingProfile' record should be created, linked to the user (and optionally the team), with a creation timestamp, ready to track onboarding progress, goals, and brand voice."
    },
    {
      "given": "an 'OnboardingProfile' exists for a user",
      "when": "the user completes the onboarding process",
      "then": "the 'onboardedAt' field of the 'OnboardingProfile' should be updated with the completion timestamp."
    },
    {
      "given": "a team or workspace exists in the system",
      "when": "a new role is defined with a name, description, and an association to either the team or the workspace",
      "then": "a 'Role' record should be created, accurately representing its scope within the organization."
    },
    {
      "given": "a unique permission code does not exist",
      "when": "a new permission is created with a unique code and an optional description",
      "then": "a 'Permission' record should be created, making that capability available for assignment to roles."
    },
    {
      "given": "a 'Permission' with a specific 'code' already exists",
      "when": "an attempt is made to create another 'Permission' with the identical 'code'",
      "then": "the system should prevent the creation of a duplicate 'Permission' entry, ensuring all permission codes are unique."
    },
    {
      "given": "an existing 'Role' and an existing 'Permission'",
      "when": "the 'Permission' is assigned to the 'Role'",
      "then": "a 'RolePermission' record should be created, linking the role and the permission, and preventing duplicate assignments of the same permission to the same role."
    },
    {
      "given": "an existing 'User' and an existing 'Role'",
      "when": "the 'Role' is assigned to the 'User', optionally with a specific scope ('scopeType', 'scopeId')",
      "then": "a 'UserRoleRelation' record should be created, linking the user and the role, and preventing duplicate assignments for the same user, role, and scope combination."
    },
    {
      "given": "a user exists and optionally a team or workspace",
      "when": "a new content template is created by the user with a title, type, and optional schema JSON or search text",
      "then": "a 'Template' record should be created, associated with the owner, and optionally a team or workspace, with the provided content details."
    },
    {
      "given": "A user is authenticated and associated with a workspace.",
      "when": "The user creates a new template with required details.",
      "then": "A new Template record is created with a unique ID, default 'private' shared scope, version 1, and current timestamp for 'createdAt' and 'updatedAt', linked to the owner and workspace."
    },
    {
      "given": "An existing template is present in the database.",
      "when": "The template's attributes (e.g., title, content) are updated.",
      "then": "The 'updatedAt' field of the Template record is automatically updated, and the 'version' field is incremented."
    },
    {
      "given": "Multiple templates exist with populated 'searchTsv' fields.",
      "when": "A user performs a search query.",
      "then": "Templates matching the search query via 'searchTsv' are retrieved and presented to the user."
    },
    {
      "given": "An existing template belongs to a specific owner and workspace.",
      "when": "A user attempts to retrieve templates based on owner or workspace.",
      "then": "Only templates associated with the specified 'ownerId' or 'workspaceId' are returned."
    },
    {
      "given": "An existing template and a target workspace are available.",
      "when": "A user shares the template with the target workspace.",
      "then": "A new TemplateShare record is created, linking the template to the target workspace, and recording the 'sharedBy' user and 'createdAt' timestamp."
    },
    {
      "given": "A template has been shared with a specific target workspace via a TemplateShare record.",
      "when": "A user belonging to the target workspace browses for shared templates.",
      "then": "The shared template is discoverable and accessible within their workspace."
    },
    {
      "given": "An existing template and a publisher user are available.",
      "when": "The publisher lists the template on the marketplace with pricing information.",
      "then": "A new TemplateMarketplaceItem record is created, linking the template to the publisher, including 'pricingJson', 'listedAt' timestamp, and an initial 'status'."
    },
    {
      "given": "A template is listed on the marketplace with a specific status.",
      "when": "The publisher updates the status of the marketplace listing (e.g., from 'pending' to 'active' or 'delisted').",
      "then": "The 'status' field of the TemplateMarketplaceItem record is updated accordingly."
    },
    {
      "given": "A user is authenticated and associated with a team or workspace.",
      "when": "The user creates a new content item of a specific type.",
      "then": "A new ContentItem record is created with a unique ID, default status 'DRAFT', version 1, 'createdAt' and 'updatedAt' timestamps, linked to the owner, and optionally to a team or workspace."
    },
    {
      "given": "An existing content item with a specific version.",
      "when": "The content item's title, body, or other editable attributes are updated.",
      "then": "The 'updatedAt' field is automatically updated, the 'version' is incremented, and the 'currentVersionId' may be updated to reflect the latest version."
    },
    {
      "given": "An existing content item is available.",
      "when": "The user initiates the deletion of the content item.",
      "then": "The 'deletedAt' field of the ContentItem record is set to the current timestamp, marking the item as soft-deleted rather than permanently removed."
    },
    {
      "given": "A content item exists in a specific status (e.g., DRAFT).",
      "when": "The owner or an authorized user changes the status of the content item (e.g., to PUBLISHED, ARCHIVED).",
      "then": "The 'status' field of the ContentItem record is updated to the new value."
    },
    {
      "given": "Multiple content items exist with populated 'searchTsv' fields and 'tags'.",
      "when": "A user performs a search query or filters content items by specific tags.",
      "then": "Relevant content items are returned based on matches in 'searchTsv' or the specified 'tags'."
    },
    {
      "given": "A ContentItem exists with a specific ID.",
      "when": "A user modifies the content's body.",
      "then": "A new ContentVersion record should be created, associated with the ContentItem and the author, capturing the new body, a change reason, and a version label."
    },
    {
      "given": "A ContentItem and an Image exist.",
      "when": "The user associates the Image with the ContentItem.",
      "then": "A ContentMedia record should be created, linking the ContentItem to the Image, and optionally defining its position and metadata."
    },
    {
      "given": "A ContentItem exists.",
      "when": "The user uploads a file to be attached to the ContentItem.",
      "then": "An Attachment record should be created, linked to the ContentItem and the uploading user, storing the filename, content type, size, storage path, and checksum."
    },
    {
      "given": "A ContentItem exists.",
      "when": "The user initiates a soft delete operation for the ContentItem.",
      "then": "The 'deleted_at' timestamp for that ContentItem should be populated, marking it as soft-deleted without permanent removal."
    },
    {
      "given": "Multiple ContentItems exist, each belonging to a specific workspace and team.",
      "when": "A user queries for ContentItems within a particular workspace or team.",
      "then": "The system should efficiently retrieve only the ContentItems associated with the specified workspace or team, utilizing the indexed fields."
    },
    {
      "given": "A ContentItem exists.",
      "when": "The user adds a new carousel slide to the content.",
      "then": "A CarouselSlide record should be created, associated with the ContentItem, defining its position, body content, and metadata."
    },
    {
      "given": "A user uploads a new image.",
      "when": "The image is successfully stored.",
      "then": "An Image record should be created, owned by the user, linked to their workspace and team, and storing its source, URL, and metadata."
    },
    {
      "given": "A content item exists and an approval hierarchy is defined for the workspace.",
      "when": "A user submits the content item for approval.",
      "then": "An \"Approval\" record is created with a \"PENDING\" status, linked to the content item, the submitting user, and the relevant approval hierarchy."
    },
    {
      "given": "An approval record exists for a content item with a \"PENDING\" status, and an approver is assigned.",
      "when": "The assigned approver approves the content item.",
      "then": "The \"status\" of the Approval record is updated to \"APPROVED\", an \"ApprovalTransition\" record is created indicating the step change, and the \"updatedAt\" field is updated."
    },
    {
      "given": "An approval record exists for a content item with a \"PENDING\" status, and an approver is assigned.",
      "when": "The assigned approver rejects the content item with comments.",
      "then": "The \"status\" of the Approval record is updated to \"REJECTED\", an \"ApprovalTransition\" record is created with the provided comment, indicating the step change, and the \"updatedAt\" field is updated."
    },
    {
      "given": "A user has administrative privileges for a workspace.",
      "when": "The user defines a new approval hierarchy with a name and a sequence of steps.",
      "then": "An \"ApprovalHierarchy\" record is created for the workspace with the specified name and \"stepsJson\"."
    },
    {
      "given": "An approval process for a content item is active and transitions between steps occur.",
      "when": "An actor performs an action that changes the approval step (e.g., moving from 'Review' to 'Legal Approval').",
      "then": "An \"ApprovalTransition\" record is created, linked to the \"Approval\" record, detailing the \"fromStep\", \"toStep\", \"actorId\", and \"actedAt\"."
    },
    {
      "given": "A content item exists and a workspace is configured.",
      "when": "A user schedules the content item for publication at a specific date, time, and timezone.",
      "then": "A \"Schedule\" record is created, linked to the content item and workspace, with \"scheduledAt\", \"timezone\", and a \"PENDING\" status."
    },
    {
      "given": "A scheduled content item exists.",
      "when": "The user modifies the schedule to be recurring with specific recurrence rules.",
      "then": "The \"recurrenceJson\" field of the \"Schedule\" record is updated, and \"nextRunAt\" is calculated based on the new rules."
    },
    {
      "given": "A workspace exists.",
      "when": "A user adds a new platform profile for a specific publishing platform (e.g., Facebook) with an external ID and configuration.",
      "then": "A \"PlatformProfile\" record is created for the workspace, storing the platform type, external ID, and \"configJson\"."
    },
    {
      "given": "A content item is scheduled for publication.",
      "when": "The system processes the scheduled item at its \"nextRunAt\" time.",
      "then": "A \"PublishJob\" record is created, linked to the \"Schedule\" and the relevant content item and platform profiles, to initiate publication."
    },
    {
      "given": "A content item is prepared for publication and target social media platforms are specified.",
      "when": "A new publish job is scheduled.",
      "then": "A `PublishJob` record should be created with `status` set to `QUEUED`, a default `priority`, and a `createdAt` timestamp."
    },
    {
      "given": "A `PublishJob` exists with `status` `QUEUED` and its `runAt` time is due.",
      "when": "A worker attempts to process the job.",
      "then": "The `PublishJob`'s `workerId` should be assigned, `attemptCount` incremented, `leaseExpiresAt` set, and its `status` updated to `PROCESSING`."
    },
    {
      "given": "A `PublishJob` is being processed by a `workerId`.",
      "when": "The worker successfully publishes the content to the designated platform(s).",
      "then": "A `JobAttempt` record should be created for the successful attempt, and the `PublishJob`'s `status` should be updated (e.g., to `SUCCESS`) with a `publishedAt` timestamp, and `PlatformPost` records should be created for each successful platform publication."
    },
    {
      "given": "A `PublishJob` is being processed by a `workerId`.",
      "when": "The worker encounters an error during publication.",
      "then": "A `JobAttempt` record should be created with `errorText` and `correlationId`, and the `PublishJob`'s `status` should be updated (e.g., to `FAILED` or `RETRY`) with `lastError` updated."
    },
    {
      "given": "A user interacts with a `ContentItem` or an `externalPostId`.",
      "when": "The system records the user's `action` (e.g., like, share).",
      "then": "An `Engagement` record should be created, linking the `userId`, `contentItemId` (if applicable), `externalPostId` (if applicable), and the specific `action`."
    },
    {
      "given": "A `userId` within a `workspaceId` requires a personalized engagement feed.",
      "when": "The system generates the engagement feed content.",
      "then": "An `EngagementFeed` record should be created or updated for the `userId` and `workspaceId` with the generated `feedJson` and `generatedAt` timestamp."
    },
    {
      "given": "The system monitors for trending topics within a `workspaceId`.",
      "when": "A new trending `topic` is identified and evaluated.",
      "then": "A `TrendingSignal` record should be created or updated for the `workspaceId` with the `topic`, `signalJson`, `score`, and `evaluatedAt` timestamp."
    },
    {
      "given": "A user wants to track a competitor's social media presence for their `workspaceId`.",
      "when": "A new competitor account is provided with its `externalAccountId` and `name`.",
      "then": "A `CompetitorAccount` record should be created, associated with the `workspaceId`, `externalAccountId`, and `name`."
    },
    {
      "given": "A workspace exists and a user is authorized to add competitor accounts.",
      "when": "The user attempts to add a new competitor account providing a valid 'workspaceId', 'externalAccountId', and 'type'.",
      "then": "A new 'CompetitorAccount' record is created with a unique 'id', 'addedAt' timestamped to the current time, and linked to the specified 'workspace' and 'addedBy' user."
    },
    {
      "given": "Multiple competitor accounts exist within a specific 'workspaceId'.",
      "when": "A request is made to fetch all competitor accounts for that 'workspaceId'.",
      "then": "A list of 'CompetitorAccount' records associated with the 'workspaceId' is returned, containing details like 'id', 'externalAccountId', and 'type'."
    },
    {
      "given": "An existing 'CompetitorAccount' record with modifiable 'notes'.",
      "when": "A user updates the 'notes' field for that account with a new string value.",
      "then": "The 'notes' field of the 'CompetitorAccount' record is updated to reflect the new value."
    },
    {
      "given": "An existing 'CompetitorAccount' is available for snapshotting.",
      "when": "A system process captures a snapshot of metrics, providing the 'competitorAccountId', 'metricsJson', and optionally 'rawDataJson'.",
      "then": "A new 'CompetitorSnapshot' record is created with a unique 'id', 'snapshotAt' and 'createdAt' timestamped, and correctly linked to the 'competitorAccount'."
    },
    {
      "given": "Multiple snapshots exist for a specific 'CompetitorAccount'.",
      "when": "A request is made to fetch all snapshots for that 'competitorAccountId'.",
      "then": "A list of 'CompetitorSnapshot' records associated with the 'competitorAccountId' is returned, ordered by 'snapshotAt'."
    },
    {
      "given": "A user interacts with an AI service, sending a prompt and receiving a response.",
      "when": "The system logs the interaction, including 'userId', 'prompt', 'responseSnippet', 'tokensIn', 'tokensOut', and 'cost'.",
      "then": "An 'AiPrompt' record is created, capturing the prompt details, user, associated workspace/team (if applicable), and timestamps 'createdAt'."
    },
    {
      "given": "A user has made multiple AI prompts, recorded in the system.",
      "when": "The user requests to view their AI prompt history, potentially filtered by workspace or team.",
      "then": "A list of 'AiPrompt' records associated with the 'userId' is returned, allowing the user to review their past interactions."
    },
    {
      "given": "An AI interaction has completed, with known 'tokensUsed' and 'costEstimate'.",
      "when": "The system records the usage for a specific 'userId', and optionally 'workspaceId' or 'teamId'.",
      "then": "An 'AiUsage' record is created, tracking the 'tokensUsed', 'costEstimate', and 'createdAt' timestamp for the interaction."
    },
    {
      "given": "Multiple 'AiUsage' records exist for various users, workspaces, and teams over a period.",
      "when": "An administrator requests aggregated AI usage for a specific 'workspaceId' within a defined time range.",
      "then": "The total 'tokensUsed' and 'costEstimate' are calculated and returned for that 'workspaceId' within the specified period."
    },
    {
      "given": "An administrator is configuring the AI credit offerings.",
      "when": "They define a new AI credit pack with a unique 'plan' name, a specific 'credits' amount, 'currency', and 'price'.",
      "then": "An 'AiCreditPack' record is created, making this new credit pack available for purchase or allocation."
    },
    {
      "given": "Multiple 'AiCreditPack' records exist, defining various credit purchase options.",
      "when": "A user or system requests a list of all available AI credit packs.",
      "then": "A list of 'AiCreditPack' records, including their 'plan', 'credits', 'currency', and 'price', is returned."
    },
    {
      "given": "A team exists and is authorized to receive AI credits.",
      "when": "An administrator allocates a specific 'creditsTotal' to a 'teamId'.",
      "then": "An 'AiCreditAllocation' record is created for the 'teamId' with 'creditsTotal' and 'creditsRemaining' initially set to 'creditsTotal', and 'allocatedAt' timestamped."
    },
    {
      "given": "An 'AiCreditAllocation' exists for a user or team with a certain amount of 'creditsRemaining'.",
      "when": "The system or user queries for the amount of remaining credits.",
      "then": "The current 'creditsRemaining' value from the corresponding 'AiCreditAllocation' record is returned."
    },
    {
      "given": "An 'AiCreditAllocation' with available 'creditsRemaining'.",
      "when": "A user or team consumes AI credits, resulting in a negative 'delta' value.",
      "then": "An 'AiCreditLedger' record is created for the 'allocationId' with the negative 'delta', the updated 'balanceAfter', and a 'reason' for the deduction. The 'creditsRemaining' in the associated 'AiCreditAllocation' is also updated."
    },
    {
      "given": "An 'AiCreditAllocation' for a user or team.",
      "when": "Additional credits are added to the allocation, resulting in a positive 'delta' value.",
      "then": "An 'AiCreditLedger' record is created for the 'allocationId' with the positive 'delta', the updated 'balanceAfter', and a 'reason' for the top-up. The 'creditsRemaining' in the associated 'AiCreditAllocation' is also updated."
    },
    {
      "given": "An 'AiCreditAllocation' has multiple 'AiCreditLedger' entries recording its credit history.",
      "when": "An administrator or user requests to view the credit transaction history for a specific allocation.",
      "then": "A chronological list of 'AiCreditLedger' records associated with the 'allocationId' is returned, detailing each credit transaction's 'delta', 'balanceAfter', and 'reason'."
    },
    {
      "given": "An AI credit allocation has been made for a user.",
      "when": "Credits are recorded as allocated to the user for a specific reason.",
      "then": "An AiCreditLedger entry is created, recording the `creditsAllocated`, `reason`, and `createdAt`."
    },
    {
      "given": "An AiCreditLedger entry exists with `creditsAllocated` for a user.",
      "when": "The user consumes a certain amount of AI credits.",
      "then": "The `creditsUsed` field in the corresponding AiCreditLedger entry is updated to reflect the consumption."
    },
    {
      "given": "A team and an AI Credit Pack are available for purchase.",
      "when": "The team purchases an AI Credit Pack for a specified amount.",
      "then": "A CreditTopup entry is created with the pack details, `credits`, `amount`, a 'purchased' or 'pending' `status`, and `purchasedAt` timestamp."
    },
    {
      "given": "A team or workspace performs an action that requires a new metric to be tracked for a specific period.",
      "when": "The system attempts to log consumption for a new metric within a new period for that team or workspace.",
      "then": "A QuotaCounter entry is created with `consumed` initialized to 0, for the specified `teamId`/`workspaceId`, `metric`, and `periodStart`."
    },
    {
      "given": "A QuotaCounter entry exists for a specific team/workspace, metric, and period.",
      "when": "The team or workspace consumes more of the tracked metric.",
      "then": "The `consumed` field of the corresponding QuotaCounter entry is incremented by the consumed amount."
    },
    {
      "given": "A user in a workspace initiates a help tour identified by a unique key.",
      "when": "The system records the start of the help tour for that user and workspace.",
      "then": "A HelpTour entry is created with the `key`, `workspaceId`, `userId`, and `createdAt` timestamp, and `completedAt` is null."
    },
    {
      "given": "A HelpTour entry exists for a user in a workspace for a specific key, with `completedAt` as null.",
      "when": "The user completes the help tour.",
      "then": "The `completedAt` field of the HelpTour entry is updated with the completion timestamp."
    },
    {
      "given": "A user in a workspace configures details for an external service.",
      "when": "The user activates a new integration of a specific type with the provided configuration.",
      "then": "An Integration entry is created with the `workspaceId`, `type`, `configJson`, and an 'active' `status`."
    },
    {
      "given": "An active Integration entry exists for a workspace.",
      "when": "The user deactivates the integration.",
      "then": "The `status` field of the Integration entry is updated to 'inactive'."
    },
    {
      "given": "An active Integration exists for a workspace.",
      "when": "An event is received from the external service linked to the integration.",
      "then": "An IntegrationEvent entry is created with the `integrationId`, `eventType`, `payload`, a 'pending' `status`, and `receivedAt` timestamp."
    },
    {
      "given": "An IntegrationEvent exists with a 'pending' status.",
      "when": "The system successfully processes the event's payload.",
      "then": "The `status` of the IntegrationEvent is updated to 'processed', and `processedAt` is set to the current timestamp."
    },
    {
      "given": "An IntegrationEvent exists with a 'pending' status and the `retries` count is below the maximum limit.",
      "when": "The system attempts to process the event but encounters an error.",
      "then": "The `status` of the IntegrationEvent is updated to 'failed' or 'retrying', and the `retries` count is incremented."
    },
    {
      "given": "A user in a workspace requests to generate a new API key.",
      "when": "The user specifies desired `scopes` and `rateLimitJson` for the key.",
      "then": "An ApiKey entry is created with a hashed `keyHash`, assigned `scopes`, `rateLimitJson`, and `active` status set to true."
    },
    {
      "given": "An active ApiKey exists for a workspace.",
      "when": "The user deactivates the API key.",
      "then": "The `active` field of the ApiKey entry is set to false."
    },
    {
      "given": "An active ApiKey is used to authenticate an API request.",
      "when": "The system successfully processes an API request using the key.",
      "then": "The `lastUsedAt` field of the ApiKey entry is updated with the current timestamp."
    },
    {
      "given": "A content item is ready for a plagiarism check.",
      "when": "A plagiarism check is initiated for the content item using a specific `engine`.",
      "then": "A PlagiarismCheck entry is created with the `contentItemId`, `engine`, and `checkedAt` timestamp, with `resultJson` and `score` initially null."
    },
    {
      "given": "A PlagiarismCheck entry exists for a content item with null `resultJson` and `score`.",
      "when": "The plagiarism check engine returns results for the content item.",
      "then": "The `resultJson` and `score` fields of the PlagiarismCheck entry are updated with the returned data."
    },
    {
      "given": "A content item is submitted for a specific compliance check.",
      "when": "A content compliance check of a certain `checkType` is initiated for the content item.",
      "then": "A ContentCompliance entry is created with the `contentItemId` and `checkType`, and `resultJson` is initially null."
    },
    {
      "given": "A ContentCompliance entry exists for a content item with null `resultJson`.",
      "when": "The compliance check system returns results for the content item.",
      "then": "The `resultJson` field of the ContentCompliance entry is updated with the returned data."
    },
    {
      "given": "a content item exists with a specific ID",
      "when": "a compliance check is performed and its result is recorded",
      "then": "the content item's compliance status, check timestamp, and detailed result JSON should be stored"
    },
    {
      "given": "multiple compliance checks have been recorded for various content items",
      "when": "a user requests the compliance status for a specific content item and status",
      "then": "the system should efficiently retrieve the relevant compliance record(s)"
    },
    {
      "given": "a content item exists",
      "when": "analytics data (metricsJson) is generated and recorded for that content item",
      "then": "the system should store the metrics along with the content item ID and the recording timestamp"
    },
    {
      "given": "analytics data has been recorded for several content items at different times",
      "when": "a user queries for analytics related to a specific content item",
      "then": "the system should return all recorded analytics for that content item"
    },
    {
      "given": "analytics data has been recorded for several content items at different times",
      "when": "a user queries for analytics recorded within a specific time range",
      "then": "the system should efficiently return all analytics records within that range"
    },
    {
      "given": "a user in a workspace wants to export a report",
      "when": "they request a report export specifying format and parameters",
      "then": "a new report export record should be created with 'requested' status, the requestor and workspace IDs, and the request timestamp"
    },
    {
      "given": "a report export request has been initiated",
      "when": "the report generation process completes successfully and a file path is available",
      "then": "the system should update the report export record with the 'completed' status, the file path, and the completion timestamp"
    },
    {
      "given": "multiple report export requests exist for a workspace and different requestors",
      "when": "a user queries for report exports associated with a specific workspace or requestor",
      "then": "the system should efficiently retrieve the relevant report export records"
    },
    {
      "given": "a workspace exists",
      "when": "an administrator defines a new data retention policy with specific rules",
      "then": "a new retention policy record should be created, linked to the workspace, with a name, the rules JSON, and a creation timestamp"
    },
    {
      "given": "multiple retention policies are defined for various workspaces",
      "when": "a user requests all retention policies for a specific workspace",
      "then": "the system should efficiently retrieve all policies associated with that workspace"
    },
    {
      "given": "a team and a geographical region are identified",
      "when": "an administrator configures data residency settings for that team in that region",
      "then": "a new region data configuration record should be created, linked to the team and region, including the data residency JSON"
    },
    {
      "given": "data residency configurations exist for various teams and regions",
      "when": "a user queries for the data residency configuration for a specific team and region",
      "then": "the system should efficiently retrieve the unique configuration for that team and region"
    },
    {
      "given": "a user in a workspace encounters an issue",
      "when": "they submit a new support ticket with a subject, body, status, and priority",
      "then": "a new support ticket record should be created, linked to the workspace and the requester, with default status and priority, and a creation timestamp"
    },
    {
      "given": "an unassigned support ticket exists",
      "when": "an agent is assigned to the ticket and its status or priority is updated",
      "then": "the support ticket record should reflect the assigned agent, the new status, priority, and an updated timestamp"
    },
    {
      "given": "multiple support tickets exist with varying statuses, priorities, workspaces, and requesters",
      "when": "a user queries for tickets within a specific workspace by requester",
      "then": "the system should efficiently retrieve all tickets matching the workspace and requester"
    },
    {
      "given": "multiple support tickets exist with varying statuses, priorities, workspaces, and requesters",
      "when": "a user queries for tickets by status and priority",
      "then": "the system should efficiently retrieve all tickets matching the specified status and priority"
    },
    {
      "given": "a user in a workspace needs guidance on a feature",
      "when": "they start a specific help tour identified by a unique key",
      "then": "a new help tour record should be created, linked to the workspace and user, with the tour key and a creation timestamp"
    },
    {
      "given": "a user has started a help tour",
      "when": "they complete the help tour",
      "then": "the help tour record should be updated with a completion timestamp"
    },
    {
      "given": "multiple help tour records exist for various users and workspaces",
      "when": "a user queries for their help tour progress within a specific workspace",
      "then": "the system should efficiently retrieve all help tour records for that user and workspace"
    },
    {
      "given": "a user attempts to start a help tour with the same key they have already started in the same workspace",
      "when": "the system processes this request",
      "then": "it should ensure only one active or completed record exists for that user, workspace, and help tour key, preventing duplicates"
    },
    {
      "given": "a new language is to be supported",
      "when": "an administrator defines a new locale with a unique code and name",
      "then": "a new locale record should be created with the specified code, name, and a creation timestamp"
    },
    {
      "given": "multiple locales have been defined",
      "when": "a user requests details for a specific locale code",
      "then": "the system should retrieve the locale's name and other associated data"
    },
    {
      "given": "a locale exists",
      "when": "a new translation is provided for that locale",
      "then": "a new translation record should be created, linked to the locale"
    },
    {
      "given": "a locale and a workspace exist",
      "when": "a new translation is provided that is specific to that workspace",
      "then": "a new translation record should be created, linked to the locale and optionally to the workspace"
    },
    {
      "given": "multiple translations exist for various locales and workspaces",
      "when": "a user requests all translations for a specific locale",
      "then": "the system should retrieve all global and workspace-specific translations for that locale"
    },
    {
      "given": "multiple translations exist for various locales and workspaces",
      "when": "a user requests translations for a specific locale within a particular workspace",
      "then": "the system should retrieve only the translations relevant to that locale and workspace"
    },
    {
      "given": "A user is in a specific workspace and locale context.",
      "when": "The user attempts to create a new translation by providing a unique key, text, and locale ID.",
      "then": "A new 'Translation' entry should be created in the database, associated with the correct workspace and locale."
    },
    {
      "given": "An existing 'Translation' for a specific key, locale, and workspace.",
      "when": "The user updates the text content of that translation.",
      "then": "The 'text' and 'updatedAt' fields of the 'Translation' record should be updated accordingly."
    },
    {
      "given": "An authenticated user specifies a file path, an import type (e.g., 'csv'), and a target workspace.",
      "when": "The user initiates an import operation.",
      "then": "A new 'ImportJob' record should be created with 'status' set to 'PENDING', associated with the user and workspace, and 'createdAt' timestamped."
    },
    {
      "given": "An 'ImportJob' record exists with a 'status' of 'PENDING' or 'PROCESSING'.",
      "when": "The background import process completes successfully.",
      "then": "The 'status' of the 'ImportJob' should be updated to 'COMPLETED' and the 'completedAt' field should be timestamped."
    },
    {
      "given": "An authenticated user specifies an export format (e.g., 'json'), a target workspace, and an output file path.",
      "when": "The user initiates an export operation.",
      "then": "A new 'ExportJob' record should be created with 'status' set to 'PENDING', associated with the user and workspace, and 'createdAt' timestamped."
    },
    {
      "given": "An 'ExportJob' record exists with a 'status' of 'PENDING' or 'PROCESSING'.",
      "when": "The background export process finishes successfully.",
      "then": "The 'status' of the 'ExportJob' should be updated to 'COMPLETED' and the 'completedAt' field should be timestamped."
    },
    {
      "given": "An administrator user with permissions to manage stock image providers.",
      "when": "The administrator provides a unique name and configuration details for a new stock image provider.",
      "then": "A new 'StockImageProvider' record should be created in the database, with its 'createdAt' field timestamped."
    },
    {
      "given": "An existing 'StockImageProvider' and an image retrieved from that provider with a unique 'providerImageId' and associated metadata.",
      "when": "The system determines that this image needs to be cached for future use.",
      "then": "A new 'StockImageCache' record should be created, linking to the 'StockImageProvider' and storing the 'providerImageId' and metadata."
    },
    {
      "given": "A 'Team' exists and has selected a specific 'PlanTier' for subscription.",
      "when": "The team successfully completes the payment and subscription activation process (e.g., via Stripe).",
      "then": "A 'Subscription' record should be created for the 'Team' with the chosen 'plan', 'status' set to 'ACTIVE', and 'nextBillingAt' defined."
    },
    {
      "given": "An active 'Subscription' for a team.",
      "when": "The subscription's status changes due to a recurring event (e.g., renewal, cancellation, or payment failure).",
      "then": "The 'status' field of the 'Subscription' record should be updated to reflect the new state (e.g., 'CANCELLED', 'PAST_DUE')."
    },
    {
      "given": "An active 'Subscription' reaches its next billing cycle.",
      "when": "The system processes the billing event for the subscription.",
      "then": "A new 'Invoice' record should be generated, linked to the 'Subscription', with a 'status' of 'PENDING' and the 'amount' specified."
    },
    {
      "given": "An existing 'Invoice' record with a 'status' of 'PENDING'.",
      "when": "Payment for the invoice is successfully received and processed.",
      "then": "The 'status' of the 'Invoice' should be updated to 'PAID' and the 'paidAt' field should be timestamped."
    },
    {
      "given": "A specific 'User' and an event that triggers the need for a notification (e.g., task completion, system alert).",
      "when": "The system generates a new notification for that user.",
      "then": "A 'Notification' record should be created for the 'User' with the specified 'type', 'channel', 'payload', and a 'status' of 'PENDING'."
    },
    {
      "given": "A 'Notification' record exists with a 'status' of 'PENDING'.",
      "when": "The notification is successfully dispatched to the user through its designated channel (e.g., email, in-app).",
      "then": "The 'status' of the 'Notification' should be updated to 'SENT' and the 'sentAt' field should be timestamped."
    },
    {
      "given": "An administrator wants to define a role.",
      "when": "They create a new role and specify no team or workspace scope.",
      "then": "The system should create a global role, available system-wide."
    },
    {
      "given": "An administrator wants to define a role within a specific team.",
      "when": "They create a new role and associate it with an existing Team.",
      "then": "The system should create a team-scoped role, available only within that Team."
    },
    {
      "given": "An administrator wants to define a role within a specific workspace.",
      "when": "They create a new role and associate it with an existing Workspace.",
      "then": "The system should create a workspace-scoped role, available only within that Workspace."
    },
    {
      "given": "A defined Role and a set of Permissions exist.",
      "when": "An administrator configures the Role to include the set of Permissions.",
      "then": "The Role should grant all associated Permissions to any User assigned that Role."
    },
    {
      "given": "A User and a Role (global, team-scoped, or workspace-scoped) exist.",
      "when": "An administrator assigns the Role to the User.",
      "then": "The User should inherit the permissions and scope defined by the assigned Role."
    },
    {
      "given": "A global Locale and a global Translation for a key are configured.",
      "when": "A request for translation of that key is made for that Locale without a specific workspace context.",
      "then": "The system should return the global Translation."
    },
    {
      "given": "A Locale, an existing Workspace, and a Translation for a key specifically configured for that Workspace.",
      "when": "A request for translation of that key is made for that Locale within the context of that specific Workspace.",
      "then": "The system should return the workspace-specific Translation, overriding any global Translation for that key."
    },
    {
      "given": "A Locale, an existing Workspace, and a global Translation for a key exists, but no workspace-specific Translation for that key in that Workspace is configured.",
      "when": "A request for translation of that key is made for that Locale within the context of that specific Workspace.",
      "then": "The system should fall back and return the global Translation for that key."
    },
    {
      "given": "An actor performs an action on a target within the system.",
      "when": "The system captures the details of this event.",
      "then": "A new AuditLog entry should be created, containing the actorId, actorType, action, targetType, targetId, and a createdAt timestamp."
    },
    {
      "given": "A ContentItem exists in the system.",
      "when": "A request is made to perform a plagiarism check on this ContentItem using a specific PlagiarismEngine.",
      "then": "A new PlagiarismCheck record should be created, linked to the ContentItem, with the specified engine and checkedAt timestamp."
    },
    {
      "given": "An external service sends a webhook payload to the system.",
      "when": "The system's webhook listener receives the payload.",
      "then": "A new WebhookEvent record should be created with status PENDING, receivedAt timestamp, and the payload, provider, and eventType stored."
    },
    {
      "given": "A WebhookEvent record exists with status PENDING.",
      "when": "The system successfully processes the WebhookEvent's payload.",
      "then": "The WebhookEvent record's status should be updated to SUCCESS and processedAt timestamp should be recorded."
    },
    {
      "given": "A user has an unread notification associated with their userId.",
      "when": "The user marks the notification as read through the application.",
      "then": "The 'readAt' field of the corresponding Notification record should be updated with the current timestamp."
    },
    {
      "given": "A PostgreSQL database",
      "when": "the Scribl migration script is executed",
      "then": "an 'extensions' schema should exist, created if it does not already exist"
    },
    {
      "given": "A PostgreSQL database with an 'extensions' schema",
      "when": "the Scribl migration script is executed",
      "then": "the 'pgcrypto' extension should be installed into the 'extensions' schema, created if it does not already exist"
    },
    {
      "given": "A PostgreSQL database",
      "when": "the Scribl migration script is executed",
      "then": "the 'pg_trgm' extension should be installed into the 'public' schema, created if it does not already exist"
    },
    {
      "given": "A PostgreSQL database",
      "when": "the Scribl migration script is executed",
      "then": "the 'btree_gist' extension should be installed into the 'public' schema, created if it does not already exist"
    },
    {
      "given": "A PostgreSQL database",
      "when": "the main migration section begins execution",
      "then": "a database transaction should be initiated"
    },
    {
      "given": "A PostgreSQL database where some or all target schemas or extensions might already exist",
      "when": "the Scribl migration script is executed",
      "then": "existing schemas and extensions should not be re-created or cause errors, and the database state should remain consistent due to idempotent operations ('IF NOT EXISTS', 'guarded DO blocks')"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'user_role' is executed",
      "then": "The 'user_role' ENUM type is created with values 'ADMIN', 'EDITOR', 'APPROVER', 'VIEWER', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'seat_type' is executed",
      "then": "The 'seat_type' ENUM type is created with values 'STANDARD', 'ADMIN', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'content_type' is executed",
      "then": "The 'content_type' ENUM type is created with values 'POST', 'ARTICLE', 'CAROUSEL', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'content_status' is executed",
      "then": "The 'content_status' ENUM type is created with values 'DRAFT', 'SCHEDULED', 'PUBLISHED', 'ARCHIVED', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'schedule_status' is executed",
      "then": "The 'schedule_status' ENUM type is created with values 'PENDING', 'COMPLETED', 'FAILED', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'approval_status' is executed",
      "then": "The 'approval_status' ENUM type is created with values 'PENDING', 'APPROVED', 'REJECTED', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'plan_tier' is executed",
      "then": "The 'plan_tier' ENUM type is created with values 'NORMAL', 'PRO', 'ENTERPRISE', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'invoice_status' is executed",
      "then": "The 'invoice_status' ENUM type is created with values 'PENDING', 'PAID', 'FAILED', 'VOID', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'notification_channel' is executed",
      "then": "The 'notification_channel' ENUM type is created with values 'IN_APP', 'EMAIL', 'SLACK', 'TEAMS', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'notification_status' is executed",
      "then": "The 'notification_status' ENUM type is created with values 'PENDING', 'SENT', 'READ', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'webhook_status' is executed",
      "then": "The 'webhook_status' ENUM type is created with values 'PENDING', 'PROCESSED', 'FAILED', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'publish_job_status' is executed",
      "then": "The 'publish_job_status' ENUM type is created with values 'QUEUED', 'RUNNING', 'FAILED', 'SUCCESS', 'CANCELLED', 'DLQ', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'engagement_action' is executed",
      "then": "The 'engagement_action' ENUM type is created with values 'LIKE', 'COMMENT', 'SHARE', 'CLICK', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'publish_platform' is executed",
      "then": "The 'publish_platform' ENUM type is created with values 'LINKEDIN', 'X', 'INSTAGRAM', 'YOUTUBE', 'FACEBOOK', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'integration_type' is executed",
      "then": "The 'integration_type' ENUM type is created with values 'SLACK', 'CRM', 'CALENDAR', 'SALESFORCE', 'HUBSPOT', 'UNSPLASH', 'PEXELS', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'support_priority' is executed",
      "then": "The 'support_priority' ENUM type is created with values 'LOW', 'MEDIUM', 'HIGH', 'URGENT', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'support_status' is executed",
      "then": "The 'support_status' ENUM type is created with values 'OPEN', 'PENDING', 'RESOLVED', 'CLOSED', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'compliance_status' is executed",
      "then": "The 'compliance_status' ENUM type is created with values 'PASS', 'WARN', 'FAIL', and repeated execution causes no error"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent migration script for 'plagiarism_engine' is executed",
      "then": "The 'plagiarism_engine' ENUM type is created with values 'INTERNAL', 'EXTERNAL', and repeated execution causes no error"
    },
    {
      "given": "A new user wants to register for the platform",
      "when": "The user provides a unique email address and a name",
      "then": "A new user record is created with a system-generated ID, a default role of 'EDITOR', and the specified email and name. The created_at and updated_at timestamps are automatically set."
    },
    {
      "given": "A user with a specific email address already exists in the system",
      "when": "Another user attempts to register using the exact same email address",
      "then": "The registration attempt fails due to the unique email constraint, and no new user record is created."
    },
    {
      "given": "An authenticated user wants to create a new team",
      "when": "The user provides a unique team name",
      "then": "A new team record is created with a system-generated ID, the creating user set as the owner, a default plan of 'NORMAL', a default seat count of 1, and the created_at timestamp is automatically set."
    },
    {
      "given": "An existing team and an existing user who is not yet a member of that team",
      "when": "A team administrator invites the user to the team with a specified role",
      "then": "A new team_member record is created with a system-generated ID, linking the team and user, with the specified role, a default status of 'invited', and the invited_at timestamp automatically set."
    },
    {
      "given": "A user has been invited to a team, and their team_member record has a 'invited' status",
      "when": "The invited user accepts the invitation to join the team",
      "then": "The existing team_member record's status is updated to 'accepted', and the accepted_at timestamp is set to the current time."
    },
    {
      "given": "An existing team and an existing user who is a member of that team",
      "when": "A seat of a specific type is assigned to the user within that team",
      "then": "A new seat record is created with a system-generated ID, linking the user and team, with the specified seat type, and the assigned_at timestamp automatically set."
    },
    {
      "given": "A user already has a seat assigned within a specific team",
      "when": "An attempt is made to assign another seat to the same user within the exact same team",
      "then": "The seat assignment fails due to the unique constraint on (team_id, user_id), and no new seat record is created."
    },
    {
      "given": "An existing team",
      "when": "A user associated with that team creates a new workspace with a unique name",
      "then": "A new workspace record is created with a system-generated ID, associated with the specified team, and the created_at and updated_at timestamps are automatically set."
    },
    {
      "given": "An existing user and an existing workspace",
      "when": "A team administrator grants the user access to the workspace with a specific set of permissions",
      "then": "A new user_workspace record is created with a system-generated ID, linking the user and workspace, storing the specified permission set, and the created_at timestamp is automatically set."
    },
    {
      "given": "A user already has access to a specific workspace with defined permissions",
      "when": "An attempt is made to grant the same user access to the exact same workspace again",
      "then": "The access grant fails due to the unique constraint on (user_id, workspace_id), and no new user_workspace record is created."
    },
    {
      "given": "A user is authenticated and part of a team and workspace",
      "when": "They create a new content item with a title and initial body",
      "then": "A new 'content_items' record is created with 'DRAFT' status, owned by the user, and an initial 'content_versions' record is generated for the content body."
    },
    {
      "given": "An existing content item with an initial version",
      "when": "The content owner updates the body of the content item and provides a change reason",
      "then": "A new record is created in 'content_versions' with the updated body and author, and the 'content_items' record is updated to reflect the new version ID and increment its version number."
    },
    {
      "given": "An existing content item and an image previously uploaded to the system",
      "when": "The user associates the image with the content item at a specified position",
      "then": "A new 'content_media' record is created, linking the content item to the image with its defined position."
    },
    {
      "given": "An existing content item",
      "when": "The user adds multiple carousel slides to the content item, each with its own body and position",
      "then": "Multiple 'carousel_slides' records are created, linked to the content item, accurately reflecting their content and sequence."
    },
    {
      "given": "An existing content item and a file to be attached",
      "when": "The user attaches the file to the content item",
      "then": "A new 'attachments' record is created, storing the file's metadata (filename, type, size, storage path) and linking it to the content item."
    },
    {
      "given": "An administrator is authenticated within a specific workspace",
      "when": "They define a new approval hierarchy by providing a name and a JSON structure of approval steps",
      "then": "A new 'approval_hierarchies' record is created for the workspace, storing the structured approval workflow."
    },
    {
      "given": "An existing content item in a workspace with a defined approval hierarchy",
      "when": "A user submits the content item for approval using a specific hierarchy",
      "then": "A new 'approvals' record is created with 'PENDING' status, linking the content item, the submitting user, and the chosen hierarchy, awaiting the first approver's action."
    },
    {
      "given": "A content item has a 'PENDING' approval record, awaiting action from a designated approver at a specific step",
      "when": "The designated approver transitions the approval to the next step (e.g., approves or rejects) and optionally adds a comment",
      "then": "The 'status' in the 'approvals' record is updated, and a new 'approval_transitions' record is created, documenting the step change, the actor, and any associated comments and timestamp."
    },
    {
      "given": "A content item exists within a workspace",
      "when": "A user schedules the content item for a specific future date and time, specifying a timezone",
      "then": "A 'schedules' record should be created with status 'PENDING', the specified 'scheduled_at' and 'timezone', and linked to the content item and workspace"
    },
    {
      "given": "A content item exists within a workspace",
      "when": "A user schedules the content item with a recurrence pattern (e.g., daily, weekly, monthly)",
      "then": "A 'schedules' record should be created with 'PENDING' status, including the 'recurrence_json', the initial 'scheduled_at', and a calculated 'next_run_at' if applicable"
    },
    {
      "given": "A workspace has a connected publishing 'platform_profile' or specific platform account (e.g., 'linked_in_profiles')",
      "when": "A 'schedules' record's 'scheduled_at' or 'next_run_at' has passed and its status is 'PENDING'",
      "then": "A 'publish_jobs' record should be created with status 'QUEUED', linking to the content item, schedule, and platform profile, with 'run_at' set to the scheduled time"
    },
    {
      "given": "A 'publish_jobs' record exists with status 'QUEUED' and associated content item and platform profile",
      "when": "A worker processes the 'publish_jobs' record and successfully publishes the content to the external platform",
      "then": "A 'job_attempts' record should be created for the successful attempt, a 'platform_posts' record should be created with the 'external_post_id' and a 'PUBLISHED' status, and the 'publish_jobs' record's status should be updated to 'PUBLISHED' with 'published_at' set"
    },
    {
      "given": "A 'publish_jobs' record exists with status 'QUEUED', an 'attempt_count' below the maximum allowed, and associated content item and platform profile",
      "when": "A worker attempts to process the 'publish_jobs' record but fails to publish the content to the external platform",
      "then": "A 'job_attempts' record should be created with 'error_text', the 'publish_jobs' record's 'attempt_count' should be incremented, its 'last_error' should be updated, and its 'run_at' should be scheduled for a retry"
    },
    {
      "given": "A 'publish_jobs' record exists with a 'status' indicating failure and its 'attempt_count' has reached the maximum allowed retries",
      "when": "The system processes this failed 'publish_jobs' record",
      "then": "The 'publish_jobs' record's 'status' should be updated to a final 'FAILED' state, indicating no further retries will be attempted"
    },
    {
      "given": "A user is managing a workspace",
      "when": "The user connects their workspace to an external publishing platform (e.g., LinkedIn)",
      "then": "A 'platform_profiles' record (and a specific platform profile like 'linked_in_profiles' if applicable) should be created, securely storing the necessary authentication tokens and configuration details for that platform"
    },
    {
      "given": "A 'platform_posts' record exists, linked to a successful 'publish_job' and content item",
      "when": "The system receives updated metrics or status information from the external publishing platform for that post",
      "then": "The 'metrics_json' or 'status' field of the 'platform_posts' record should be updated to reflect the latest information from the platform"
    },
    {
      "given": "A content item exists in the system",
      "when": "Analytics data is collected for that content item",
      "then": "The analytics data should be recorded in the 'analytics' table, linked to the content item ID"
    },
    {
      "given": "A user and a content item exist in the system",
      "when": "The user performs an engagement action on the content item",
      "then": "An engagement record should be created in the 'engagements' table, linking the user, content item, and the specific action"
    },
    {
      "given": "A user and an external post ID exist",
      "when": "The user performs an engagement action on the external post",
      "then": "An engagement record should be created in the 'engagements' table, linking the user, external post ID, and the specific action"
    },
    {
      "given": "A user interacts with a content item that was suggested by an AI",
      "when": "The user performs an engagement action on the AI-suggested content item",
      "then": "An engagement record should be created in the 'engagements' table, linking the user, content item, action, and the associated 'ai_suggestion_id'"
    },
    {
      "given": "A workspace and a user exist with relevant engagement data",
      "when": "An engagement feed is generated for the user within that workspace",
      "then": "A record should be created or updated in the 'engagement_feed' table, containing the personalized 'feed_json' for that user and workspace"
    },
    {
      "given": "A workspace has content and user engagement data",
      "when": "The system processes this data to identify trending topics",
      "then": "Records should be created or updated in the 'trending_signals' table for each identified topic, including its 'topic', 'signal_json', and calculated 'score' for the workspace"
    },
    {
      "given": "A workspace exists in the system",
      "when": "A new competitor account is added to be tracked for that workspace",
      "then": "A record should be created in the 'competitor_accounts' table, linking to the workspace and storing the competitor's 'external_account_id' and 'name'"
    },
    {
      "given": "A competitor account is being tracked for a workspace",
      "when": "A snapshot of the competitor's performance metrics is taken",
      "then": "A record should be created in the 'competitor_snapshots' table, linked to the 'competitor_account_id', containing the 'metrics_json' and optionally 'raw_data_json' for that snapshot"
    },
    {
      "given": "A user initiates an AI request by providing a prompt.",
      "when": "The AI service processes the prompt and returns a response, along with details like tokens used and estimated cost.",
      "then": "A record of the prompt, context, model, response, tokens, and cost is stored in 'ai_prompts', and the aggregated usage (tokens, cost) is updated in 'ai_usage' for the respective user/team/workspace."
    },
    {
      "given": "An administrator or system wants to allocate a specific amount of AI credits to a user or team.",
      "when": "The credit allocation process is triggered with a target user/team and a credit amount.",
      "then": "A new entry is created in 'ai_credit_allocations' tracking the total and remaining credits, and a corresponding ledger entry is recorded in 'ai_credit_ledger' reflecting the credit increase."
    },
    {
      "given": "A team decides to purchase an AI credit pack that has been defined in 'ai_credit_packs'.",
      "when": "The team successfully completes the payment for a chosen credit pack.",
      "then": "A 'credit_topups' record is created with the purchase details, the team's 'credits_total' and 'credits_remaining' in 'ai_credit_allocations' are increased by the pack's credits, and a corresponding ledger entry is added to 'ai_credit_ledger'."
    },
    {
      "given": "A user or team has available AI credits in 'ai_credit_allocations' and performs an action that consumes AI resources.",
      "when": "The system calculates the cost of the AI resource consumption (e.g., tokens used) and attempts to deduct it from the available credits.",
      "then": "The 'credits_remaining' for the user/team in 'ai_credit_allocations' is reduced by the consumption cost, and a corresponding deduction entry is recorded in 'ai_credit_ledger'."
    },
    {
      "given": "An action occurs that contributes to a trackable metric (e.g., 'AI_PROMPTS_PER_DAY') for a specific team or workspace.",
      "when": "The system records the occurrence of this action within its predefined period.",
      "then": "The 'consumed' value for the corresponding 'team_id', 'workspace_id', 'metric', and 'period_start' in 'quota_counters' is incremented to reflect the usage."
    },
    {
      "given": "A user is interacting with an in-application help tour identified by a unique key.",
      "when": "The user successfully navigates through and completes all steps of the help tour.",
      "then": "The 'completed_at' timestamp is updated for that specific 'workspace_id', 'user_id', and 'key' in the 'help_tours' table."
    },
    {
      "given": "The application needs to display text for a specific key in a user's selected locale.",
      "when": "The application requests the translation for the given key and locale code.",
      "then": "The corresponding 'text' from the 'translations' table, linked via 'locale_id' to the requested locale 'code', is retrieved and returned."
    },
    {
      "given": "An administrator wishes to add a new supported language or modify an existing translation.",
      "when": "The administrator provides a new locale code and name, or updates the text for a specific key in a given locale.",
      "then": "A new entry is created in 'locales' if a new language is added, or an existing entry in 'translations' for the specified 'locale_id' and 'key' has its 'text' and 'updated_at' fields updated."
    },
    {
      "given": "a workspace exists and an integration type is available",
      "when": "a user configures a new integration for their workspace",
      "then": "the system should create an 'integration' record with the specified type and configuration, and set its status"
    },
    {
      "given": "an active integration exists",
      "when": "an event is received from the external integration",
      "then": "the system should record an 'integration_event' with its payload and status, and attempt to process it"
    },
    {
      "given": "an integration event fails to process",
      "when": "the system attempts to reprocess the event",
      "then": "the 'integration_event' record's 'retries' count should increment and its status should be updated"
    },
    {
      "given": "a workspace exists",
      "when": "a user creates a new API key for their workspace with specific scopes and a name",
      "then": "the system should generate a unique API key, store its hash, assign the specified scopes, and mark it as active"
    },
    {
      "given": "an active API key exists for a workspace",
      "when": "the user deactivates the API key",
      "then": "the system should update the API key's 'active' status to false"
    },
    {
      "given": "an active API key exists",
      "when": "the API key is used to access the system",
      "then": "the system should record the 'last_used_at' timestamp for that API key"
    },
    {
      "given": "a workspace and a user exist with a file path for import data",
      "when": "the user initiates a new data import job of a specific type",
      "then": "the system should create an 'import_job' record with 'status' set to pending or processing, and store relevant parameters"
    },
    {
      "given": "an import job is in progress",
      "when": "the import process completes successfully or with errors",
      "then": "the system should update the 'import_job' record's 'status' and 'completed_at' timestamp"
    },
    {
      "given": "a workspace and a user exist with a desired export format",
      "when": "the user initiates a new data export job",
      "then": "the system should create an 'export_job' record with 'status' set to pending or processing, and store relevant parameters"
    },
    {
      "given": "an export job is in progress",
      "when": "the export process completes successfully or with errors",
      "then": "the system should update the 'export_job' record's 'status' and 'completed_at' timestamp"
    },
    {
      "given": "a system administrator",
      "when": "a new stock image provider needs to be integrated",
      "then": "the system should allow creating a 'stock_image_provider' record with its name and configuration details"
    },
    {
      "given": "an enabled stock image provider",
      "when": "a user searches for or selects a stock image from that provider",
      "then": "the system should cache the image's metadata and provider-specific ID in 'stock_image_cache' for future quick retrieval"
    },
    {
      "given": "a team exists and available subscription plans are defined",
      "when": "the team subscribes to a specific plan via a payment gateway (e.g., Stripe)",
      "then": "the system should create a 'subscription' record for the team, link it to the payment gateway ID, and set its status and next billing date"
    },
    {
      "given": "an active subscription is due for billing",
      "when": "the payment gateway processes a payment for the subscription",
      "then": "the system should create an 'invoice' record for the subscription with the amount, payment gateway invoice ID, and set its status to paid, updating 'paid_at' and 'pdf_url'"
    },
    {
      "given": "a payment gateway or external service sends a webhook event to the system",
      "when": "the system receives the webhook event",
      "then": "the system should record a 'webhook_event' with the provider, event type, payload, signature, and set its status to 'PENDING'"
    },
    {
      "given": "a 'webhook_event' with status 'PENDING' exists",
      "when": "the system attempts to process the webhook event",
      "then": "the 'webhook_event' record's 'status' should be updated to 'PROCESSED' or 'FAILED', and 'processed_at' should be set"
    },
    {
      "given": "a 'webhook_event' processing fails",
      "when": "the system attempts to reprocess the webhook event",
      "then": "the 'webhook_event' record's 'retries' count should increment and its status should be updated"
    },
    {
      "given": "A user performs an action on a target resource within the system.",
      "when": "The action is successfully completed and recorded.",
      "then": "An audit log entry should be created, detailing the actor, action, target type, target ID, and relevant metadata."
    },
    {
      "given": "A user from a specific workspace requires assistance.",
      "when": "The user submits a new support ticket with a subject and detailed body.",
      "then": "A new support ticket should be created with an initial status, priority, and associated with the requester and workspace."
    },
    {
      "given": "A workspace administrator needs to define rules for data retention.",
      "when": "The administrator creates a new retention policy for their workspace, specifying a name and a set of JSON-defined rules.",
      "then": "The retention policy should be stored and uniquely associated with the respective workspace."
    },
    {
      "given": "A team operates across different geographical regions.",
      "when": "A team administrator configures data residency rules for a specific region.",
      "then": "The regional data configuration should be stored, outlining data residency requirements for that team in the specified region."
    },
    {
      "given": "An event that could impact system security occurs.",
      "when": "The security event is detected by the system.",
      "then": "A security event log entry should be created, capturing the user involved, event type, and associated metadata."
    },
    {
      "given": "A new system capability or resource requires fine-grained access control.",
      "when": "A unique permission code and a descriptive text are defined for this capability.",
      "then": "The new permission should be successfully recorded and available for assignment to roles."
    },
    {
      "given": "A specific set of users within a team or workspace requires a predefined level of access.",
      "when": "An administrator creates a new role with a unique name and description, optionally scoping it to a team or workspace.",
      "then": "The new role should be created and stored in the system."
    },
    {
      "given": "An existing role and a defined permission are available.",
      "when": "An administrator associates the permission with the role.",
      "then": "The role should inherit the specified permission, allowing users with this role to perform actions associated with that permission."
    },
    {
      "given": "An existing user and a defined role are available.",
      "when": "An administrator assigns the role to the user, optionally specifying a scope (e.g., a specific team or workspace).",
      "then": "The user should be successfully associated with the role, granting them access based on the role's permissions within the defined scope."
    },
    {
      "given": "a new identity provider configuration",
      "when": "an administrator registers the identity provider",
      "then": "the identity provider details, including its type and configuration, should be stored"
    },
    {
      "given": "an existing team and a registered identity provider",
      "when": "an administrator links the identity provider to the team",
      "then": "a record of the link between the team and the identity provider should be created"
    },
    {
      "given": "a team with an existing brand voice",
      "when": "a user creates a new brand voice for that team",
      "then": "the new brand voice, including its name, description, and voice parameters, should be saved and associated with the team"
    },
    {
      "given": "a new user starting their onboarding process",
      "when": "an onboarding profile is created for the user",
      "then": "the profile should record the user's ID, optional team ID, initial goals, and an optional link to a brand voice"
    },
    {
      "given": "a user has completed their onboarding tasks",
      "when": "their onboarding profile is updated",
      "then": "the 'onboarded_at' timestamp should be set for their profile"
    },
    {
      "given": "a user wants to create a new content template",
      "when": "the user defines a title, type, and schema for the template",
      "then": "a new template record should be created, owned by the user, and associated with their team or workspace"
    },
    {
      "given": "an existing template",
      "when": "the owner updates the template content or settings",
      "then": "the template's version should be incremented and the 'updated_at' timestamp should reflect the change"
    },
    {
      "given": "an existing private template",
      "when": "the owner shares the template with a specific workspace",
      "then": "a 'template_shares' record should be created, linking the template to the target workspace and tracking the sharer"
    },
    {
      "given": "a finalized template ready for wider distribution",
      "when": "a publisher lists the template on the marketplace",
      "then": "a 'template_marketplace_items' record should be created, specifying the template, publisher, pricing, and initial status"
    },
    {
      "given": "a content item that requires plagiarism assessment",
      "when": "a plagiarism check is initiated using a specified engine",
      "then": "a 'plagiarism_checks' record should be created, storing the result, score, engine used, and the timestamp of the check"
    },
    {
      "given": "a content item that requires compliance verification",
      "when": "a specific type of compliance check is performed on the content",
      "then": "a 'content_compliance' record should be created, detailing the check type, result, status, and check timestamp"
    },
    {
      "given": "a user requesting an export of data from a workspace",
      "when": "the user specifies the desired format and any report parameters",
      "then": "a 'report_exports' record should be created, marking the request as pending with the specified details"
    },
    {
      "given": "an export request with a 'pending' status",
      "when": "the export process successfully completes and the file is generated",
      "then": "the 'status' of the 'report_exports' record should be updated to 'completed' and the 'file_path' and 'completed_at' fields should be populated"
    },
    {
      "given": "The `public.update_updated_at_column()` function is executed as part of a trigger.",
      "when": "A row in a table with an `updated_at` column is being inserted or updated.",
      "then": "The `search_path` is temporarily set to an empty string for security, and the `updated_at` column of the row is automatically set to the current timestamp."
    },
    {
      "given": "A table, such as 'users' or 'content_items', that is configured for `updated_at` tracking and has an 'updated_at' column.",
      "when": "An existing row in that table is updated.",
      "then": "The `updated_at` column of the updated row is automatically set to the current timestamp by its associated trigger."
    },
    {
      "given": "The database environment before `updated_at` triggers are ensured.",
      "when": "The idempotent script to attach `update_updated_at_column` triggers is executed.",
      "then": "Triggers are created only for tables from the predefined list that possess an 'updated_at' column and where the corresponding trigger does not already exist, ensuring no redundant trigger creation."
    },
    {
      "given": "The `public.update_search_tsv()` function is executed for a `content_items` row as part of a trigger.",
      "when": "The row includes values for `title`, `body`, and `tags`.",
      "then": "The `search_path` is temporarily set to an empty string for security, and the `search_tsv` column is populated with a `tsvector` that is a weighted combination of `title` (A), `body` (B), and `tags` (C)."
    },
    {
      "given": "The `public.update_search_tsv()` function is executed for a `templates` row as part of a trigger.",
      "when": "The row includes values for `title` and `schema_json`.",
      "then": "The `search_path` is temporarily set to an empty string for security, and the `search_tsv` column is populated with a `tsvector` that is a weighted combination of `title` (A) and `schema_json` (B)."
    },
    {
      "given": "A `content_items` table with the `trg_content_items_search_tsv` trigger active.",
      "when": "A new row is inserted or an existing row is updated in `content_items`.",
      "then": "The `search_tsv` column of that row is automatically populated based on its `title`, `body`, and `tags` using the `update_search_tsv` function."
    },
    {
      "given": "A `templates` table with the `trg_templates_search_tsv` trigger active.",
      "when": "A new row is inserted or an existing row is updated in `templates`.",
      "then": "The `search_tsv` column of that row is automatically populated based on its `title` and `schema_json` using the `update_search_tsv` function."
    },
    {
      "given": "The database environment before `search_tsv` triggers are ensured.",
      "when": "The idempotent script to attach `update_search_tsv` triggers is executed.",
      "then": "Triggers named `trg_content_items_search_tsv` and `trg_templates_search_tsv` are created only if they do not already exist, preventing duplicate trigger creation."
    },
    {
      "given": "A content_item exists with a current_version_id referencing an existing content_version.",
      "when": "The referenced content_version is deleted.",
      "then": "The current_version_id of the content_item should be set to NULL."
    },
    {
      "given": "A content_item exists with a created_by field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The created_by field of the content_item should be set to NULL."
    },
    {
      "given": "A content_item exists with an updated_by field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The updated_by field of the content_item should be set to NULL."
    },
    {
      "given": "A publish_job exists with a created_by field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The created_by field of the publish_job should be set to NULL."
    },
    {
      "given": "An approval exists with a created_by field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The created_by field of the approval should be set to NULL."
    },
    {
      "given": "An approval exists with an updated_by field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The updated_by field of the approval should be set to NULL."
    },
    {
      "given": "An approval exists with an approver_id field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The approver_id field of the approval should be set to NULL."
    },
    {
      "given": "A platform_profile exists with a workspace_id referencing an existing workspace.",
      "when": "The referenced workspace is deleted.",
      "then": "The associated platform_profile should also be deleted."
    },
    {
      "given": "A publish_job exists with a schedule_id referencing an existing schedule.",
      "when": "The referenced schedule is deleted.",
      "then": "The schedule_id of the publish_job should be set to NULL."
    },
    {
      "given": "A template exists with an owner_id field referencing an existing user.",
      "when": "The referenced user is deleted.",
      "then": "The owner_id field of the template should be set to NULL."
    },
    {
      "given": "The database contains various entities such as users, teams, content items, schedules, audit logs, etc., requiring efficient data access.",
      "when": "The application needs to retrieve records based on common attributes (e.g., 'role', 'status', 'type', 'created_at'), or perform joins between related tables using foreign key columns (e.g., 'owner_id', 'team_id', 'user_id', 'content_item_id').",
      "then": "Queries should execute with optimal performance, quickly locating and joining data records without full table scans, ensuring fast response times for user-facing features and internal processes due to the presence of Btree indexes."
    },
    {
      "given": "Data is stored in JSONB columns (e.g., content_items.metadata, templates.schema_json, ai_prompts.context_json) or array columns (e.g., content_items.tags).",
      "when": "The application performs queries that search for specific keys, values, or elements within these complex data structures.",
      "then": "These searches should be highly efficient, leveraging GIN indexes to quickly filter and retrieve matching records, supporting advanced content filtering, template discovery, and AI prompt analysis."
    },
    {
      "given": "Content items and templates include 'search_tsv' columns populated with TSVECTOR data for full-text search capabilities.",
      "when": "Users or processes initiate full-text search queries across these content items or templates.",
      "then": "Search results should be returned rapidly and accurately, utilizing GIN indexes on the TSVECTOR columns to provide a responsive and effective search experience."
    },
    {
      "given": "A mechanism to create new publish_jobs is in place, which can include an optional 'idempotency_key'.",
      "when": "The system attempts to create a publish_job specifying the same 'workspace_id' and a non-null 'idempotency_key', or the same 'platform_profile_id' and a non-null 'idempotency_key', multiple times.",
      "then": "Only one publish_job should be successfully created for a given unique combination of '(workspace_id, idempotency_key)' or '(platform_profile_id, idempotency_key)', preventing duplicate processing of publishing tasks and ensuring transactional integrity."
    },
    {
      "given": "The publish_jobs table contains jobs with various statuses, priorities, and scheduled run times.",
      "when": "The job scheduler needs to fetch the next set of publish_jobs that are 'QUEUED' for processing, prioritizing them by 'priority' and 'run_at'.",
      "then": "The retrieval of these specific 'QUEUED' jobs should be extremely fast, allowing the scheduler to efficiently pick up and execute tasks based on their urgency and scheduled time, facilitated by a partial index."
    },
    {
      "given": "Publish_jobs can have a 'lease_expires_at' timestamp, which may be null for jobs without an active lease.",
      "when": "The system periodically checks for publish_jobs whose 'lease_expires_at' is in the past and is not null.",
      "then": "These expired lease jobs should be quickly identifiable, enabling timely re-queuing, failure handling, or re-assignment of tasks to maintain the robustness of the publishing system, due to a partial index on 'lease_expires_at'."
    },
    {
      "given": "The database schema might not yet include the 'notifications' table.",
      "when": "The application initializes or performs a schema migration, and later needs to store, retrieve, or update user notifications.",
      "then": "The 'notifications' table should be created with all specified columns, including a primary key, foreign key to 'users', and Btree indexes on 'user_id' and 'status' to ensure notifications can be reliably stored, efficiently retrieved for a specific user, and quickly filtered by their current status."
    },
    {
      "given": "There are 'content_items' rows where 'search_tsv' is NULL.",
      "when": "The system executes the backfill update for 'content_items' by setting 'updated_at' to NOW().",
      "then": "The 'search_tsv' column for affected 'content_items' should be populated by the trigger, and 'updated_at' should reflect the update time."
    },
    {
      "given": "There are 'templates' rows where 'search_tsv' is NULL.",
      "when": "The system executes the backfill update for 'templates' by setting 'updated_at' to NOW().",
      "then": "The 'search_tsv' column for affected 'templates' should be populated by the trigger, and 'updated_at' should reflect the update time."
    },
    {
      "given": "The 'permissions' table may or may not contain initial permissions.",
      "when": "The initial permission seeding script is executed.",
      "then": "A predefined set of permissions (e.g., 'content.create', 'team.manage', 'ai.use') should exist in the 'permissions' table, and existing permissions should not be duplicated due to 'ON CONFLICT (code) DO NOTHING'."
    },
    {
      "given": "The 'locales' table may or may not contain initial locales.",
      "when": "The initial locale seeding script is executed.",
      "then": "A predefined set of locales (e.g., 'en', 'es', 'fr', 'de') should exist in the 'locales' table, and existing locales should not be duplicated due to 'ON CONFLICT (code) DO NOTHING'."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.users' table with a 'users_select_own' policy based on 'id = auth.uid()'.",
      "when": "An authenticated user attempts to query their own 'users' profile.",
      "then": "The user should successfully retrieve their own 'users' profile and be prevented from viewing other users' profiles."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.users' table with a 'users_update_own' policy based on 'id = auth.uid()'.",
      "when": "An authenticated user attempts to update their own 'users' profile.",
      "then": "The user should successfully update their own 'users' profile and be prevented from updating other users' profiles."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.content_items' table with a 'content_items_select_owner' policy based on 'owner_id = auth.uid()'.",
      "when": "An authenticated user attempts to query 'content_items'.",
      "then": "The user should successfully retrieve only the 'content_items' where their 'auth.uid()' matches the 'owner_id', and no other items."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.content_items' table with a 'content_items_insert_owner' policy based on 'owner_id = auth.uid()'.",
      "when": "An authenticated user attempts to insert a 'content_item' with their 'auth.uid()' as the 'owner_id'.",
      "then": "The 'content_item' should be successfully inserted, and attempts to insert items with a different 'owner_id' should be prevented."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.content_items' table with a 'content_items_update_owner' policy based on 'owner_id = auth.uid()'.",
      "when": "An authenticated user attempts to update a 'content_item' where their 'auth.uid()' matches the 'owner_id'.",
      "then": "The 'content_item' should be successfully updated, and attempts to update items owned by others should be prevented."
    },
    {
      "given": "Row-Level Security (RLS) is enabled on the 'public.content_items' table with a 'content_items_delete_owner' policy based on 'owner_id = auth.uid()'.",
      "when": "An authenticated user attempts to delete a 'content_item' where their 'auth.uid()' matches the 'owner_id'.",
      "then": "The 'content_item' should be successfully deleted, and attempts to delete items owned by others should be prevented."
    },
    {
      "given": "A user attempts to access a workspace.",
      "when": "A membership-based policy is active for workspace access, checking the team_members table.",
      "then": "The system verifies that the user exists in the team_members table for the requested team and workspace."
    },
    {
      "given": "Row Level Security (RLS) is currently disabled for a specific database table (e.g., public.users, public.content_items).",
      "when": "An administrator uncomments and executes the 'ALTER TABLE <table_name> ENABLE ROW LEVEL SECURITY' command.",
      "then": "Row Level Security is enabled for the specified table, enforcing data access policies based on the user's context."
    },
    {
      "given": "A new user initiates the authentication process.",
      "when": "The user successfully completes the LinkedIn OAuth flow.",
      "then": "A LinkedInProfile record is created, a User record is created, and the user is assigned to a Team and Workspace context."
    },
    {
      "given": "A user has created a ContentItem.",
      "when": "The ContentItem is scheduled for publishing (optionally after an approval process).",
      "then": "A PublishJob is enqueued, a background worker calls the LinkedIn API to publish the content, the PublishJob.publishedAt timestamp is updated, and the ContentItem's status is updated."
    },
    {
      "given": "A user wants to authenticate via LinkedIn",
      "when": "They make a GET request to /api/auth/linkedin/start with a 'redirect' URL",
      "then": "The system redirects them to LinkedIn for OAuth authorization"
    },
    {
      "given": "A user has authorized the application on LinkedIn and is redirected back with an authorization 'code'",
      "when": "The system receives a GET request to /api/auth/linkedin/callback with the 'code'",
      "then": "The system exchanges the code for tokens, creates or merges a User and LinkedInProfile, and responds with a JWT/session and user summary"
    },
    {
      "given": "The application is in development mode",
      "when": "A POST request is made to /api/auth/demo-login",
      "then": "The system creates a demo/test user and provides authentication"
    },
    {
      "given": "An authenticated user and their userId",
      "when": "A POST request is made to /api/users/:userId/onboarding with 'step' and 'payload'",
      "then": "The system saves the onboarding progress and updates User.preferencesJson"
    },
    {
      "given": "An authenticated user and their userId",
      "when": "A GET request is made to /api/users/:userId/onboarding",
      "then": "The system returns the current onboarding progress for the user"
    },
    {
      "given": "An authenticated user within a workspaceId",
      "when": "A GET request is made to /api/contents with optional 'workspaceId', 'status', and 'q' filters",
      "then": "The system returns a paginated list of content items matching the criteria"
    },
    {
      "given": "An authenticated user and a workspaceId",
      "when": "A POST request is made to /api/contents with 'workspaceId', 'type', 'title', 'body', and 'tags'",
      "then": "The system creates a new ContentItem"
    },
    {
      "given": "An authenticated user and an existing contentId",
      "when": "A GET request is made to /api/contents/:id",
      "then": "The system returns the details of the specified content item"
    },
    {
      "given": "An authenticated user and an existing contentId",
      "when": "A PATCH request is made to /api/contents/:id with updated fields",
      "then": "The system updates the specified content item"
    },
    {
      "given": "An authenticated user and an existing contentId",
      "when": "A POST request is made to /api/contents/:id/duplicate",
      "then": "The system creates a duplicate of the specified content item"
    },
    {
      "given": "An authenticated user and an existing contentId",
      "when": "A POST request is made to /api/contents/:id/versions with a new 'body' and 'label'",
      "then": "The system creates a new ContentVersion for the content item"
    },
    {
      "given": "An authenticated user and an existing contentId",
      "when": "A GET request is made to /api/contents/:id/versions",
      "then": "The system returns a list of all versions for the specified content item"
    },
    {
      "given": "An authenticated user and a workspaceId",
      "when": "A GET request is made to /api/templates with a 'workspaceId'",
      "then": "The system returns a list of templates available for that workspace"
    },
    {
      "given": "An authenticated user",
      "when": "A POST request is made to /api/templates with template details",
      "then": "The system creates a new template"
    },
    {
      "given": "An authenticated user and an existing templateId",
      "when": "A POST request is made to /api/templates/:id/share with a 'targetWorkspaceId'",
      "then": "The system shares the specified template with the target workspace"
    },
    {
      "given": "An authenticated user, a contextId, a prompt, and a generationType",
      "when": "A POST request is made to /api/ai/generate with these details",
      "then": "The system generates content variations, logs the prompt to AiPrompt, logs usage to AiUsage, enforces per-plan quotas using QuotaCounter, and returns the generated content, token count, and costs"
    },
    {
      "given": "An authenticated user and their userId",
      "when": "A GET request is made to /api/ai/usage?userId=",
      "then": "The system returns the AI usage data for quota checks"
    },
    {
      "given": "An authenticated user and a workspaceId",
      "when": "A POST request is made to /api/workspaces/:id/snapshots with 'sessionState'",
      "then": "The system saves the current session state as a workspace snapshot"
    },
    {
      "given": "An authenticated user and a workspaceId",
      "when": "A GET request is made to /api/workspaces/:id/snapshots",
      "then": "The system returns the saved snapshots for the specified workspace"
    },
    {
      "given": "An authenticated user, a contentId, scheduledAt time, timezone, and optional recurrence",
      "when": "A POST request is made to /api/schedules",
      "then": "The system creates a Schedule entry and enqueues a PublishJob with status QUEUED"
    },
    {
      "given": "An authenticated user, a workspaceId, and an optional range",
      "when": "A GET request is made to /api/schedules with these parameters",
      "then": "The system returns a list of schedules for the workspace within the specified range"
    },
    {
      "given": "An authenticated user, a contentId, and a linkedInProfileId",
      "when": "A POST request is made to /api/publish/linkedin",
      "then": "The system creates a PublishJob and triggers a worker to process it"
    },
    {
      "given": "An authenticated user, a contentId, and submittedBy information",
      "when": "A POST request is made to /api/approvals",
      "then": "The system creates a new approval request for the content"
    },
    {
      "given": "An authenticated user, an existing approvalId, a status (APPROVED|REJECTED), and optional comments",
      "when": "A PATCH request is made to /api/approvals/:id",
      "then": "The system updates the status and comments of the specified approval request"
    },
    {
      "given": "An authenticated user, a workspaceId, and optional filters",
      "when": "A GET request is made to /api/engage/feed",
      "then": "The system returns a feed of posts suitable for engagement"
    },
    {
      "given": "An authenticated user, a userId, an action (like|comment|share), an externalPostId, and optional text for comments",
      "when": "A POST request is made to /api/engage/action",
      "then": "The system performs the specified engagement action via the LinkedInProfile token"
    },
    {
      "given": "An authenticated user, a workspaceId, and an optional range",
      "when": "A GET request is made to /api/opportunities",
      "then": "The system returns a list of opportunities for the workspace within the specified range"
    },
    {
      "given": "An authenticated user",
      "when": "A POST request is made to /api/opportunities/refresh",
      "then": "The system enqueues a background job to manually refresh opportunities"
    },
    {
      "given": "An authenticated user, a workspaceId, and an optional range",
      "when": "A GET request is made to /api/analytics/overview",
      "then": "The system returns an overview of analytics data for the workspace"
    },
    {
      "given": "An authenticated user and a contentId",
      "when": "A GET request is made to /api/analytics/content/:contentId",
      "then": "The system returns analytics data specific to the specified content item"
    },
    {
      "given": "A Stripe webhook event for invoice.payment_succeeded or similar",
      "when": "A POST request is made to /api/webhooks/stripe",
      "then": "The system idempotently handles the event, verifies the signature, persists the event in WebhookEvent, and marks it as processed"
    },
    {
      "given": "An authenticated user and a teamId",
      "when": "A GET request is made to /api/billing/subscription/:teamId",
      "then": "The system returns the subscription details for the specified team"
    },
    {
      "given": "An authenticated user, a teamId, and a new plan",
      "when": "A POST request is made to /api/billing/upgrade",
      "then": "The system calls the Stripe API to upgrade the team's billing plan"
    },
    {
      "given": "An administrator or monitoring system",
      "when": "A GET request is made to /api/admin/health",
      "then": "The system returns liveness and dependency check results"
    },
    {
      "given": "An administrator and a failed publishJobId",
      "when": "A POST request is made to /api/admin/retry-publish",
      "then": "The system re-enqueues or retries the specified publish job"
    },
    {
      "given": "A worker processing jobs that interact with external APIs (e.g., LinkedIn, AI provider)",
      "when": "The worker makes calls to external services",
      "then": "The worker respects per-account / per-team rate limits and handles throttling gracefully"
    },
    {
      "given": "A worker processing a PublishJob",
      "when": "The worker attempts to publish content",
      "then": "The worker uses PublishJob.idempotencyKey to prevent double-posting"
    },
    {
      "given": "A worker processing any background job",
      "when": "An attempt to process a job fails",
      "then": "The worker retries the job with an exponential backoff, jitter, and up to a configurable maximum number of attempts, recording JobAttempt records for each attempt"
    },
    {
      "given": "A background job that repeatedly fails",
      "when": "The job reaches its maximum retry attempts without success",
      "then": "The system escalates the failure via an alerting mechanism like PagerDuty"
    },
    {
      "given": "A worker is listening to the publish-queue",
      "when": "A PublishJob is dequeued",
      "then": "The worker validates the LinkedIn token for the associated LinkedInProfile (refreshing if needed) and calls the LinkedIn publish API, wrapping the call with idempotency and retry logic"
    },
    {
      "given": "A PublishJob has completed successfully",
      "when": "The publish job completes",
      "then": "PublishJob.status is updated to COMPLETED, publishedAt timestamp is set, ContentItem.status is updated to PUBLISHED, and an Analytics placeholder event is created"
    },
    {
      "given": "A PublishJob has failed",
      "when": "The publish job fails",
      "then": "attemptCount for the PublishJob is incremented, lastError is set, a JobAttempt row is created, and the job is re-enqueued with backoff"
    },
    {
      "given": "A PublishJob has failed multiple times, exceeding the attempt limit",
      "when": "The publish job fails again",
      "then": "The PublishJob is marked as FAILED"
    },
    {
      "given": "The database schema is defined",
      "when": "Data is queried",
      "then": "Indexes are added on userId, workspaceId, status, scheduledAt, and createdAt, and GIN indexes are applied to jsonb fields used for filtering"
    },
    {
      "given": "Content exists in the database",
      "when": "A user performs a search query",
      "then": "Postgres tsvector + GIN is used for full-text search, and search indexes are maintained via triggers or materializer jobs"
    },
    {
      "given": "Tables audit_logs, ai_prompts, competitor_snapshots, webhook_events are in use",
      "when": "Data grows significantly in these tables",
      "then": "Time partitioning is used for audit_logs, ai_prompts, competitor_snapshots, and webhook_events, implemented via DB migrations"
    },
    {
      "given": "LinkedIn profile access and refresh tokens are received",
      "when": "Tokens are stored in LinkedInProfile.accessTokenEnc and refreshTokenEnc",
      "then": "Tokens are encrypted server-side using KMS (AWS/GCP) before writing"
    },
    {
      "given": "A User or ContentItem is marked for deletion",
      "when": "A user or content item is 'deleted'",
      "then": "The deletedAt field is set, the record is not physically deleted, and retention jobs are run to manage soft-deleted data"
    },
    {
      "given": "Old snapshots or job attempts exist in the database",
      "when": "The retention policy is applied (e.g., after 13 months)",
      "then": "Old snapshots/attempts are purged or archived to S3"
    },
    {
      "given": "An end-user wants to log in",
      "when": "The user authenticates using LinkedIn OAuth",
      "then": "Sessions are managed via Supabase or JWTs signed with rotated keys"
    },
    {
      "given": "An enterprise user attempts to log in using SAML/OIDC",
      "when": "The user utilizes enterprise SSO",
      "then": "IdentityProvider + IdpLink facilitates the SSO, and IdP configuration is stored encrypted in IdentityProvider.configJson"
    },
    {
      "given": "A user attempts to perform an action",
      "when": "The user attempts to access a resource or perform an action",
      "then": "RBAC is enforced at the backend via UserRole checks and per-resource permission sets (e.g., UserWorkspace.permissionSet)"
    },
    {
      "given": "Provider keys (OpenAI, Stripe, LinkedIn) are required, and tokens need encryption",
      "when": "The application needs to access sensitive provider keys or encrypt tokens",
      "then": "Secret manager (AWS Secrets Manager / GCP Secret Manager) is used for provider keys, and KMS is used for token encryption"
    },
    {
      "given": "A user requests their personal data export to satisfy GDPR",
      "when": "A GET request is made to /api/users/:id/export",
      "then": "The user's personal data is exported"
    },
    {
      "given": "A user requests deletion of their personal data to satisfy GDPR",
      "when": "A DELETE request is made to /api/users/:id",
      "then": "A purge workflow is initiated to delete the user's personal data"
    },
    {
      "given": "Users or teams are making API calls (e.g., AI calls, LinkedIn calls)",
      "when": "API calls are made",
      "then": "Per-user and per-team rate limits are enforced, throttling AI calls and LinkedIn calls"
    },
    {
      "given": "The application is deployed",
      "when": "Security assessments are performed",
      "then": "Pen tests and audits are conducted quarterly, and SAST/DAST scans are run in CI"
    },
    {
      "given": "An error occurs in the application",
      "when": "An error is encountered",
      "then": "The error is reported to Sentry with environment tags (teamId, workspaceId, requestId)"
    },
    {
      "given": "The application is running",
      "when": "Application activity occurs",
      "then": "Prometheus metrics are exported (e.g., http_request_duration_seconds, queue_length, publish_success_rate, ai_tokens_used)"
    },
    {
      "given": "The application generates logs",
      "when": "Events occur in the application",
      "then": "Structured JSON logs containing correlation IDs are generated and stored in a central store (ELK / Datadog)"
    },
    {
      "given": "A user initiates a request that flows through the system",
      "when": "The request progresses from API to AI provider to publish job",
      "then": "OpenTelemetry spans are generated for the entire user request flow"
    },
    {
      "given": "The publish pipeline experiences sustained errors",
      "when": "Sustained errors in the publish pipeline exceed a defined threshold",
      "then": "An alert is triggered via PagerDuty"
    },
    {
      "given": "Stripe webhook failures occur",
      "when": "Stripe webhook failures impact billing",
      "then": "An alert is triggered via PagerDuty"
    },
    {
      "given": "The database experiences unusual activity",
      "when": "DB connection spikes or a high error rate are detected",
      "then": "An alert is triggered via PagerDuty"
    },
    {
      "given": "Business logic components for content lifecycle, approvals, and AI prompt generation are developed",
      "when": "Unit tests are executed",
      "then": "These components are tested in isolation"
    },
    {
      "given": "API endpoints and the database are deployed",
      "when": "Integration tests are executed",
      "then": "Endpoints and DB interactions are tested using a test DB"
    },
    {
      "given": "The schedule-to-publish flow is implemented",
      "when": "Integration tests are executed for this flow",
      "then": "The flow is tested with external calls to LinkedIn mocked"
    },
    {
      "given": "Stripe webhooks are integrated",
      "when": "Contract tests are executed for Stripe webhooks",
      "then": "The contract with Stripe webhooks is validated"
    },
    {
      "given": "LinkedIn publish functionality is integrated",
      "when": "Contract tests are executed for LinkedIn publish",
      "then": "LinkedIn publish contract mocks are validated"
    },
    {
      "given": "AI responses are consumed",
      "when": "Contract tests are executed for AI responses",
      "then": "AI response schemas are validated"
    },
    {
      "given": "The full application workflow from onboarding to publishing is implemented",
      "when": "E2E tests are executed for Onboarding -> Create content -> Approval -> Schedule -> Publish",
      "then": "External calls are mocked in CI"
    },
    {
      "given": "The system is under varying loads",
      "when": "Publish bursts are simulated using tools like k6 or Gatling",
      "then": "System performance under publish load is evaluated"
    },
    {
      "given": "The system is under varying loads",
      "when": "AI-heavy usage is simulated using tools like k6 or Gatling",
      "then": "System performance under AI-heavy load is evaluated"
    },
    {
      "given": "Code is committed to the repository",
      "when": "The CI pipeline runs",
      "then": "SAST, DAST, and dependency scanning are performed"
    },
    {
      "given": "A feature branch is pushed",
      "when": "The GitHub Actions pipeline runs",
      "then": "Linting, unit tests, migrations check, prisma generate, build, and integration tests are executed"
    },
    {
      "given": "A build passes on a feature branch",
      "when": "Code is ready for staging deployment",
      "then": "The application is deployed to staging, and smoke tests are run on the staging environment"
    },
    {
      "given": "Staging deployment is successful and approved",
      "when": "Code is ready for production deployment",
      "then": "A manual/gated production deploy is performed with migration approvals required"
    },
    {
      "given": "Database schema changes are required",
      "when": "Migrations are applied",
      "then": "Prisma migrations are used"
    },
    {
      "given": "A migration involves large tables",
      "when": "A schema change is applied to a large table",
      "then": "CREATE TABLE ..., backfill, swap, and then DROP strategy is used to avoid locking"
    },
    {
      "given": "Schema changes are developed",
      "when": "A migration is to be created",
      "then": "A migration branch is created, and `prisma migrate dev --create-only` is run to generate SQL"
    },
    {
      "given": "A SQL migration has been generated",
      "when": "The migration is reviewed and tested",
      "then": "SQL is reviewed for indexes/partitions and long-running operations, applied in staging, and data migrations and smoke tests are run in staging"
    },
    {
      "given": "The migration is successfully tested in staging",
      "when": "The migration is deployed to production",
      "then": "Deployment occurs in a maintenance window if locks are required, preferring zero-downtime where possible"
    },
    {
      "given": "A schema change has been deployed",
      "when": "A rollback is required due to issues",
      "then": "A plan exists to revert schema changes (backup + restore or run reverse-migration)"
    },
    {
      "given": "New features are developed",
      "when": "New changes are deployed",
      "then": "Changes are gated behind FeatureFlag to enable gradual rollout"
    },
    {
      "given": "A publish pipeline is active",
      "when": "A publish job fails",
      "then": "The system should allow checking publish_jobs failure rates, worker logs, and LinkedIn API status."
    },
    {
      "given": "A publish pipeline is active and a publish job has failed",
      "when": "An administrator intervenes",
      "then": "The system should allow retrying failed jobs or running 'admin/retry-publish' for manual retries."
    },
    {
      "given": "The system relies on an AI provider",
      "when": "The AI provider experiences an outage or quota is exceeded",
      "then": "The system should switch to a degraded mode using cached templates, notify users, and backfill once the service is restored."
    },
    {
      "given": "The system processes Stripe webhooks",
      "when": "A Stripe webhook fails",
      "then": "The system should allow reprocessing webhook_events, reconciling payments, and notifying finance."
    },
    {
      "given": "The publish operation is experiencing high latency",
      "when": "High publish latency is detected",
      "then": "The system should allow scaling workers, checking rate limits, and adding more concurrency with careful rate-limiting per account."
    },
    {
      "given": "An incident occurs in the system",
      "when": "An on-call engineer starts triage",
      "then": "The engineer should use Grafana and Sentry for diagnosis."
    },
    {
      "given": "An incident has been triaged by an on-call engineer",
      "when": "Escalation is determined to be necessary",
      "then": "The incident should be escalated to the relevant owner (billing, publish, or AI provider)."
    },
    {
      "given": "A severe incident impacts system operations",
      "when": "Traffic re-routing or maintenance mode is required",
      "then": "The system should allow re-routing traffic or enabling maintenance mode."
    },
    {
      "given": "The application requires sensitive configuration variables",
      "when": "The application is deployed to an environment",
      "then": "Secrets must be stored in cloud secret managers and injected at runtime."
    },
    {
      "given": "Content data is created or updated within the system",
      "when": "The system processes content changes",
      "then": "Triggers or a background job should produce and update the 'search_index.tsv'."
    },
    {
      "given": "An Image is present in the system",
      "when": "Content is saved that includes this image",
      "then": "A 'ContentMedia' entry should be created at content save time."
    },
    {
      "given": "Historical data exists for 'audit_logs', 'webhook_events', 'competitor_snapshots', and 'ai_prompts'",
      "when": "Data ages beyond a predefined period",
      "then": "Retention and partitioning policies should be implemented for these tables."
    },
    {
      "given": "A user attempts to authenticate using OIDC or SAML",
      "when": "The user interacts with an SSO flow",
      "then": "The system should support OIDC/SAML flows mapped to 'IdentityProvider' and 'IdpLink'."
    },
    {
      "given": "Users or teams are performing operations, especially those involving AI and LinkedIn integrations",
      "when": "Operation requests exceed predefined thresholds",
      "then": "The system should apply per-user or per-team throttles."
    },
    {
      "given": "The dashboard needs to display aggregated data",
      "when": "The dashboard queries data that involves expensive joins",
      "then": "Materialized read models should be used to reduce query complexity and improve performance."
    },
    {
      "given": "The system integrates with LinkedIn, Stripe, and AI providers",
      "when": "Code is committed to the CI pipeline",
      "then": "Contract tests with mocks should run in CI, and periodic staging smoke-tests with real credentials should be performed."
    },
    {
      "given": "The system exposes public endpoints",
      "when": "A request is made for API documentation",
      "then": "An OpenAPI 3.0.3 specification should be generated, covering all public endpoints and their functionalities."
    },
    {
      "given": "A client wishes to initiate the LinkedIn OAuth process",
      "when": "A GET request is made to '/auth/linkedin/start' with an optional 'redirect' parameter",
      "then": "The system should respond with a '302' redirect to the LinkedIn OAuth authorization URL or a '400' for a bad request."
    },
    {
      "given": "LinkedIn has redirected a user back to the application's callback URL with an authorization 'code'",
      "when": "A GET request is made to '/auth/linkedin/callback'",
      "then": "The server should exchange the 'code' for tokens, create or merge a User and LinkedInProfile, and return a session (JWT cookie or token)."
    },
    {
      "given": "a valid 'code' and an optional 'state' parameter",
      "when": "a GET request is made to the authentication callback endpoint",
      "then": "the user summary and a session token are returned with status 200"
    },
    {
      "given": "an invalid 'code' or 'state' parameter",
      "when": "a GET request is made to the authentication callback endpoint",
      "then": "an error indicating invalid code or state is returned with status 400"
    },
    {
      "given": "an internal server error occurs during authentication processing",
      "when": "a GET request is made to the authentication callback endpoint",
      "then": "an internal server error is returned with status 500"
    },
    {
      "given": "the application is configured for development or testing",
      "when": "a POST request is made to /auth/demo-login with a valid 'role'",
      "then": "a demo user token is returned with status 200"
    },
    {
      "given": "the application is configured for production",
      "when": "a POST request is made to /auth/demo-login with any 'role'",
      "then": "a forbidden error is returned with status 403"
    },
    {
      "given": "a 'userId' exists in the system",
      "when": "a GET request is made to /users/{userId}/onboarding",
      "then": "the onboarding progress object for the specified user is returned with status 200"
    },
    {
      "given": "an authenticated user and a valid 'userId'",
      "when": "a POST request is made to /users/{userId}/onboarding with a 'step' and 'payload'",
      "then": "the onboarding step is saved and a success response is returned with status 200"
    },
    {
      "given": "an unauthenticated user",
      "when": "a POST request is made to /users/{userId}/onboarding with a 'step' and 'payload'",
      "then": "an unauthorized error is returned with status 401"
    },
    {
      "given": "multiple content items exist, some matching filter criteria",
      "when": "a GET request is made to /contents with optional query parameters like 'workspaceId', 'status', 'q', 'page', and 'pageSize'",
      "then": "a paginated list of content items matching the criteria is returned with status 200"
    },
    {
      "given": "an authenticated user",
      "when": "a POST request is made to /contents with a valid 'ContentCreateRequest' payload",
      "then": "a new content item is created, and its details are returned with status 201"
    },
    {
      "given": "an authenticated user",
      "when": "a POST request is made to /contents with an invalid 'ContentCreateRequest' payload",
      "then": "a validation error is returned with status 400"
    },
    {
      "given": "a content item with a specific 'id' exists",
      "when": "a GET request is made to /contents/{id}",
      "then": "the details of the content item are returned with status 200"
    },
    {
      "given": "an authenticated user and an existing content item with a specific 'id'",
      "when": "a PATCH request is made to /contents/{id} with a 'ContentUpdateRequest' payload",
      "then": "the content item is partially updated, and the updated item details are returned with status 200"
    },
    {
      "given": "an authenticated user and an existing content item with a specific 'id'",
      "when": "a POST request is made to /contents/{id} to duplicate the item",
      "then": "a new duplicated content item is created and its details are returned with status 201"
    },
    {
      "given": "a content item with a specific 'id' and associated versions",
      "when": "a GET request is made to /contents/{id}/versions",
      "then": "a list of content versions for that item is returned with status 200"
    },
    {
      "given": "an authenticated user and an existing content item with a specific 'id'",
      "when": "a POST request is made to /contents/{id}/versions with a valid 'ContentVersionCreate' payload",
      "then": "a new version of the content item is created, and its details are returned with status 201"
    },
    {
      "given": "multiple templates exist, some associated with specific workspaces",
      "when": "a GET request is made to /templates with an optional 'workspaceId' query parameter",
      "then": "a list of templates is returned, filtered by workspace if specified, with status 200"
    },
    {
      "given": "an authenticated user",
      "when": "a POST request is made to /templates with a valid 'TemplateCreate' payload",
      "then": "a new template is created, and its details are returned with status 201"
    },
    {
      "given": "an authenticated user, an existing template with a specific 'id', and a valid 'targetWorkspaceId'",
      "when": "a POST request is made to /templates/{id}/share with the 'targetWorkspaceId' payload",
      "then": "the template is successfully shared to the target workspace, and a success response is returned with status 200"
    },
    {
      "given": "an authenticated user and a non-existent template 'id'",
      "when": "a POST request is made to /templates/{id}/share with a 'targetWorkspaceId'",
      "then": "an error indicating template not found is returned with status 404"
    },
    {
      "given": "an authenticated user with sufficient AI quota",
      "when": "a POST request is made to /ai/generate with a valid 'AiGenerateRequest' payload",
      "then": "AI-generated content variations and metadata are returned with status 200"
    },
    {
      "given": "an authenticated user who has exceeded their AI quota",
      "when": "a POST request is made to /ai/generate with an 'AiGenerateRequest' payload",
      "then": "an error indicating quota exceeded is returned with status 429"
    },
    {
      "given": "an authenticated user and an existing workspace with a specific 'id'",
      "when": "a POST request is made to /workspaces/{id}/snapshots with a 'sessionState' payload",
      "then": "the workspace snapshot is saved, and a success response is returned with status 201"
    },
    {
      "given": "an existing workspace with a specific 'id' and associated snapshots",
      "when": "a GET request is made to /workspaces/{id}/snapshots",
      "then": "a list of snapshots for that workspace is returned with status 200"
    },
    {
      "given": "an authenticated user",
      "when": "a POST request is made to /schedules with a valid 'ScheduleCreateRequest' payload",
      "then": "a new schedule is created, a publish job is enqueued, and its details are returned with status 201"
    },
    {
      "given": "multiple schedules exist in a workspace, some matching filter criteria",
      "when": "a GET request is made to /schedules with optional query parameters like 'workspaceId', 'rangeStart', and 'rangeEnd'",
      "then": "a list of filtered schedules is returned with status 200"
    },
    {
      "given": "an authenticated user and valid 'contentId', 'linkedInProfileId', and 'scheduledAt' details",
      "when": "a POST request is made to /publish/linkedin",
      "then": "a LinkedIn publish job is created and enqueued, returning its details with status 202"
    },
    {
      "given": "an authenticated user and valid 'contentId' and 'submittedBy' details",
      "when": "a POST request is made to /approvals with the content and submitter details",
      "then": "the content is submitted for approval, and a success response is returned with status 201"
    },
    {
      "given": "an authenticated user, an existing 'approvalId', and a valid approval 'status'",
      "when": "a PATCH request is made to /approvals with the 'approvalId', 'status', and optional 'comments' payload",
      "then": "the approval status is updated, and a success response is returned with status 200"
    },
    {
      "given": "an authenticated user and posts recommended for engagement exist in a workspace",
      "when": "a GET request is made to /engage/feed with an optional 'workspaceId' query parameter",
      "then": "a list of recommended posts for engagement is returned with status 200"
    },
    {
      "given": "an authenticated user and valid details for an 'action' (like, comment, or share) on an 'externalPostId'",
      "when": "a POST request is made to /engage/action with the user, action, external post ID, and optional text payload",
      "then": "the engagement action is performed, and a success response is returned with status 200"
    },
    {
      "given": "an authenticated user who has exceeded the rate limit for engagement actions",
      "when": "a POST request is made to /engage/action with an engagement action payload",
      "then": "a rate limit exceeded error is returned with status 429"
    },
    {
      "given": "opportunities exist for a given workspace",
      "when": "a GET request is made to /opportunities with an optional 'workspaceId' query parameter",
      "then": "a list of opportunities relevant to the workspace is returned with status 200"
    },
    {
      "given": "an authenticated user and a valid 'workspaceId'",
      "when": "a POST request is made to /opportunities to trigger a refresh",
      "then": "an opportunity refresh job is enqueued, and an accepted response is returned with status 202"
    },
    {
      "given": "analytics data is available for a workspace over a specific time range",
      "when": "a GET request is made to /analytics/overview with optional 'workspaceId', 'rangeStart', and 'rangeEnd' parameters",
      "then": "dashboard overview metrics are returned with status 200"
    },
    {
      "given": "the Stripe webhook endpoint is configured to receive events",
      "when": "a POST request is made to /webhooks/stripe containing a Stripe event payload",
      "then": "the event is persisted and processed asynchronously, returning a success status (e.g., 200 or 202)"
    },
    {
      "given": "The system is configured with a secret key for `Stripe-Signature` validation.",
      "when": "A webhook request is received with a `Stripe-Signature` header that contains a valid signature for the request body and timestamp.",
      "then": "The system should successfully process the webhook event."
    },
    {
      "given": "The system is configured with a secret key for `Stripe-Signature` validation.",
      "when": "A webhook request is received with a `Stripe-Signature` header that contains an invalid signature (e.g., forged, tampered, or generated with an incorrect key).",
      "then": "The system should reject the webhook event and return an appropriate error response (e.g., 400 Bad Request or 401 Unauthorized)."
    },
    {
      "given": "The system is configured to require and validate the `Stripe-Signature` header.",
      "when": "A webhook request is received without a `Stripe-Signature` header.",
      "then": "The system should reject the webhook event and return a 400 Bad Request error response."
    },
    {
      "given": "The system is configured to receive webhook requests with a signature header.",
      "when": "A valid webhook request with a correct signature is received.",
      "then": "The system should return a \"200 Accepted\" response."
    },
    {
      "given": "A team with a known 'teamId' has an existing subscription.",
      "when": "A GET request is made to '/billing/subscription/{teamId}' with a valid 'teamId'.",
      "then": "The system should return a \"200 Subscription\" response containing the subscription details."
    },
    {
      "given": "The system's core services (application, database, Redis) are operational.",
      "when": "A GET request is made to '/admin/health'.",
      "then": "The system should return a \"200 Healthy\" response with status 'healthy' and 'db' and 'redis' reporting 'ok'."
    },
    {
      "given": "An authenticated administrator has a valid bearer token and a failed publish job with a specific 'publishJobId' exists.",
      "when": "A POST request is made to '/admin/retry-publish' with the 'publishJobId' in the request body, authenticated with the bearer token.",
      "then": "The system should return a \"200 Enqueued retry\" response, indicating the job has been queued for another attempt."
    },
    {
      "given": "A user wants to authenticate via LinkedIn",
      "when": "They initiate the LinkedIn OAuth flow with a redirect URL",
      "then": "The system redirects the user to LinkedIn for authorization"
    },
    {
      "given": "A user has authorized the application on LinkedIn",
      "when": "The LinkedIn OAuth callback endpoint receives the authorization code",
      "then": "The system returns an authentication token and user details"
    },
    {
      "given": "The environment is a development or test environment",
      "when": "A request is made to create a demo user with a specified role (e.g., EDITOR)",
      "then": "The system creates a demo user and returns an authentication token"
    },
    {
      "given": "A user exists in the system",
      "when": "A request is made to retrieve their onboarding progress",
      "then": "The system returns the user's completed onboarding steps and progress percentage"
    },
    {
      "given": "A user is authenticated and is in the onboarding process",
      "when": "A request is made to save a specific onboarding step with its payload",
      "then": "The system successfully saves the onboarding step for the user"
    },
    {
      "given": "Content items exist for various workspaces and statuses",
      "when": "A request is made to list content items, optionally filtered by workspaceId, status, search query, page, and pageSize",
      "then": "The system returns a paginated list of content items matching the criteria"
    },
    {
      "given": "A user is authenticated and wants to create new content",
      "when": "A request is made to create a content item with required fields (type, ownerId)",
      "then": "The system creates and returns the new content item with a 201 status"
    },
    {
      "given": "A content item exists with a specific ID",
      "when": "A request is made to retrieve that content item by its ID",
      "then": "The system returns the details of the specified content item"
    },
    {
      "given": "A user is authenticated and a content item exists with a specific ID",
      "when": "A request is made to partially update the content item's title, body, status, or tags",
      "then": "The system updates and returns the modified content item"
    },
    {
      "given": "A user is authenticated and a content item exists with a specific ID",
      "when": "A request is made to duplicate the content item",
      "then": "The system creates a new content item that is a copy of the original and returns it with a 201 status"
    },
    {
      "given": "A content item has multiple versions stored",
      "when": "A request is made to list all versions for a specific content item ID",
      "then": "The system returns an array of content versions associated with that item"
    },
    {
      "given": "A user is authenticated and a content item exists",
      "when": "A request is made to create a new version for the content item with an authorId and body",
      "then": "The system creates and returns the new content version with a 201 status"
    },
    {
      "given": "Content templates exist, optionally associated with a workspace",
      "when": "A request is made to list templates, optionally filtered by workspace ID",
      "then": "The system returns an array of templates"
    },
    {
      "given": "A user is authenticated and wants to create a new template",
      "when": "A request is made to create a template with required fields (ownerId, title, type)",
      "then": "The system creates and returns the new template with a 201 status"
    },
    {
      "given": "A user is authenticated and a template exists with a specific ID",
      "when": "A request is made to share the template to a target workspace ID",
      "then": "The system successfully shares the template to the specified workspace"
    },
    {
      "given": "A user is authenticated and has sufficient AI generation quota",
      "when": "A request is made to generate content using AI with a prompt and generation type",
      "then": "The system returns an AI-generated response containing variations and metadata"
    },
    {
      "given": "A user is authenticated but has exceeded their AI generation quota",
      "when": "A request is made to generate content using AI",
      "then": "The system responds with a 429 status code indicating 'Quota exceeded'"
    },
    {
      "given": "A user is authenticated and working within a specific workspace",
      "when": "A request is made to save the current session state as a snapshot for that workspace",
      "then": "The system successfully saves the workspace snapshot with a 201 status"
    },
    {
      "given": "Snapshots exist for a given workspace",
      "when": "A request is made to list all snapshots for that workspace ID",
      "then": "The system returns an array of workspace snapshots"
    },
    {
      "given": "A user is authenticated and a content item is ready for scheduling",
      "when": "A request is made to create a schedule with the contentId and scheduledAt timestamp",
      "then": "The system creates the schedule, enqueues the publish job, and returns the schedule details"
    },
    {
      "given": "Schedules exist for content publication",
      "when": "A request is made to list schedules, optionally filtered by workspaceId and a date range (rangeStart, rangeEnd)",
      "then": "The system returns an array of schedules matching the criteria"
    },
    {
      "given": "A user is authenticated and has a content item ready for LinkedIn publication",
      "when": "A request is made to manually trigger an immediate LinkedIn publish job for the content item",
      "then": "The system creates and returns a publish job with a 202 accepted status"
    },
    {
      "given": "A user is authenticated and has a content item that requires approval",
      "when": "A request is made to submit the content item for approval",
      "then": "The system records the approval request with a 201 status"
    },
    {
      "given": "A user with approver permissions is authenticated and an approval request exists",
      "when": "A request is made to update the approval status (e.g., APPROVED, REJECTED) for a given approvalId, with optional comments",
      "then": "The system updates the approval status accordingly"
    },
    {
      "given": "A user is authenticated and an engage feed is available for their workspace",
      "when": "A request is made to retrieve the engage feed for a specific workspace ID",
      "then": "The system returns an array of engagement feed items"
    },
    {
      "given": "A user is authenticated and an external post is identified",
      "when": "A request is made to perform an engagement action (like, comment, or share) on the external post",
      "then": "The system successfully performs the engagement action"
    },
    {
      "given": "A user is authenticated and has exceeded the rate limit for engagement actions",
      "when": "A request is made to perform an engagement action",
      "then": "The system responds with a 429 status code indicating 'Rate limited'"
    },
    {
      "given": "Opportunities data exists for a specific workspace",
      "when": "A request is made to retrieve opportunities for that workspace ID",
      "then": "The system returns an array of opportunities with predicted scores and signals"
    },
    {
      "given": "A user is authenticated",
      "when": "A request is made to trigger an opportunity refresh for a specific workspace ID",
      "then": "The system enqueues a job to refresh the opportunities for the workspace with a 202 status"
    },
    {
      "given": "Analytics data is available for a workspace over a specific time range",
      "when": "A request is made to retrieve the dashboard overview for a workspace and date range",
      "then": "The system returns an analytics overview including impressions, clicks, engagement rate, follower growth, and top content"
    },
    {
      "given": "A Stripe webhook event is sent to the system",
      "when": "A POST request is made to the Stripe webhook endpoint with a valid Stripe-Signature header",
      "then": "The system accepts the event for asynchronous processing and responds with a 200 status"
    },
    {
      "given": "A team has an active subscription managed by Stripe",
      "when": "A request is made to get the subscription status for a specific team ID",
      "then": "The system returns the subscription details including the plan tier and current status"
    },
    {
      "given": "The system is deployed and running",
      "when": "An unauthenticated request is made to the admin health endpoint",
      "then": "The system returns a healthy status and checks for core dependencies like the database and Redis"
    },
    {
      "given": "An admin user is authenticated and a publish job has previously failed",
      "when": "A request is made to retry a specific failed publish job by its ID",
      "then": "The system enqueues a retry for the publish job"
    },
    {
      "given": "A new user attempts to sign up or log in using their LinkedIn account.",
      "when": "The system retrieves the user's LinkedIn profile data, including name, title, connections, and profile picture.",
      "then": "A Scribl user record is successfully created, ensuring authenticity and a seamless LinkedIn-centered workflow."
    },
    {
      "given": "A user has successfully created a Scribl account.",
      "when": "The user proceeds through the guided, multi-step onboarding process, providing their goals, brand voice preferences, posting frequency, and niche selections.",
      "then": "The user's progress is automatically saved at each step, preventing drop-offs."
    },
    {
      "given": "A Team Admin is on the seat selection page.",
      "when": "The Admin selects the desired number of seats and a subscription plan for their team.",
      "then": "A real-time calculator displays the pricing and features, and upon successful payment processing via Stripe, access is provisioned for the team."
    },
    {
      "given": "A Team Admin or designated Org-Admin wishes to connect their organization's LinkedIn page.",
      "when": "The Admin, who is also an admin of the LinkedIn organization page, authenticates via LinkedIn OAuth and consents to the necessary organizational scopes.",
      "then": "The system stores encrypted organization-level tokens, lists the available OrgPages (URNs), and ensures that individual team members do not automatically gain direct LinkedIn access."
    },
    {
      "given": "An Org-Admin has successfully connected an organization's LinkedIn page to their team.",
      "when": "The Org-Admin grants specific team members 'publish' or 'manage_media' rights for a particular connected OrgPage within Scribl.",
      "then": "The system implements server-controlled role-based access, allowing only granted members to perform publishing or media management actions for that OrgPage, without providing them direct LinkedIn-level permissions."
    },
    {
      "given": "A team member with appropriate 'publish' rights attempts to publish content to a connected Organization LinkedIn Page.",
      "when": "The publishing request is routed through the server-side publish pipeline, utilizing the organization's token (or optionally a delegated user's token), with server-enforced grant checks, approvals, and idempotency.",
      "then": "The content is successfully published to the organization's LinkedIn page, and all actions are recorded in audit logs."
    },
    {
      "given": "An Organization LinkedIn Page has an approval workflow configured for publishing.",
      "when": "A team member submits content intended for publishing to that OrgPage.",
      "then": "The content requires explicit approval by a designated Approver or Org Admin before it can be actually published to LinkedIn."
    },
    {
      "given": "An admin user is logged into the application.",
      "when": "The admin navigates to the 'Connect LinkedIn Page' section and clicks the 'Connect LinkedIn Page' button.",
      "then": "The system displays a CTA with an explanation of required scopes, and upon confirmation, redirects the admin to the LinkedIn OAuth authorization page with appropriate scopes and state parameter."
    },
    {
      "given": "An admin user has successfully authorized the application on LinkedIn for an organization.",
      "when": "LinkedIn redirects the user back to the application's callback URL with a 'code' and 'state' parameter.",
      "then": "The system validates the 'state', exchanges the 'code' for an organization access token, calls the LinkedIn API to identify organizations the user administers, persists 'OrganizationLinkedInAccount' and 'OrgLinkedInPage' records for selected organizations and their pages, creates an 'AuditLog' entry, and notifies team admins."
    },
    {
      "given": "An admin user is logged in and has connected one or more Organization LinkedIn Accounts.",
      "when": "The admin requests to view the connected LinkedIn organizations and their pages using GET /api/teams/:teamId/linkedin/orgs.",
      "then": "The system returns a list of all connected OrganizationLinkedInAccounts and their associated OrgLinkedInPages."
    },
    {
      "given": "An admin or manager is logged in, and an OrgLinkedInPage exists for a connected organization.",
      "when": "The admin/manager sends a POST request to /api/teams/:teamId/linkedin/orgs/:orgId/grant with a userId, pageId, and role.",
      "then": "The system creates an OrgPageAccess record, sends a notification to the granted user, and creates an AuditLog entry for the access grant."
    },
    {
      "given": "An admin or manager is logged in, and an OrgPageAccess record exists for a team member on an OrgLinkedInPage.",
      "when": "The admin/manager sends a DELETE request to /api/teams/:teamId/linkedin/orgs/:orgId/grant/:grantId to revoke access.",
      "then": "The system deletes the corresponding OrgPageAccess record."
    },
    {
      "given": "An admin is logged in and has a workspace configured.",
      "when": "The admin sends a PATCH request to /api/workspaces/:workspaceId/settings, specifying one or more OrgLinkedInPage IDs to link and a default publishing identity (org/individual).",
      "then": "The system updates the workspace settings to associate the specified OrgLinkedInPages and sets the default publish identity."
    },
    {
      "given": "A user is a member of the team, has OrgPageAccess.role = PUBLISHER (or is an Admin/Approver) for a specific OrgLinkedInPage, and the workspace does not require content approval.",
      "when": "The user sends a POST request to /api/publish/linkedin/org with contentId, orgAccountId, pageId, and scheduledForUtc.",
      "then": "The system validates the user's role and org token validity, creates a PublishJob with the org's details, and enqueues it for publishing."
    },
    {
      "given": "A user is a member of the team and has OrgPageAccess.role = PUBLISHER (but is not an Approver) for a specific OrgLinkedInPage, and the workspace requires content approval.",
      "when": "The user sends a POST request to /api/publish/linkedin/org to publish content to the OrgLinkedInPage.",
      "then": "The system creates a PublishJob with 'pending_approval' status, instead of immediately enqueuing it for publishing."
    },
    {
      "given": "A PublishJob is enqueued with linkedInProfileId pointing to an organization and a valid OrganizationLinkedInAccount access token.",
      "when": "The publish worker processes the PublishJob.",
      "then": "The worker uses the organization's encrypted access token to publish content to LinkedIn via org-specific endpoints, and stores the resulting org post URN in PublishJob.resultPayload."
    },
    {
      "given": "A PublishJob is enqueued for an organization, but its OrganizationLinkedInAccount.tokenExpiresAt indicates an expired token.",
      "when": "The system attempts to process the PublishJob or perform an operation requiring the token.",
      "then": "The system attempts to refresh the token, or if refresh fails, the operation fails with an actionable message indicating the token is expired."
    },
    {
      "given": "An admin user has successfully completed the LinkedIn OAuth flow for an organization.",
      "when": "The system returns to the application from the OAuth redirect.",
      "then": "The UI displays a list of LinkedIn pages that the authenticating user administers, allowing the admin to select and connect them, and the system only surfaces pages the user actually administers."
    },
    {
      "given": "An admin is on the Team Admin page",
      "when": "They choose one or more LinkedIn pages to connect to the Team, confirm, and save",
      "then": "A success state is shown with the message 'Grant page access to your members' and a quick link"
    },
    {
      "given": "An admin is viewing the 'LinkedIn Pages' section on the Team Admin page",
      "when": "They interact with the page cards",
      "then": "Each page card displays its name, connectedBy, lastSyncedAt, and status"
    },
    {
      "given": "An admin is viewing the 'LinkedIn Pages' section on the Team Admin page",
      "when": "They select the 'Grant access' action for a page",
      "then": "A modal opens for selecting team members and roles (PUBLISHER/APPROVER/MANAGER), showing seat/billing impact"
    },
    {
      "given": "An admin is viewing the 'LinkedIn Pages' section on the Team Admin page",
      "when": "They select the 'Revoke access' action for a page",
      "then": "A confirmation dialog is presented, and an audit trail (who granted, when) is displayed"
    },
    {
      "given": "A user is in the content editor/publish modal, and the workspace has connected organization pages",
      "when": "They attempt to publish content",
      "then": "An option 'Publish as: [Me] / [Company Page]' is available"
    },
    {
      "given": "A user is in the content editor/publish modal and selects a Company Page",
      "when": "The user does not have the PUBLISHER role for that page and attempts to publish",
      "then": "The publish option is disabled, showing 'You need publisher access. Request access'"
    },
    {
      "given": "A user is presented with the message 'You need publisher access. Request access' with a request button",
      "when": "They click the request button",
      "then": "An access request is sent to admins, creating a notification and an AuditLog"
    },
    {
      "given": "The workspace is configured to require approval for company posts",
      "when": "A user submits a post for publishing to a Company Page",
      "then": "A pending approval is created that must be actioned by someone with an OrgPageAccess.role = APPROVER or a Team Admin"
    },
    {
      "given": "An approval for a company post is pending in the Approvals queue",
      "when": "An approver views the queue",
      "then": "The entry clearly shows 'posting as {Company Page}'"
    },
    {
      "given": "Posts have been published by various users and as different entities (personal/organization)",
      "when": "A user views the Publish Jobs / History",
      "then": "Filters are available to show posts by publishedBy and publishedAs (org page vs personal)"
    },
    {
      "given": "Posts have been published by various users and as different entities (personal/organization)",
      "when": "Analytics data is generated",
      "then": "Posts published as ORGANIZATION are tagged accordingly for differentiation"
    },
    {
      "given": "An admin attempts to connect an Organization LinkedIn page",
      "when": "The system verifies the connecting LinkedIn user's administrative rights for that page",
      "then": "If the user is not a valid LinkedIn page admin, the connection is refused, and an appropriate message is displayed"
    },
    {
      "given": "An admin is a valid LinkedIn page admin for an organization",
      "when": "They successfully connect the Org LinkedIn page",
      "then": "OrgLinkedInPage and OrganizationLinkedInAccount records are created, and the connected page is visible in the Team Admin UI"
    },
    {
      "given": "An admin attempts to connect an organization page",
      "when": "The provided LinkedIn scopes are missing required permissions for the intended functionality",
      "then": "The connection is refused, and the admin is instructed to request the correct scopes"
    },
    {
      "given": "An organization LinkedIn account has scheduled publishes",
      "when": "LinkedIn returns a 401 response for an API call, indicating a revoked token",
      "then": "The organization account is marked as active = false, admins are notified, and scheduled organization publishes are paused"
    },
    {
      "given": "OrgPage access is configured as a billable entitlement",
      "when": "PUBLISHER or APPROVER access is granted to a user for an organization page",
      "then": "The pricing & seat change modal is displayed during the granting process"
    },
    {
      "given": "A publish request for content is sent",
      "when": "The system processes the publish request",
      "then": "An idempotencyKey is used to prevent duplicate postings"
    },
    {
      "given": "An action occurs that grants or changes access to an organization page",
      "when": "The system records this event",
      "then": "The event is audited and its history is visible to Organization Owners"
    },
    {
      "given": "An Admin user is logged in",
      "when": "The Admin navigates to an organization page's settings and grants a PUBLISHER, APPROVER, or MANAGER role to a team member",
      "then": "An OrgPageAccess record is created, and the team member receives a notification"
    },
    {
      "given": "A user has the PUBLISHER role for an organization page",
      "when": "The user attempts to publish content as the organization, and the content is approved or approvals are disabled",
      "then": "A publish job is created and executed using the organization's account, and the job includes 'publishedAs' metadata and stores the returned organization post URN"
    },
    {
      "given": "A user does not have the PUBLISHER role (or Admin role) for an organization page",
      "when": "The user attempts to publish content as the organization",
      "then": "The publication attempt is blocked, and the user is notified of insufficient permissions"
    },
    {
      "given": "A user has the PUBLISHER role for an organization page",
      "when": "The user attempts to publish content as the organization, and content approvals are pending",
      "then": "The publication attempt creates a pending approval request"
    },
    {
      "given": "An OrganizationLinkedInAccount exists with an active token",
      "when": "The organization's LinkedIn token expires or is revoked",
      "then": "The OrganizationLinkedInAccount.active status is set to false, any scheduled organization publishes are paused, and administrators receive notifications"
    },
    {
      "given": "An Admin user performs role grant changes OR a user publishes content as an organization",
      "when": "These actions occur",
      "then": "Corresponding entries are logged to the AuditLog"
    },
    {
      "given": "An OrganizationLinkedInAccount is active and connected via a specific user",
      "when": "The LinkedIn page's administrator changes on LinkedIn, or the connecting user's permissions are removed for that page",
      "then": "The system re-validates the connection, revokes access if no longer valid, marks the account inactive, and notifies admins to re-connect or provide a new authorizing user"
    },
    {
      "given": "Multiple organization pages are managed by a team",
      "when": "An administrator configures the system to manage these pages",
      "then": "The system allows mapping different organization pages to different workspaces"
    },
    {
      "given": "An organization has defined publishing rate limits on LinkedIn",
      "when": "Content is published as the organization exceeding the rate limit",
      "then": "Per-organization throttles are enforced, and queue retries are managed"
    },
    {
      "given": "An Admin user is logged in",
      "when": "The Admin navigates to 'Team Admin → LinkedIn Pages → Connect LinkedIn Page', completes the LinkedIn Authorization flow, and selects pages they administer to connect",
      "then": "The system stores the organization account and page entries, and displays a success message"
    },
    {
      "given": "A Team Admin is logged in and viewing an organization page card",
      "when": "The Team Admin opens the page card, selects 'Grant Access', chooses specific users and the PUBLISHER role, and confirms the grant",
      "then": "The selected users receive a notification and can now select the organization page in the composer publish menu (if workspace mapped)"
    },
    {
      "given": "A team member with PUBLISHER role selects an organization in the composer",
      "when": "The member chooses 'Publish as: [Org Name]' and initiates publication when approval is required",
      "then": "The content is submitted for approval, and a PublishJob is created and executed after approval"
    },
    {
      "given": "A team member with PUBLISHER role selects an organization in the composer",
      "when": "The member chooses 'Publish as: [Org Name]' and initiates publication when no approval is required",
      "then": "A scheduled PublishJob is immediately created, the Publisher uses the organization token at runtime, a success notification is sent on completion, and the PublishJob.resultPayload includes the orgPostUrn"
    },
    {
      "given": "A team uses SSO for user authentication and has defined mapping processes",
      "when": "An SSO group admin connects their account via SSO to Scribl",
      "then": "The system considers auto-mapping that SSO group admin to an Org manager role in Scribl"
    },
    {
      "given": "A user is an authenticated member with an appropriate role for a specific team",
      "when": "The user attempts to access or modify data scoped to that team",
      "then": "The user should successfully access or modify the data, with app-layer and DB-layer checks validating access"
    },
    {
      "given": "A user is an authenticated member with an appropriate role for a specific workspace within a team",
      "when": "The user attempts to access or modify data scoped to that workspace",
      "then": "The user should successfully access or modify the data, with app-layer and DB-layer checks validating access"
    },
    {
      "given": "A user is authenticated but is not a member or does not have an appropriate role for a specific team or workspace",
      "when": "The user attempts to access or modify data scoped to that unauthorized team or workspace",
      "then": "The system should prevent the user from accessing or modifying the data, and return an authorization error"
    },
    {
      "given": "A team has a maximum 'seatCount' according to its plan",
      "when": "An invited user accepts the invitation to join the team, and accepting would exceed the 'seatCount'",
      "then": "The system should prevent the user from joining and inform them that the team has reached its seat limit"
    },
    {
      "given": "A team has a maximum 'seatCount' according to its plan",
      "when": "An inactive user within the team is activated, and activating would exceed the 'seatCount'",
      "then": "The system should prevent the user from being activated and inform the team that the seat limit has been reached"
    },
    {
      "given": "A user performs a key business action (e.g., creating content, inviting a member, changing settings)",
      "when": "The action is successfully completed",
      "then": "An 'AuditLog' entry should be created, containing the actor, timestamp, action, and relevant metadata (including 'teamId' and 'workspaceId' if applicable)"
    },
    {
      "given": "A user is logged in and has selected a specific workspace within their team",
      "when": "The user navigates to view templates, content items, or analytics",
      "then": "Only items scoped to the selected workspace (or team-level/global items permitted for the selected team) should be displayed"
    },
    {
      "given": "The system is designed to store multi-tenant business data",
      "when": "New data models are defined or existing ones are updated for tenant-scoped entities (e.g., ContentItem, Workspace, LinkedInPost)",
      "then": "Each relevant model should include a 'teamId' field, and 'workspaceId' where applicable, with appropriate database indexes, to ensure data segregation"
    },
    {
      "given": "An authenticated user makes an API request specifying a 'teamId' and/or 'workspaceId'",
      "when": "The request reaches the application's authorization middleware",
      "then": "The middleware should verify the user's roles and membership against the specified 'teamId' and 'workspaceId' before allowing further processing"
    },
    {
      "given": "An application initiates a database session for a user within a specific team context",
      "when": "The application sets a session variable 'SET LOCAL app.current_team = 'team-uuid'' for that database session",
      "then": "Postgres Row-Level Security policies should automatically filter queries to show only data where 'team_id' matches 'app.current_team', preventing cross-tenant data access at the database level"
    },
    {
      "given": "A 'content_item' table exists in the database",
      "when": "Row Level Security is enabled and a 'content_item_tenant_isolation' policy is applied",
      "then": "Access to 'content_item' records is restricted based on 'team_id' matching 'current_setting('app.current_team')'."
    },
    {
      "given": "A database connection is established for a user request",
      "when": "The 'SET LOCAL app.current_team = '...' ' command is executed on the DB connection",
      "then": "Subsequent queries within that connection respect the 'app.current_team' setting for RLS policies."
    },
    {
      "given": "An application uses Prisma/ORM for database interactions",
      "when": "Server-side middleware or Prisma middleware is configured to manage 'teamId' constraints",
      "then": "Write operations (e.g., 'create ContentItem') automatically assign 'teamId' from 'req.user.activeTeamId', and read operations automatically inject 'where: { teamId: req.user.activeTeamId }' constraints, and 'SET LOCAL app.current_team' is executed within the same DB session before Prisma calls."
    },
    {
      "given": "An authorization system is in place",
      "when": "Roles are defined for different levels of access",
      "then": "Team-level roles include OWNER, ADMIN, BILLING, MEMBER, and Workspace-level roles include WORKSPACE_ADMIN, EDITOR, APPROVER, VIEWER, with granular permissions stored in a 'RolePermissions' table or encoded in code, and role-to-permission mapping stored in configuration."
    },
    {
      "given": "A user sends a request with a session cookie",
      "when": "The 'authMiddleware' is executed",
      "then": "The session token is decoded, the 'userId' is extracted, the user object is loaded and attached to the request ('req.user'), or a '401 Unauthorized' response is returned if the token is invalid or user not found."
    },
    {
      "given": "A user ('userId') and a 'teamId' (from params/query/default) are identified in the 'authMiddleware'",
      "when": "The middleware attempts to load 'TeamMember' entries for the user and team",
      "then": "The 'teamId' parameter is verified to be one of the user's teams, and if the user is not a member of the specified team, a '403 Forbidden' response is returned."
    },
    {
      "given": "A user is authenticated and verified as a team member within the 'authMiddleware'",
      "when": "The middleware processes the request",
      "then": "A 'userContext' object '{ userId, teamId, workspaceId, roles: [...] }' is attached to the request."
    },
    {
      "given": "RLS is in use and 'authMiddleware' has identified the 'teamId' for the request",
      "when": "The middleware executes 'await prisma.$executeRaw`SET LOCAL app.current_team = ${teamId}` '",
      "then": "The 'app.current_team' setting in the DB connection is updated to the identified 'teamId' for the current request."
    },
    {
      "given": "An API endpoint is designed to return or change tenant data",
      "when": "The endpoint is invoked",
      "then": "The API call must require a 'teamId' or operate within the currently-selected team scope, and must not return cross-tenant data."
    },
    {
      "given": "A user is a member of a team",
      "when": "They make a 'GET /api/teams/:teamId/workspaces' request",
      "then": "They can list workspaces belonging to that team."
    },
    {
      "given": "A user has ADMIN or OWNER role within a team",
      "when": "They make a 'POST /api/teams/:teamId/workspaces' request",
      "then": "They can create a new workspace within that team."
    },
    {
      "given": "A user has appropriate RBAC permissions for a workspace",
      "when": "They make a 'GET /api/teams/:teamId/workspaces/:workspaceId/content?status=&type=' request",
      "then": "They can list content for that specific workspace based on their roles."
    },
    {
      "given": "A user has permissions to invite team members and there are available seats",
      "when": "They make a 'POST /api/teams/:teamId/invite' request",
      "then": "Invites are created, seat checks are performed, and an audit log entry is recorded."
    },
    {
      "given": "A user is part of a team",
      "when": "They make a 'GET /api/teams/:teamId/templates?scope=workspace' request",
      "then": "They can view templates scoped to their workspace."
    },
    {
      "given": "A user is logged into the application",
      "when": "They navigate through different pages",
      "then": "The global layout explicitly shows the current Team and Workspace via switchers and breadcrumbs, indicates plan/seat summary in the header, and prevents user confusion about context."
    },
    {
      "given": "A user accesses the Team Admin console",
      "when": "They navigate the console",
      "then": "Pages for Team settings, Members, Workspaces, Templates, and Audit are available for management."
    },
    {
      "given": "A user opens the invite modal in the Team Admin console",
      "when": "They interact with the modal",
      "then": "It provides multi-email input, role selector, optional initial workspace assignment, real-time seat usage preview, blocks invitation if exceeding available seats, and shows invite expiration with a resend option."
    },
    {
      "given": "A user is on a page displaying content within a workspace",
      "when": "They use the Workspace selector",
      "then": "The displayed content, analytics, and templates are filtered according to the selected workspace."
    },
    {
      "given": "a user is in a specific workspace",
      "when": "the user creates new content",
      "then": "the content is automatically associated with that workspace."
    },
    {
      "given": "a user has permission to multiple workspaces\nAND the user is in a specific workspace",
      "when": "the user creates new content and selects another permitted workspace from a dropdown",
      "then": "the content is associated with the selected workspace."
    },
    {
      "given": "a user does not have permission to another workspace\nAND the user is in a specific workspace",
      "when": "the user attempts to select another workspace from a dropdown during content creation",
      "then": "the dropdown does not show the unpermitted workspace, or the selection is blocked."
    },
    {
      "given": "a user is viewing the templates gallery",
      "when": "templates are displayed",
      "then": "each template shows its scope badge (Personal, Workspace, Team, or Global)."
    },
    {
      "given": "a user is saving a new template",
      "when": "the user selects a scope from 'Personal', 'Workspace', or 'Team'",
      "then": "the template is saved with the chosen scope."
    },
    {
      "given": "a user attempts to navigate to a team they are not a member of",
      "when": "the system detects the unauthorized access",
      "then": "a clear message is displayed informing the user of access denial, along with a Call To Action (CTA) to request access."
    },
    {
      "given": "a user attempts to perform an action within a workspace for which they lack permission",
      "when": "the system detects the unauthorized action",
      "then": "an explanation message is displayed, along with a link to request access."
    },
    {
      "given": "an Admin user logs into the system",
      "when": "the Admin navigates to the Audit Viewer",
      "then": "the Audit Viewer UI is displayed, including search, filters (actor, time range, action type, targetType), and a CSV export option."
    },
    {
      "given": "an Admin user is viewing audit logs in the Audit Viewer",
      "when": "the Admin selects a specific audit entry",
      "then": "a detail panel appears, showing metadata for the entry and a link to the related entity if applicable."
    },
    {
      "given": "a team has members with various roles (OWNER, ADMIN, EDITOR, VIEWER)",
      "when": "the system calculates used seats",
      "then": "only members with configurable seat-consuming roles (e.g., OWNER, ADMIN, EDITOR) are counted towards seat usage."
    },
    {
      "given": "a team has available seats\nAND the sum of 'seatsUsed + pendingInvites + newInvites' is less than or equal to 'seatCount'",
      "when": "an admin attempts to create new invites",
      "then": "the invites are successfully created."
    },
    {
      "given": "a team has available seats\nAND the sum of 'seatsUsed + pendingInvites + newInvites' would exceed 'seatCount'",
      "when": "an admin attempts to create new invites",
      "then": "the invite creation is blocked, and an upgrade Call To Action (CTA) is displayed."
    },
    {
      "given": "a team has only one seat remaining\nAND multiple users attempt to accept invites simultaneously",
      "when": "the system processes invite acceptances with a transactional check (e.g., SELECT FOR UPDATE)",
      "then": "only one user successfully consumes the last seat, and subsequent attempts are handled appropriately (e.g., blocked or informed of no seats)."
    },
    {
      "given": "a user is in a non-seat-consuming role (e.g., VIEWER)\nAND a team has available seats",
      "when": "an admin promotes the user to a seat-consuming role (e.g., EDITOR)",
      "then": "the role change is successful, and a seat is consumed."
    },
    {
      "given": "a user is in a non-seat-consuming role\nAND a team has no available seats",
      "when": "an admin attempts to promote the user to a seat-consuming role",
      "then": "the role change is blocked, or the system requires admin confirmation to increase seats."
    },
    {
      "given": "a team has a defined 'seatCount'",
      "when": "SCIM provisioning attempts to add users that would exceed the 'seatCount'",
      "then": "a SCIM error is returned."
    },
    {
      "given": "an admin is viewing the Team Admin section",
      "when": "the seat meter is displayed",
      "then": "it accurately shows 'Used / Total' seats."
    },
    {
      "given": "an admin is attempting to send new invites",
      "when": "the invite creation interface is shown",
      "then": "a predictive seat count 'X / Y' (after sending invites) is displayed."
    },
    {
      "given": "an admin attempts to send invites\nAND the invite count would exceed available seats",
      "when": "the system enforces the seat limit",
      "then": "invites are blocked, and an upgrade modal is displayed."
    },
    {
      "given": "a user performs an action (e.g., login, create content, change role, accept invite, publish content)",
      "when": "the action is completed",
      "then": "an audit log entry is created for that action, including relevant details."
    },
    {
      "given": "an admin user is viewing the Audit Viewer",
      "when": "the admin applies date-range and action filters\nAND selects the CSV export option",
      "then": "a CSV file containing the filtered audit logs is downloaded."
    },
    {
      "given": "audit logs are generated",
      "when": "the system applies its retention policy",
      "then": "audit logs are retained for the default period (e.g., 12-24 months), with an option for longer retention for enterprise customers."
    },
    {
      "given": "an existing database schema for tenant-scoped tables",
      "when": "a data migration is performed",
      "then": "'teamId' and 'workspaceId' columns are added to relevant tables, indexes are created, and legacy rows are backfilled with inferred 'teamId'/'workspaceId' values where possible."
    },
    {
      "given": "a user with \"Editor\" role",
      "when": "the user attempts to create content in their assigned workspace",
      "then": "the content is successfully created"
    },
    {
      "given": "a user with \"Editor\" role assigned to \"Workspace A\"",
      "when": "the user attempts to modify content existing in \"Workspace B\"",
      "then": "the system returns a \"403 Forbidden\" error"
    },
    {
      "given": "only one seat remaining in the team's subscription",
      "when": "two different users simultaneously accept an invitation to join the team",
      "then": "only one user successfully joins the team and consumes the last seat"
    },
    {
      "given": "a user creates a new template",
      "when": "the user saves the template with \"Team\" scope",
      "then": "the template is visible and accessible to all other members of that team"
    },
    {
      "given": "a user creates a new template",
      "when": "the user saves the template with \"Workspace\" scope",
      "then": "the template is visible and accessible only to members of that specific workspace"
    },
    {
      "given": "a user modifies content in a workspace",
      "when": "the modification is successfully saved",
      "then": "an \"AuditLog\" entry is created with accurate metadata including actor, team, workspace, action, target type, and target ID"
    },
    {
      "given": "an administrator creates an invite for a new user",
      "when": "the new user accepts the invite via LinkedIn authentication",
      "then": "a \"TeamMember\" record is created for the user and the available seat count for the team is decremented by one"
    },
    {
      "given": "a user creates a new workspace",
      "when": "the workspace creation is complete",
      "then": "the new workspace has its own set of templates and content, separate from other existing workspaces"
    },
    {
      "given": "a user belongs to \"Team A\"",
      "when": "the user attempts to retrieve content belonging to \"Team B\" by guessing its ID",
      "then": "the system returns a \"403 Forbidden\" error or an empty result, without revealing sensitive information"
    },
    {
      "given": "the system is under heavy publishing load",
      "when": "multiple concurrent content publishing events occur",
      "then": "the \"AuditLog\" service successfully writes all audit entries without significant performance degradation or errors"
    },
    {
      "given": "a large batch of user provisioning requests via SCIM",
      "when": "multiple concurrent requests attempt to provision users and consume seats",
      "then": "the seat management system correctly handles concurrency and prevents over-provisioning beyond the subscribed seat limit"
    },
    {
      "given": "RLS policies are enabled on the database",
      "when": "a database user attempts to directly query rows belonging to a team they are not authorized for",
      "then": "the database returns only rows for the authorized team or no rows, without exposing cross-team data"
    },
    {
      "given": "a user is logged in",
      "when": "the user creates, edits, deletes, or versions a template with \"Personal\" scope",
      "then": "the template is stored in their \"My Space\" personal workspace and can be instantiated when creating new content"
    },
    {
      "given": "a user has created a personal template in their \"My Space\"",
      "when": "another user attempts to view this template",
      "then": "the personal template is only visible to the owning user and not to any other user"
    },
    {
      "given": "a user has a personal template and write permissions for a specific workspace",
      "when": "the user promotes the personal template to \"Workspace\" scope",
      "then": "the template becomes visible and editable to other members of that specific workspace"
    },
    {
      "given": "a user has a personal template and requests to promote it to \"Team\" or \"Global\" scope",
      "when": "an administrator approves the promotion request",
      "then": "the template becomes visible and accessible to the relevant scope (all team members or globally) as intended"
    },
    {
      "given": "a user creates or edits a template",
      "when": "the template is saved",
      "then": "the template includes metadata such as 'type', 'category', 'industry', 'placeholders', and 'preview image'."
    },
    {
      "given": "a promoted template exists",
      "when": "its metadata is viewed",
      "then": "it includes 'performance stats'."
    },
    {
      "given": "a user creates a template in their 'My Space' workspace",
      "when": "the template is stored",
      "then": "the template is isolated by 'ownerId' set to the user's ID and 'teamId' is null."
    },
    {
      "given": "a user creates a template in a 'Team Space' workspace",
      "when": "the template is stored",
      "then": "the template is isolated by 'ownerId' set to the user's ID and 'teamId' set to the team's ID."
    },
    {
      "given": "a user is editing a template",
      "when": "changes are made",
      "then": "the template edits are automatically saved and previous versions are available."
    },
    {
      "given": "a user opens the template picker with both personal and team templates available",
      "when": "they search for templates",
      "then": "personal templates matching the search criteria are shown first in the results."
    },
    {
      "given": "a new user account is provisioned",
      "when": "the user accesses their workspaces",
      "then": "they have a private 'My Space' workspace, data is private to the user unless shared, and storage is limited by their plan."
    },
    {
      "given": "an Enterprise plan user is part of a team",
      "when": "they access their workspaces",
      "then": "they have access to one or more 'Team Space' workspaces with shared templates, content, analytics, and larger storage quotas."
    },
    {
      "given": "a user has exceeded their individual storage quota (e.g., 'My Space')",
      "when": "the user attempts to upload new content",
      "then": "the upload is prevented, the UI displays a quota exceeded message, and an upgrade CTA is shown."
    },
    {
      "given": "a team has exceeded its collective storage quota (e.g., 'Team Space')",
      "when": "a team member attempts to upload new content into a 'Team Space' workspace",
      "then": "the upload is prevented, the UI displays a quota exceeded message, and an upgrade CTA is shown."
    },
    {
      "given": "content is uploaded into a 'Team Workspace'",
      "when": "storage usage is updated",
      "then": "the content's size is consumed from 'Team.storageQuotaBytes' and 'Team.storageUsedBytes' is updated."
    },
    {
      "given": "content is uploaded into a user's 'My Space' workspace by an Individual plan user",
      "when": "storage usage is updated",
      "then": "the content's size is consumed from 'User.storageQuotaBytes' and 'User.storageUsedBytes' is updated."
    },
    {
      "given": "a user views their workspace or account dashboard",
      "when": "the page loads",
      "then": "the UI displays usage meters for their current storage."
    },
    {
      "given": "discrepancies may exist in 'storageUsedBytes' values",
      "when": "a periodic reconciliation job runs",
      "then": "the 'storageUsedBytes' fields for users, teams, and workspaces are accurately updated."
    },
    {
      "given": "a user or team performs a data read or write operation",
      "when": "the operation executes",
      "then": "the operation is tenant-scoped by 'teamId' or 'workspaceId' and RBAC policies are enforced."
    },
    {
      "given": "data is uploaded to the storage system (e.g., S3/Supabase)",
      "when": "the data is stored",
      "then": "its storage path or bucket is separate or logically namespaced based on 'teamId' or 'userId'."
    },
    {
      "given": "a user's or team's storage quota changes or an overage occurs",
      "when": "the system detects the change",
      "then": "billing records are updated accordingly, the admin UI shows usage per user/team, and notifications alert users nearing quotas."
    },
    {
      "given": "A user has available storage quota in their 'My Space' (user-level quota applies).",
      "when": "The user uploads a file to 'My Space'.",
      "then": "The upload is successful, and User.storageUsedBytes is incremented."
    },
    {
      "given": "A user's 'My Space' storage quota is exhausted, and overage billing is not enabled.",
      "when": "The user attempts to upload a file to 'My Space'.",
      "then": "The upload is blocked, and a 'Quota exceeded, upgrade' CTA is displayed."
    },
    {
      "given": "A workspace has a specific 'workspace.storageQuotaBytes' set, and there is available quota.",
      "when": "A user uploads a file to this workspace.",
      "then": "The upload is successful, and workspace.storageUsedBytes is incremented."
    },
    {
      "given": "A workspace's specific 'workspace.storageQuotaBytes' is exhausted, and overage billing is not enabled.",
      "when": "A user attempts to upload a file to this workspace.",
      "then": "The upload is blocked, and a 'Quota exceeded, upgrade' CTA is displayed."
    },
    {
      "given": "A workspace belongs to a team, does not have a specific 'workspace.storageQuotaBytes' set, and the team has available storage quota.",
      "when": "A user uploads a file to this workspace.",
      "then": "The upload is successful, and team.storageUsedBytes is incremented."
    },
    {
      "given": "A workspace belongs to a team, does not have a specific 'workspace.storageQuotaBytes' set, the team's storage quota is exhausted, and overage billing is not enabled.",
      "when": "A user attempts to upload a file to this workspace.",
      "then": "The upload is blocked, and a 'Quota exceeded, upgrade' CTA is displayed."
    },
    {
      "given": "A user's, workspace's, or team's storage quota is exhausted, and overage billing (charge per GB) is enabled.",
      "when": "The user attempts to upload a file.",
      "then": "The upload is allowed, and a charge for overage is initiated with the billing system."
    },
    {
      "given": "A user/team has exhausted their base quota, but an admin has granted temporary extra quota via 'TeamFeature' or 'QuotaOverride' model.",
      "when": "The user uploads a file, and the upload size is within the temporary extra quota.",
      "then": "The upload is successful, and storage usage is incremented within the context of the override."
    },
    {
      "given": "A client requests an upload pre-signed URL for a file of 'sizeBytes', and the effective available quota (effectiveQuota - effectiveUsed) is greater than 'sizeBytes'.",
      "when": "The 'POST /api/media/upload-url' endpoint is called with 'workspaceId', 'fileName', 'contentType', 'sizeBytes'.",
      "then": "The server generates and returns a pre-signed URL, creates an 'Image' record in 'uploading' state, and increments the relevant 'storageUsedBytes' (workspace/team/user) by 'sizeBytes' as reserved allocation within a transaction."
    },
    {
      "given": "A client requests an upload pre-signed URL for a file of 'sizeBytes', and the effective available quota (effectiveQuota - effectiveUsed) is less than 'sizeBytes'.",
      "when": "The 'POST /api/media/upload-url' endpoint is called with 'workspaceId', 'fileName', 'contentType', 'sizeBytes'.",
      "then": "The server responds with a '422' status code, indicating 'quotaExceeded', and provides 'availableBytes' along with an 'upgradeUrl' or 'billingInfo'."
    },
    {
      "given": "An 'Image' record exists in the database in an 'uploading' state, and the client has successfully uploaded the file to storage.",
      "when": "The client calls 'POST /api/media/confirm-upload' with 'imageId' (or a storage webhook confirms the upload).",
      "then": "The 'Image.state' is updated to 'available', and the reserved 'storageUsedBytes' remains as is."
    },
    {
      "given": "An 'Image' record exists in the database in an 'uploading' state, and the corresponding upload to storage has failed or timed out within its TTL.",
      "when": "A background job runs periodically to clean stale uploading images.",
      "then": "The background job deletes the stale 'Image' record and decrements the corresponding reserved 'storageUsedBytes'."
    },
    {
      "given": "A user attempts to delete an 'Image' for which they have appropriate permissions.",
      "when": "The 'DELETE /api/media/:id' endpoint is called.",
      "then": "The server marks 'Image.deleted = true', decrements the relevant 'storageUsedBytes' (workspace/team/user) within a transaction, and the file is asynchronously deleted from storage."
    },
    {
      "given": "The 'storageUsedBytes' counters might have drifted from actual stored bytes due to failed operations or inconsistencies.",
      "when": "A periodic worker (e.g., daily) runs to rescan storage or compute usage from the database.",
      "then": "The worker corrects any drift, ensuring 'storageUsedBytes' is consistent with actual stored bytes, and alerts if the drift exceeds a defined threshold."
    },
    {
      "given": "A user's or team's subscription changes, resulting in an increased storage quota.",
      "when": "A Stripe webhook or similar mechanism triggers a quota update.",
      "then": "The 'User.storageQuotaBytes' or 'Team.storageQuotaBytes' is updated to the new, higher value."
    },
    {
      "given": "A user's or team's subscription changes, resulting in a decreased storage quota that is now below their current 'storageUsedBytes', and the policy is to block new uploads after a grace period.",
      "when": "A Stripe webhook or similar mechanism triggers a quota update after the grace period has expired.",
      "then": "The 'User.storageQuotaBytes' or 'Team.storageQuotaBytes' is updated, new uploads are disabled until usage is resolved, and admins are notified."
    },
    {
      "given": "A user's or team's subscription changes, resulting in a decreased storage quota that is now below their current 'storageUsedBytes'.",
      "when": "A Stripe webhook or similar mechanism triggers a quota update, and a grace period (e.g., 7 days) is applied.",
      "then": "The 'User.storageQuotaBytes' or 'Team.storageQuotaBytes' is updated, and new uploads are not immediately blocked, allowing the user/team to resolve their usage during the grace period."
    },
    {
      "given": "A user wants to view their personal storage usage information.",
      "when": "The user calls the 'GET /api/usage/me' endpoint.",
      "then": "The API returns a JSON object containing 'userUsedBytes', 'userQuotaBytes', an array of 'workspaces' (with 'id', 'used', 'quota'), 'teamUsedBytes', and 'teamQuotaBytes'."
    },
    {
      "given": "An administrator wants to view a specific team's storage usage breakdown and top consumers.",
      "when": "The administrator calls the 'GET /api/teams/:teamId/usage' endpoint.",
      "then": "The API returns a usage breakdown for the specified team, including detailed usage and top consumers."
    },
    {
      "given": "Overage billing is allowed, and a subscription change (upgrade/downgrade) occurs that impacts a user's or team's quota.",
      "when": "A Stripe webhook triggers a quota update, requiring billing integration.",
      "then": "A prorated charge for additional quota or a credit is computed, an invoice/charge is created in Stripe using the appropriate billing API, and 'QuotaCharge' records are tracked for reconciliation."
    },
    {
      "given": "A user initiates an image upload with a specified sizeBytes.",
      "when": "The system attempts to reserve storage.",
      "then": "A new image record is created in 'uploading' state, and the relevant storage counter (workspace, team, or user) is incremented by sizeBytes within a transaction."
    },
    {
      "given": "An image upload reservation exists with a corresponding 'uploading' state record.",
      "when": "The upload is successfully confirmed.",
      "then": "The image record's state is updated to 'available', its 'uploadedAt' timestamp is set, and no storage counters are changed."
    },
    {
      "given": "An image upload reservation exists with a corresponding 'uploading' state record.",
      "when": "The user cancels the upload or cleanup is initiated for a failed upload.",
      "then": "The image record is deleted, and the relevant storage counter (workspace, team, or user) is decremented by the reserved sizeBytes within a transaction."
    },
    {
      "given": "A user is viewing their 'My Space'.",
      "when": "The global chrome header is displayed.",
      "then": "The quota meter shows 'You’ve used X of Y (My Space)', is color-coded based on usage percentage (green < 80%, yellow 80–95%, red >95%), and displays an 'Upgrade' or 'Request more storage' CTA."
    },
    {
      "given": "A user is viewing a 'Team Workspace'.",
      "when": "The global chrome header is displayed.",
      "then": "The quota meter shows 'Team usage: X of Y (Team); Workspace: a of b', is color-coded based on usage percentage (green < 80%, yellow 80–95%, red >95%), and displays an 'Upgrade' or 'Request more storage' CTA."
    },
    {
      "given": "A user picks an image to upload from the Editor/Carousel Creator.",
      "when": "The client calls POST /api/media/upload-url with sizeBytes and the server responds with 'quotaExceeded'.",
      "then": "A modal is shown with the message 'Upload blocked — you have X available; file is Y.' and provides '[Upgrade]' and '[Optimize image & retry]' options."
    },
    {
      "given": "A user picks an image to upload from the Editor/Carousel Creator and sufficient quota is available.",
      "when": "The client calls POST /api/media/upload-url, a reservation is created, and the upload proceeds successfully.",
      "then": "Upload progress is shown, and on successful completion, the image appears in the editor."
    },
    {
      "given": "An upload reservation is created successfully.",
      "when": "The final confirmation of the upload fails (e.g., due to a timeout).",
      "then": "An error message is displayed to the user, and the UI for that upload is reverted."
    },
    {
      "given": "A Team Admin navigates to the 'Team Settings -> Usage & Billing' page.",
      "when": "The page loads.",
      "then": "The page displays a top summary of seats used/purchased and team storage used/quota, a chart showing daily storage used trend, a table of top consumers sorted by storage with drill-down options, and buttons for 'Increase Storage', 'Assign storage to workspace', and 'Force delete orphaned files'."
    },
    {
      "given": "A team's storage usage exceeds 80% of its quota.",
      "when": "The system monitors the team's storage usage.",
      "then": "The Team Admin receives an alert notification."
    },
    {
      "given": "There is a high rate of upload failures within a team due to quota limitations.",
      "when": "The system monitors upload failure reasons.",
      "then": "The Team Admin receives an alert notification regarding high upload failure due to quota."
    },
    {
      "given": "A user views their 'My Space' page.",
      "when": "The page loads.",
      "then": "The page displays personal templates, content, and images, along with a storage meter showing used/quota, a 'Manage files' link, and an 'Optimize images' quick action."
    },
    {
      "given": "A user's 'My Space' storage usage is near their quota.",
      "when": "The 'My Space' page is displayed.",
      "then": "Tips are shown to the user, such as 'delete drafts', 'compress images', or 'upgrade'."
    },
    {
      "given": "A user clicks the 'Upgrade' button.",
      "when": "The user completes the billing checkout process for a storage add-on via Stripe.",
      "then": "The Stripe webhook updates the 'Team.storageQuotaBytes' or 'User.storageQuotaBytes' accordingly in the database."
    },
    {
      "given": "A downgrade event occurs for storage.",
      "when": "The system computes the new quota, and the current storage usage is greater than the new quota.",
      "then": "The Admin or user is notified with options to delete files, buy an add-on, or accept a scheduled deletion, ensuring no automatic deletion unless policy explicitly allows it."
    },
    {
      "given": "A user attempts to perform a read/write operation on content within a 'MY_SPACE' workspace.",
      "when": "The `authMiddleware` validates the request.",
      "then": "The operation is permitted only if the workspace's 'ownerUserId' matches the 'currentUser.id'."
    },
    {
      "given": "A user attempts to perform a read/write operation on content within a 'teamId' workspace.",
      "when": "The `authMiddleware` validates the request.",
      "then": "The operation is permitted only if the user is a member of that team and possesses an appropriate role for the action."
    },
    {
      "given": "A user has X bytes used and a quota of Y bytes, where X + (size of file to upload) > Y",
      "when": "The user attempts to upload a file via POST /api/media/upload-url",
      "then": "The system should return a 422 status (quotaExceeded) before generating a presigned URL"
    },
    {
      "given": "A user has X bytes used and a quota of Y bytes, where X + (size of file A) + (size of file B) > Y",
      "when": "The user attempts to upload file A and file B in parallel, and both files together exceed the remaining quota",
      "then": "The system should handle reservations atomically, ensuring the final state reflects either one or zero uploads succeeding based on available quota, and counters are correct"
    },
    {
      "given": "A user has uploaded a file of N bytes, and N bytes are reflected in their storageUsedBytes",
      "when": "The user deletes the file via DELETE /api/media/:id",
      "then": "The user's storageUsedBytes counter should be decremented by N bytes"
    },
    {
      "given": "A user's storageUsedBytes is X, and their current plan has a quota of Y (where X <= Y)",
      "when": "The user's plan is downgraded to a new plan with a quota of Z (where X > Z)",
      "then": "An administrator should be notified of the user's quota violation"
    },
    {
      "given": "A user is on an Individual plan (5GB quota) and has uploaded files, bringing their usage near the quota limit",
      "when": "The user attempts to upload a file larger than their remaining quota via the UI",
      "then": "The UI should block the upload and display an 'upgrade' call to action"
    },
    {
      "given": "An enterprise team has Team.storageUsedBytes and Team.storageQuotaBytes, and a user belonging to that team",
      "when": "The user uploads a file to a team workspace",
      "then": "Team.storageUsedBytes should be incremented, and the user's User.storageUsedBytes should remain unchanged"
    },
    {
      "given": "A user has a file in their 'My Space', which counts towards User.storageUsedBytes",
      "when": "The user promotes this file to a Team Space",
      "then": "User.storageUsedBytes should be decremented by the file's size, and Team.storageUsedBytes should be incremented by the file's size"
    },
    {
      "given": "An administrator logs into the Admin UI",
      "when": "The administrator navigates to the team usage section for a specific team or workspace via GET /api/teams/:teamId/usage",
      "then": "The Admin UI should display accurate storageUsedBytes and storageQuotaBytes for that team and its workspaces"
    },
    {
      "given": "A team admin wants to increase their team's storage quota",
      "when": "The team admin initiates a purchase for additional storage via the Admin UI (POST /api/billing/teams/:teamId/add-storage), which integrates with Stripe",
      "then": "A Stripe checkout session should be created, and upon successful payment (via webhook), Team.storageQuotaBytes should be updated accordingly"
    },
    {
      "given": "A state where reconciliation_drift_bytes (difference between actual storage and DB counters) is greater than 1%",
      "when": "The reconciliation job runs",
      "then": "The job should identify and fix mismatches, reducing the reconciliation_drift_bytes to less than 1%"
    },
    {
      "given": "A team's storage_used_bytes exceeds 90% of their storage_quota_bytes",
      "when": "The monitoring system detects this threshold breach",
      "then": "An email alert should be sent to the administrator, and an in-app alert should be triggered"
    },
    {
      "given": "The reconciliation_drift_bytes metric exceeds 5%",
      "when": "The monitoring system detects this threshold breach",
      "then": "An alert should be generated for the operations page to investigate"
    },
    {
      "given": "A significant increase in upload_blocked_quota_exceeded events is detected",
      "when": "The monitoring system identifies a spike in these events",
      "then": "An alert should be generated for the product and operations teams to investigate potential pricing issues"
    },
    {
      "given": "A user is logged into the application",
      "when": "The user navigates to their billing or subscription settings",
      "then": "The user should be able to view their current subscription status, download invoices, and update payment methods"
    },
    {
      "given": "A user is on a 'Normal' subscription tier",
      "when": "The user chooses to upgrade to a 'Pro' subscription tier",
      "then": "The system should process the upgrade with prorated billing, and the user should gain access to 'Pro' features"
    },
    {
      "given": "A user is on a 'Pro' subscription tier",
      "when": "The user chooses to downgrade to a 'Normal' subscription tier",
      "then": "The system should process the downgrade with prorated billing, and the user's feature access should be adjusted accordingly"
    },
    {
      "given": "A user is not subscribed to any plan.",
      "when": "The user completes the checkout process for an Individual plan (e.g., 'Normal' or 'Pro').",
      "then": "A new subscription is created in Stripe, its metadata is mirrored in the local database, and the user's entitlements are activated."
    },
    {
      "given": "A team administrator is not subscribed to any plan for their team.",
      "when": "The administrator completes the checkout process for a Team/Enterprise plan with a specified number of seats.",
      "then": "A new subscription for the team is created in Stripe, its metadata is mirrored in the local database, and the team's entitlements, including seat count, are activated."
    },
    {
      "given": "A user or team has an active subscription.",
      "when": "The user or team administrator initiates an upgrade to a higher plan tier or adds more seats mid-billing cycle.",
      "then": "The subscription is updated in Stripe, a prorated charge is issued, the local database mirrors the updated subscription details, and entitlements are immediately adjusted."
    },
    {
      "given": "A user or team has an active subscription.",
      "when": "The user or team administrator initiates a downgrade to a lower plan tier or reduces seats mid-billing cycle.",
      "then": "The subscription is updated in Stripe, a prorated credit (or charge adjustment) is applied to the next invoice, the local database mirrors the updated subscription details, and entitlements are adjusted accordingly (e.g., at period end or immediately)."
    },
    {
      "given": "A user or team has an active subscription.",
      "when": "The user or team administrator cancels their subscription.",
      "then": "The subscription is marked for cancellation at the end of the current billing period in Stripe, the local database mirrors this status, and entitlements remain active until the period ends."
    },
    {
      "given": "A Stripe webhook event (e.g., 'customer.subscription.updated', 'invoice.payment_succeeded') is received by the system.",
      "when": "The webhook processing service handles the event.",
      "then": "The corresponding subscription and/or invoice data in the local database is updated, ensuring idempotency, and relevant user/team entitlements are automatically adjusted."
    },
    {
      "given": "A user is logged into their account.",
      "when": "The user navigates to their billing user interface.",
      "then": "The user can view their current plan, subscription details, past invoices, and has options to change their plan or update payment methods."
    },
    {
      "given": "A user is logged into their account and views their billing information.",
      "when": "The user updates their default payment method (e.g., credit card).",
      "then": "The default payment method for the customer is updated in Stripe, and the local database (BillingAccount model) reflects this change."
    },
    {
      "given": "A team administrator is logged into their account.",
      "when": "The administrator navigates to the team billing management section.",
      "then": "The administrator can manage team seats, view team usage, and access team invoices."
    },
    {
      "given": "A SaaS administrator is logged into the global admin panel.",
      "when": "The administrator accesses the global revenue metrics dashboard.",
      "then": "The administrator can view aggregated revenue data, subscription statuses, and other key business performance indicators."
    },
    {
      "given": "A user or team has an active subscription plan with defined feature flags, quotas, or seat limits.",
      "when": "The user or team attempts to access a feature or exceed a quota/seat limit.",
      "then": "The system enforces entitlements based on the mirrored subscription data and prevents access or usage if limits are exceeded."
    },
    {
      "given": "The system receives a duplicate Stripe webhook event for an already processed 'stripeEventId'.",
      "when": "The webhook processing service attempts to handle the event.",
      "then": "The system identifies the duplicate event and skips re-processing, maintaining data consistency and idempotency."
    },
    {
      "given": "A significant billing action occurs within the system (e.g., subscription creation, payment method update, plan change).",
      "when": "The system processes the billing action.",
      "then": "A detailed audit log entry is created for the action, capturing relevant event data and timestamp."
    },
    {
      "given": "A user or team has an active subscription.",
      "when": "The user or team administrator purchases an add-on (e.g., additional storage or extra seats).",
      "then": "The subscription in Stripe is updated to include the add-on, a prorated charge is applied, the local database mirrors the updated subscription, and entitlements are immediately adjusted."
    },
    {
      "given": "A user is authenticated and has a billing account",
      "when": "The user requests their billing account details via GET /api/billing/account",
      "then": "The system returns the BillingAccount for the current user/team context"
    },
    {
      "given": "A user is authenticated and has active subscriptions",
      "when": "The user requests their current subscriptions and entitlements via GET /api/billing/subscription",
      "then": "The system returns a list of current subscriptions and associated entitlements"
    },
    {
      "given": "A user wants to subscribe to a plan",
      "when": "The user sends a POST request to /api/billing/create-checkout-session with billingAccountId, planId, recurringInterval, and optionally seats",
      "then": "The system creates a Stripe Checkout Session and returns a checkoutUrl for redirection"
    },
    {
      "given": "A user wants to update their payment method",
      "when": "The user sends a POST request to /api/billing/update-payment-method",
      "then": "The system initiates a process to update the payment method, potentially redirecting to the Stripe Billing Portal or creating a SetupIntent"
    },
    {
      "given": "A user is authenticated and has past invoices",
      "when": "The user requests to list invoices via GET /api/billing/invoices",
      "then": "The system returns a list of invoices associated with their billing account"
    },
    {
      "given": "A user is authenticated and has a specific invoice",
      "when": "The user requests the PDF for a specific invoice via GET /api/billing/invoices/:id/pdf",
      "then": "The system returns the URL to the invoice PDF from Stripe or its stored link"
    },
    {
      "given": "A user has an active subscription",
      "when": "The user sends a POST request to /api/billing/cancel-subscription with a policy to cancel at period end",
      "then": "The system updates the subscription status to cancel at the end of the current billing period"
    },
    {
      "given": "A user has an active seat-based subscription",
      "when": "The user sends a POST request to /api/billing/change-seats with a new seat quantity",
      "then": "The system calls the Stripe Subscription API to update the quantity, applying proration based on product policy"
    },
    {
      "given": "A user has an active subscription",
      "when": "The user sends a POST request to /api/billing/change-plan with a new planId",
      "then": "The system calls the Stripe Subscription API to update the plan, applying proration based on product policy"
    },
    {
      "given": "An authenticated Admin or SaaS admin user",
      "when": "The admin requests to list tenant billing accounts via GET /api/admin/billing/tenants",
      "then": "The system returns a list of tenant billing accounts, their status, and MRR"
    },
    {
      "given": "An authenticated Admin or SaaS admin user",
      "when": "The admin sends a POST request to /api/admin/billing/create-override with details for a quota override",
      "then": "The system creates a QuotaOverride record to grant storage or AI credits"
    },
    {
      "given": "An authenticated Admin or SaaS admin user",
      "when": "The admin sends a POST request to /api/admin/billing/reconcile",
      "then": "The system triggers a reconciliation run to synchronize billing data"
    },
    {
      "given": "The system receives a checkout.session.completed webhook from Stripe",
      "when": "The POST /api/webhooks/stripe endpoint processes this event",
      "then": "The system creates or updates the Subscription and BillingAccount records, ensuring idempotency"
    },
    {
      "given": "The system receives an invoice.created webhook from Stripe",
      "when": "The POST /api/webhooks/stripe endpoint processes this event",
      "then": "The system mirrors the Invoice object in its database and stores the hosted invoice URL"
    },
    {
      "given": "The system receives an invoice.paid webhook from Stripe",
      "when": "The POST /api/webhooks/stripe endpoint processes this event",
      "then": "The system updates the mirrored Invoice object in its database, stores the PDF URL if available, and ensures idempotency"
    },
    {
      "given": "A user initiates a checkout flow",
      "when": "The system processes the checkout request",
      "then": "The system either creates a new Stripe Customer or reuses an existing one linked to the user/team"
    },
    {
      "given": "A Stripe Checkout Session is being created",
      "when": "The system creates the Stripe Checkout Session",
      "then": "The system attaches metadata linking to teamId or billingAccountId for traceability"
    },
    {
      "given": "A user upgrades their subscription plan",
      "when": "The system updates the subscription via Stripe's Subscription API",
      "then": "The system applies immediate proration, charging the prorated amount immediately, and creates an invoice for the proration"
    },
    {
      "given": "A user downgrades their subscription plan",
      "when": "The system updates the subscription via Stripe's Subscription API",
      "then": "The system schedules the proration to apply at the end of the current billing period to avoid negative balance surprises"
    },
    {
      "given": "A user is updating their payment method",
      "when": "The system handles the payment method update",
      "then": "The system uses Stripe Billing Portal or SetupIntent to ensure no raw card data is accepted on its servers for PCI-safety"
    },
    {
      "given": "The system receives a Stripe webhook event",
      "when": "The POST /api/webhooks/stripe endpoint processes the event",
      "then": "The system processes the event once, preventing duplicate actions due to re-delivery, using mechanisms like BillingEvent records"
    },
    {
      "given": "The application needs to map internal plan IDs to Stripe product/price IDs",
      "when": "The application starts up or needs to access pricing information",
      "then": "The system retrieves the mapping from a canonical configuration (e.g., PLANS object in ENV or DB)"
    },
    {
      "given": "A subscription plan is defined as seat-based",
      "when": "A user subscribes to or modifies a seat-based plan",
      "then": "The system uses Stripe's subscription quantity feature to represent the number of seats"
    },
    {
      "given": "A user wants to add storage to their existing subscription",
      "when": "The system processes the request to add storage",
      "then": "The system creates separate Stripe products/prices for storage add-ons and adds them as additional subscription items"
    },
    {
      "given": "A Stripe 'invoice.payment_failed' webhook is received",
      "when": "The system processes the webhook",
      "then": "The associated subscription is marked as 'past_due', and admins and the user are notified"
    },
    {
      "given": "A Stripe webhook with a specific 'event.id' has been previously processed and recorded in BillingEvent",
      "when": "The same Stripe webhook (with the same 'event.id') is received again",
      "then": "The system skips re-processing the business logic and returns a success status"
    },
    {
      "given": "A Stripe webhook is received with an invalid signature",
      "when": "The system attempts to construct the event using the 'STRIPE_ENDPOINT_SECRET'",
      "then": "The system rejects the webhook and does not proceed with processing"
    },
    {
      "given": "A valid 'checkout.session.completed' webhook is received",
      "when": "The system processes the webhook",
      "then": "A new billing account and subscription are created or updated, a BillingEvent is recorded, and a BillingAudit entry is created"
    },
    {
      "given": "A valid 'customer.subscription.created' (or 'updated', 'deleted') webhook is received",
      "when": "The system processes the webhook",
      "then": "The Subscription table is updated accordingly, a BillingEvent is recorded, and a BillingAudit entry is created"
    },
    {
      "given": "A valid 'invoice.created' (or 'finalized', 'paid', 'payment_failed') webhook is received",
      "when": "The system processes the webhook",
      "then": "The Invoice table is created or updated, relevant parties are notified, a BillingEvent is recorded, and a BillingAudit entry is created"
    },
    {
      "given": "A valid 'payment_method.attached' webhook is received",
      "when": "The system processes the webhook",
      "then": "The default payment method in the BillingAccount is updated, a BillingEvent is recorded, and a BillingAudit entry is created"
    },
    {
      "given": "A valid 'charge.refunded' webhook is received",
      "when": "The system processes the webhook",
      "then": "Relevant invoices are updated, a BillingAudit entry is created, and a BillingEvent is recorded"
    },
    {
      "given": "A valid 'payment_intent.requires_action' (or 'invoice.payment_action_required') webhook is received",
      "when": "The system processes the webhook",
      "then": "The required action is surfaced to the UI to facilitate SCA flows, a BillingEvent is recorded, and a BillingAudit entry is created"
    },
    {
      "given": "A subscription event has been successfully processed",
      "when": "The system finishes processing the subscription event",
      "then": "Entitlement caches are updated based on 'planId' (enabling/disabling features), 'Team.seatCount' is adjusted, storage quotas are updated, and changes are propagated to in-memory/Redis caches"
    },
    {
      "given": "A user navigates to the '/settings/billing' route",
      "when": "The billing dashboard page loads",
      "then": "The current plan card (name, cadence, renewal), seat count (if team), storage/AI credit usage, and masked primary card on file are displayed, along with options to update payment, change plan, or cancel subscription"
    },
    {
      "given": "An admin navigates to the '/team/:id/billing' route",
      "when": "The team billing dashboard page loads",
      "then": "The team plan, seats, storage usage, next billing date, a control to change seats, an add seats button, an invoices table with download links, billing history export, and billing contact/payment method management are displayed"
    },
    {
      "given": "A user opens the Plan Selector Modal",
      "when": "The user selects a billing cadence and (for teams) seat count, then confirms the plan change",
      "then": "A 'POST /api/billing/create-checkout-session' API call is made, and the user is redirected to the returned Stripe-hosted 'checkoutUrl'"
    },
    {
      "given": "An invoice is displayed in the UI",
      "when": "The user clicks to download the invoice PDF",
      "then": "The system uses 'invoice.invoicePdfUrl' or makes a 'GET /api/billing/invoices/:id/pdf' call to fetch and display/download the PDF"
    },
    {
      "given": "A user is attempting to change their subscription plan",
      "when": "The system prepares to display the plan change confirmation",
      "then": "A 'POST /api/billing/proration-preview' API call is made with the intended changes, and the estimated immediate charge/refund and new recurring price are displayed to the user"
    },
    {
      "given": "A user wants to change their subscription plan.",
      "when": "The user initiates a plan change via the UI.",
      "then": "The system confirms the change and calls POST /api/billing/change-plan to perform the update."
    },
    {
      "given": "A user is increasing the number of seats in their subscription.",
      "when": "The user specifies a new seat number in the UI.",
      "then": "The system displays the cost per seat and allows the change to proceed."
    },
    {
      "given": "An admin is considering increasing or decreasing seats.",
      "when": "The admin requests a proration preview.",
      "then": "The system calls Stripe's upcoming_invoice API to show the exact immediate charge/refund."
    },
    {
      "given": "An invoice is successfully paid.",
      "when": "Stripe emits the corresponding webhook event (e.g., invoice.paid).",
      "then": "The system sends an email notification to the user."
    },
    {
      "given": "An invoice payment fails.",
      "when": "Stripe emits the invoice.payment_failed webhook event.",
      "then": "The system sends an email notification to the user."
    },
    {
      "given": "A subscription is canceled.",
      "when": "Stripe emits the corresponding webhook event (e.g., customer.subscription.deleted).",
      "then": "The system sends an email notification to the user."
    },
    {
      "given": "A team's seat usage is approaching its subscription limit.",
      "when": "The system detects that seat usage is near the limit.",
      "then": "The system sends an email notification to the admin."
    },
    {
      "given": "A team's storage usage is approaching its subscription limit.",
      "when": "The system detects that storage usage is near the limit.",
      "then": "The system sends an email notification to the admin."
    },
    {
      "given": "A payment flow requires Strong Customer Authentication (SCA).",
      "when": "The user attempts to make a payment.",
      "then": "The system prefers Stripe Checkout or Billing Portal to automatically handle the SCA flow."
    },
    {
      "given": "A payment requires user action for SCA outside of automatic Stripe flows.",
      "when": "Stripe indicates that SCA is required.",
      "then": "The system shows a modal notifying the user of the required action and provides a direct link to resolve it."
    },
    {
      "given": "An admin wants to upgrade their team to an Enterprise plan and configure seats.",
      "when": "The admin clicks 'Upgrade -> Enterprise' and enters the desired number of seats in the UI.",
      "then": "The frontend calls POST /api/billing/create-checkout-session including the teamId in the body."
    },
    {
      "given": "The frontend has called POST /api/billing/create-checkout-session.",
      "when": "The server receives the request.",
      "then": "The server creates or reuses a Stripe Customer, creates a Checkout Session storing session.metadata.teamId, and redirects the client to the Stripe Checkout URL."
    },
    {
      "given": "A user is redirected to Stripe Checkout and completes the payment.",
      "when": "Stripe successfully completes the payment and emits the checkout.session.completed webhook.",
      "then": "The webhook receiver verifies the signature, idempotently records the event, creates/updates BillingAccount & Subscription records, sets Team.seatCount and Team.storageQuotaBytes per plan, writes BillingAudit, notifies the admin, and updates entitlements."
    },
    {
      "given": "An admin wants to increase the number of seats for their team.",
      "when": "The admin changes the seat number in the UI.",
      "then": "The client calls POST /api/billing/change-seats with the desired new seat count."
    },
    {
      "given": "The server receives a POST /api/billing/change-seats request.",
      "when": "The server processes the request.",
      "then": "The server calls Stripe subscriptions.update with the subscription item ID, the new quantity, and proration_behavior: 'create_prorations'."
    },
    {
      "given": "Stripe creates and processes a proration invoice for a seat increase.",
      "when": "The invoice.created and invoice.paid webhooks arrive at the server.",
      "then": "The server handles these webhooks to update the local database, set Team.seatCount, and update Subscription.seats."
    },
    {
      "given": "An admin requests a subscription downgrade.",
      "when": "The server checks the policy and determines the downgrade is scheduled for the period end.",
      "then": "The server sets Subscription.cancelAtPeriodEnd or uses stripe.subscriptions.update({ cancel_at_period_end: true })."
    },
    {
      "given": "An admin requests a subscription downgrade.",
      "when": "The server checks the policy and allows an immediate downgrade with proration.",
      "then": "The system proceeds via the change-plan endpoint with defined proration behavior and processes invoices as appropriate."
    },
    {
      "given": "A user wants to update their payment method or view invoices.",
      "when": "The user clicks 'Update payment method' in the UI.",
      "then": "The system redirects the user to the Stripe Billing Portal (after creating a server-side session)."
    },
    {
      "given": "A user manages their cards or views invoices in the Stripe Billing Portal.",
      "when": "Stripe sends customer.updated or payment_method.attached webhooks.",
      "then": "The server's webhook handler updates the local database to reflect these changes."
    },
    {
      "given": "The system receives a Stripe webhook event.",
      "when": "The server processes the webhook.",
      "then": "The system uses a BillingEvent record and stripeEventId to deduplicate events, ensuring idempotency and preventing reprocessing of duplicates."
    },
    {
      "given": "A webhook processing job fails.",
      "when": "The webhook processing encounters an error.",
      "then": "The system marks the job status as failed and attempts to retry or escalates the issue for manual intervention."
    },
    {
      "given": "Two administrators attempt to increase seats simultaneously.",
      "when": "Both requests reach Stripe for subscription updates.",
      "then": "Stripe's subscription update mechanism handles the requests atomically, ensuring data consistency on Stripe's side."
    },
    {
      "given": "Two administrators attempt to increase seats simultaneously and Stripe processes the updates.",
      "when": "Stripe sends the corresponding webhooks for the seat changes.",
      "then": "The local database update is performed only after webhook confirmation, treating Stripe as the source-of-truth for the final state, and avoiding optimistic local changes."
    },
    {
      "given": "An admin attempts to downgrade seats below the currently used seat count.",
      "when": "The admin confirms the downgrade request.",
      "then": "The system either prevents immediate acceptance, or allows scheduled downgrades at period-end, or requires the admin to reduce members before applying the downgrade."
    },
    {
      "given": "An admin attempts to downgrade seats below the currently used seat count.",
      "when": "The admin initiates the downgrade in the UI.",
      "then": "The UI displays an explicit warning and requires confirmation from the admin to proceed."
    },
    {
      "given": "A payment fails for an invoice.",
      "when": "Stripe initiates its dunning settings.",
      "then": "The system relies on Stripe's dunning process to manage subsequent retry attempts and notifications."
    },
    {
      "given": "A payment fails for an invoice.",
      "when": "The invoice.payment_failed webhook is received by the server.",
      "then": "The system marks the subscription as 'past_due', notifies the admin, and optionally disables non-critical features or freezes seat invites after a grace period."
    },
    {
      "given": "A subscription has a failed payment.",
      "when": "The admin needs to retry the payment.",
      "then": "The system provides an in-app retry payment button that links to the hosted invoice or PaymentIntent confirmation page."
    },
    {
      "given": "The system sells internationally and a new team subscribes via checkout.",
      "when": "The user proceeds through the checkout flow.",
      "then": "The system integrates Stripe Tax or requires tax/shipping information collection during checkout and stores tax amounts in Invoice.metadata."
    },
    {
      "given": "A user wants to subscribe to a new plan",
      "when": "The user successfully completes the checkout process via Stripe Checkout",
      "then": "A 'checkout.session.completed' webhook is processed, 'BillingAccount' and 'Subscription' entries are created in the database, and the subscription is active."
    },
    {
      "given": "An existing active subscription with a specific quantity (e.g., seats)",
      "when": "The user changes the quantity of their subscription plan through the application UI",
      "then": "A 'subscription.updated' webhook is processed, the 'Subscription' quantity in the database is updated, and 'Team.seatCount' and 'Team.storageQuotaBytes' are updated accordingly."
    },
    {
      "given": "An existing active subscription",
      "when": "The user requests a downgrade to a lower-tier plan",
      "then": "The system accurately handles immediate or scheduled proration based on the downgrade type, and the change is reflected in the database after webhook processing."
    },
    {
      "given": "A user is contemplating a subscription change (e.g., upgrade or downgrade)",
      "when": "The system calls the 'proration-preview' endpoint",
      "then": "An accurate preview showing the exact immediate charge or refund is returned before the change is confirmed."
    },
    {
      "given": "A user with an existing subscription and payment method",
      "when": "The user updates their payment method via the Stripe Billing Portal or a SetupIntent",
      "then": "The updated payment method is reflected in the system's database after webhook processing."
    },
    {
      "given": "An active subscription requiring a recurring payment",
      "when": "A payment attempt for the subscription fails (e.g., using Stripe test card 4000 0000 0000 9995)",
      "then": "The subscription is set to 'past_due' in the database, the UI shows a 'payment required' message to the user, and appropriate notifications are triggered."
    },
    {
      "given": "A payment attempt requires Strong Customer Authentication (SCA)",
      "when": "The payment attempt triggers an SCA challenge (e.g., using a Stripe test card requiring SCA)",
      "then": "The user is redirected to Stripe to complete the SCA flow, and upon successful authentication, the payment is completed."
    },
    {
      "given": "The system receives a 'stripe-signature' verified webhook event",
      "when": "A duplicate webhook event with the same ID is received and processed",
      "then": "The duplicate event is ignored, and the system's state remains consistent, preventing unintended side effects."
    },
    {
      "given": "Any significant billing action occurs (e.g., subscription creation, update, payment)",
      "when": "The billing action is processed by the system",
      "then": "An entry is created in the 'BillingAudit' table, logging the details of the action."
    },
    {
      "given": "A subscription event triggers an invoice (e.g., initial charge, renewal, proration)",
      "when": "Stripe generates an invoice",
      "then": "The invoice is created in the system's database, and its 'invoice.pdf' or hosted invoice URL is stored and available for download by the user."
    },
    {
      "given": "A user requests export of their billing data",
      "when": "The system processes the data export request",
      "then": "The user's billing data is exported according to GDPR policies."
    },
    {
      "given": "A user requests deletion of their billing data",
      "when": "The system processes the data deletion request",
      "then": "The user's billing data is deleted according to GDPR policies, retaining only minimal, non-PCI sensitive historical records if required for compliance."
    },
    {
      "given": "Webhook processing is active and monitoring is in place",
      "when": "The webhook processing failure rate exceeds a defined threshold 'X'",
      "then": "An alert is triggered for 'webhook processing failure rate > X'."
    },
    {
      "given": "Payment processing is active and monitoring is in place",
      "when": "The payment failure rate spikes above a defined threshold 'X'",
      "then": "An alert is triggered for 'payment failure rate spike > X'."
    },
    {
      "given": "Stripe balance and internal database records are continuously reconciled",
      "when": "The reconciliation drift between Stripe balance and the internal database exceeds a defined threshold",
      "then": "An alert is triggered for 'reconciliation drift (Stripe balance vs DB) > threshold'."
    },
    {
      "given": "A user wants to manage their billing",
      "when": "The system uses Stripe Checkout and Billing Portal for all payment operations",
      "then": "The system avoids handling PCI-sensitive card data directly, instead relying on Stripe's secure infrastructure."
    },
    {
      "given": "A webhook endpoint is exposed to receive Stripe events",
      "when": "The webhook endpoint receives an event",
      "then": "The endpoint verifies the 'stripe-signature' and is protected via network rules to ensure authenticity and security."
    },
    {
      "given": "The system needs to store payment method identifiers",
      "when": "A payment method is associated with a user",
      "then": "Only the Stripe Payment Method IDs are stored, minimizing PCI-sensitive information on our servers."
    },
    {
      "given": "An authenticated user with an existing Stripe customer ID wants to subscribe to a new plan",
      "when": "The user requests to create a checkout session specifying a plan, interval, and quantity of seats",
      "then": "A Stripe Checkout session is created using the existing Stripe customer ID, and the system returns the session URL"
    },
    {
      "given": "An authenticated user without an existing Stripe customer ID wants to subscribe to a new plan",
      "when": "The user requests to create a checkout session specifying a plan, interval, and quantity of seats",
      "then": "A new Stripe customer ID is created for the user, a Stripe Checkout session is created using this new ID, and the system returns the session URL"
    },
    {
      "given": "A Stripe 'checkout.session.completed' webhook event is received with a valid signature",
      "when": "The system processes the webhook and finds no existing record for the Stripe event ID (idempotency check passes)",
      "then": "A new billingEvent record is created, the BillingAccount and Subscription records are created/updated based on the session metadata, and a BillingAudit record is created"
    },
    {
      "given": "A Stripe webhook event is received with an event ID that already exists in the local billingEvent records",
      "when": "The system processes the webhook and identifies it as a duplicate during the idempotency check",
      "then": "The system acknowledges the event with a success status without performing any further data processing"
    },
    {
      "given": "An authenticated user wants to preview a plan change for an existing subscription",
      "when": "The user requests a proration preview specifying the subscription ID, new price ID, and new quantity",
      "then": "The system retrieves an upcoming invoice from Stripe showing the proration details, and returns the parsed total and line items for display"
    },
    {
      "given": "A user on the frontend initiates a checkout for a plan",
      "when": "The frontend successfully makes an API call to create a checkout session and receives the Stripe session URL",
      "then": "The user's browser is redirected to the provided Stripe checkout URL to complete the payment"
    },
    {
      "given": "The daily reconciliation job runs",
      "when": "It fetches Stripe subscriptions and compares them with local Subscription records, identifying mismatches",
      "then": "The system attempts to fix the identified mismatches, or flags them for human review, and logs any processing errors to Sentry"
    },
    {
      "given": "The daily reconciliation job runs",
      "when": "It processes new invoices and payments from Stripe",
      "then": "The 'invoicePdfUrl' for available invoices is stored locally within the system"
    },
    {
      "given": "A critical failure occurs during webhook processing or repeated webhook signature validation errors are detected",
      "when": "The system encounters such errors during runtime",
      "then": "Errors are logged to Sentry for tracking and PagerDuty alerts are created for immediate attention by the operations team"
    },
    {
      "given": "A user successfully completes a Stripe checkout session",
      "when": "The corresponding 'checkout.session.completed' webhook is processed by the system",
      "then": "The BillingAccount and Subscription records are accurately created or updated in the database, reflecting the new subscription"
    },
    {
      "given": "A user views the plan change interface in the application",
      "when": "The system retrieves a proration preview for a potential plan change",
      "then": "The UI displays the proration preview correctly, and this preview accurately matches the details provided by the Stripe upcoming invoice API"
    },
    {
      "given": "A team has an active subscription with a specific seatCount.",
      "when": "A Stripe event indicates an increase or decrease in the number of provisioned seats.",
      "then": "The Team.seatCount is updated to accurately reflect the change in seats."
    },
    {
      "given": "Multiple Stripe events for seat changes are received concurrently for the same team.",
      "when": "The system processes these simultaneous seat change events.",
      "then": "The Team.seatCount is updated correctly, reflecting the aggregate change without data inconsistencies."
    },
    {
      "given": "A user accesses their billing section.",
      "when": "The invoice listing is displayed.",
      "then": "The listing shows accurate hosted invoices, links to PDF versions, and the correct payment status for each invoice."
    },
    {
      "given": "A user has an active subscription.",
      "when": "A recurring payment for the subscription fails.",
      "then": "The subscription status is set to 'past_due', the user receives a notification, the administrator is notified, and payment retries are initiated as configured in Stripe settings."
    },
    {
      "given": "The system receives a billing webhook event.",
      "when": "The exact same billing webhook event (e.g., with a duplicate ID) is received again.",
      "then": "The system processes the event only once, ensuring no duplicate database rows are created or state changes are applied redundantly."
    },
    {
      "given": "A user's subscription plan or tier is changed.",
      "when": "The subscription change event is processed by the system.",
      "then": "The user's assigned quotas (e.g., AI credits, storage) and available feature flags are automatically updated to match the new subscription plan."
    },
    {
      "given": "An administrator wants to provide a temporary quota adjustment to a user.",
      "when": "The administrator grants a 'QuotaOverride' to a specific user.",
      "then": "The user's effective quota is adjusted temporarily, independent of their current subscription plan."
    },
    {
      "given": "A user is actively editing content in the Content Editor.",
      "when": "The user saves their changes (e.g., manually or via auto-save).",
      "then": "A new 'ContentVersion' record is created, the content blob is stored, the UI is signaled for real-time updates, and an optional auto-draft snapshot job is triggered."
    },
    {
      "given": "A Content item is in 'DRAFT' status and is complete.",
      "when": "An authorized user submits the content for approval.",
      "then": "An 'ApprovalRequest' is created, the content status transitions to 'PENDING_APPROVAL', and relevant approvers are notified via in-app message, email, or Slack."
    },
    {
      "given": "A Content item is in 'PENDING_APPROVAL' status with an outstanding 'ApprovalRequest'.",
      "when": "An authorized approver approves the 'ApprovalRequest'.",
      "then": "The content's status transitions (e.g., to 'SCHEDULED' or 'PUBLISHED'), and it is moved to the Scheduling queue for future publication."
    },
    {
      "given": "A user attempts to perform an action within the Content Management System.",
      "when": "The system evaluates the user's assigned role (MEMBER, EDITOR, APPROVER, ADMIN) against the requested action.",
      "then": "The system correctly enforces Role-Based Access Control (RBAC), allowing or denying the action based on the user's permissions."
    },
    {
      "given": "A user with the 'EDITOR' role.",
      "when": "The editor attempts to create new content or modify an existing content item's title, body, or attachments.",
      "then": "The editor is permitted to perform these actions, and new content versions are created upon saving."
    },
    {
      "given": "A user with the 'APPROVER' role.",
      "when": "The approver attempts to approve or reject a content item that is in 'PENDING_APPROVAL' status.",
      "then": "The approver is permitted to perform the approval or rejection action, and the content's status is updated accordingly."
    },
    {
      "given": "A significant action (e.g., content creation, update, approval, deletion, user role change) occurs in the CMS.",
      "when": "The action is successfully completed.",
      "then": "An immutable record of the action, including user details, timestamp, and action type, is saved to the 'audit_logs' table."
    },
    {
      "given": "A user with appropriate permissions",
      "when": "They request to create new content with a payload",
      "then": "A new Content entry is created, an initial ContentVersion (versionNum=1) is created, the content body is written to storage, and its URL (bodyUrl) is stored."
    },
    {
      "given": "An existing content item with a current version",
      "when": "A user with appropriate permissions requests to update the content with a new payload",
      "then": "A new ContentVersion is created with an incremented versionNum, the content body is saved to storage, the Content's currentVersionId is updated, and an audit log entry is saved."
    },
    {
      "given": "An existing content item with multiple versions",
      "when": "A user requests to retrieve a specific content item by its contentId",
      "then": "The system returns the content metadata, its current version, and a minimal list of historical versions."
    },
    {
      "given": "Multiple content items exist with various statuses, types, tags, and content",
      "when": "A user requests a list of content items with specified filters (status, type, tags, search) and pagination parameters",
      "then": "The system returns a paginated list of content items matching the applied filters."
    },
    {
      "given": "An existing content item",
      "when": "A user requests to delete the content item by its contentId",
      "then": "The content's status is updated to ARCHIVED (soft-delete), and an audit log entry is created."
    },
    {
      "given": "An existing content item",
      "when": "A user requests to duplicate the content item by its contentId",
      "then": "A new content item is created, its metadata is copied from the original, the content blob is copied to storage, and an initial ContentVersion (versionNum=1) is created for the new content."
    },
    {
      "given": "An existing content item with multiple historical versions",
      "when": "A user requests a list of versions for a specific content item by its contentId",
      "then": "The system returns all historical versions associated with that content item."
    },
    {
      "given": "An existing content version",
      "when": "A user requests to fetch a specific content version by its versionId",
      "then": "The system returns the details of that version, including its body content from storage."
    },
    {
      "given": "An existing content item with multiple versions and a specific historical version",
      "when": "A user requests to rollback the content to a specific historical version by its versionId",
      "then": "A new ContentVersion is created, copying the content body of the specified historical version, its versionNum is incremented, and the Content's currentVersionId is updated to point to the new version."
    },
    {
      "given": "An existing content item",
      "when": "A user submits an approval request for the content, optionally specifying an approverId and a message",
      "then": "A new Approval entry is created with status PENDING, and relevant participants are notified."
    },
    {
      "given": "An existing content item with multiple approval requests",
      "when": "A user requests to view the approval requests for a specific content item by its contentId",
      "then": "The system returns a list of all approval requests associated with that content item."
    },
    {
      "given": "A pending approval request for a content item",
      "when": "An authorized approver acts on the approval request with action APPROVE and an optional message",
      "then": "The Approval status is updated to APPROVED, and the Content's status is updated to SCHEDULED or remains to be handled by the Scheduler."
    },
    {
      "given": "A pending approval request for a content item",
      "when": "An authorized approver acts on the approval request with action REJECTED and an optional message",
      "then": "The Approval status is updated to REJECTED."
    },
    {
      "given": "A pending approval request for a content item",
      "when": "An authorized approver acts on the approval request with action REQUEST_CHANGES and an optional message",
      "then": "The Approval status is updated to REQUEST_CHANGES."
    },
    {
      "given": "An existing content item and an authenticated user",
      "when": "The user creates a comment on the content, optionally specifying a parentId for threading",
      "then": "A new Comment entry is created, an audit log is stored, and relevant participants are notified."
    },
    {
      "given": "A list of content IDs",
      "when": "A user initiates a bulk 'delete' action on these content IDs",
      "then": "A background job is enqueued to soft-delete (archive) each specified content item."
    },
    {
      "given": "A list of content IDs",
      "when": "A user initiates a bulk 'duplicate' action on these content IDs",
      "then": "A background job is enqueued to duplicate each specified content item, creating new content and version entries."
    },
    {
      "given": "A list of content IDs and new tag information",
      "when": "A user initiates a bulk 'change tags' action on these content IDs",
      "then": "A background job is enqueued to update the tags for each specified content item."
    },
    {
      "given": "A list of content IDs and a new status",
      "when": "A user initiates a bulk 'change status' action on these content IDs",
      "then": "A background job is enqueued to update the status for each specified content item."
    },
    {
      "given": "A list of content IDs and a desired export format (CSV/PDF/ZIP)",
      "when": "A user requests to generate an export for the specified content",
      "then": "An export job is enqueued, and a signed download URL is returned to the user when the export file is ready."
    },
    {
      "given": "A user is editing content in the editor",
      "when": "The user clicks 'Save'",
      "then": "The frontend posts content to 'content.update'; The backend stores the content blob in Supabase storage; The backend creates a ContentVersion record; The backend updates Content.currentVersionId and updatedAt; The backend writes an AuditLog entry; The backend emits a realtime 'content.updated' event to the relevant websocket channel (workspace:{id}); The frontend receives the update; The frontend optimistically updates the UI to show saved state and the new version number"
    },
    {
      "given": "A user is editing content in the editor",
      "when": "The user makes changes, and 1.5 seconds elapse without further input",
      "then": "A patch is sent to 'content.update'; A new version snapshot is created (or partial snapshot) flagged as 'isAutoDraft=true'"
    },
    {
      "given": "Multiple auto-save snapshots exist for content (flagged as 'isAutoDraft=true')",
      "when": "The system periodically condenses auto-save snapshots",
      "then": "Only the last N auto-saves and last M manual versions are kept to mitigate version explosion"
    },
    {
      "given": "An editor is viewing content",
      "when": "The editor clicks 'Submit for approval'",
      "then": "The frontend calls 'approval.submit'; The backend creates an Approval row with status PENDING; The backend updates Content.status to PENDING_APPROVAL; The backend writes an AuditLog entry; An in-app notification is created; An email/Slack notification is sent via a background worker; An approver receives the notification and can open the content"
    },
    {
      "given": "An approver is reviewing content pending approval",
      "when": "The approver performs 'approval.act(approve)'",
      "then": "The backend updates the Approval row; The backend updates the AuditLog; The Content.status is set to SCHEDULED (or PUBLISHED if publishing immediately); A SchedulingJob is added to the queue"
    },
    {
      "given": "An approver is reviewing content pending approval",
      "when": "The approver performs 'approval.act(request_changes)'",
      "then": "The backend updates the Approval row; The backend updates the AuditLog; The Content.status is set to DRAFT; A comment is left for the editor"
    },
    {
      "given": "A user is viewing the version history of content",
      "when": "The user selects a previous version and clicks 'Restore' (or 'Rollback')",
      "then": "The frontend calls 'version.rollback'; The backend reads the selected version's bodyUrl; The backend copies the content blob to a new storage path as the next version number (ensuring immutability); The backend creates a new ContentVersion; The backend updates Content.currentVersionId; The backend updates the audit log; The editor UI shows the restored content"
    },
    {
      "given": "A user is on the Content Library Page with multiple content items selected",
      "when": "The user clicks 'Export' from the bulk action toolbar",
      "then": "The frontend calls 'export.generate'; The backend enqueues a background job to fetch content blobs; The background job collates the content into ZIP/PDF/CSV format; The background job uploads the collated file to storage; On success, the background job produces a signed URL; The worker stores the job status; The frontend polls or receives a realtime update when the export is ready"
    },
    {
      "given": "A user is on the Content Library Page",
      "when": "The user interacts with search, global filter chips (status, type, tags, author), or Workspace/Folder filters",
      "then": "The list/grid of content cards is updated to reflect the applied filters"
    },
    {
      "given": "A user is on the Content Library Page and has selected multiple content cards",
      "when": "The bulk action toolbar appears, and the user selects an action (e.g., Delete, Duplicate, Export, Change tags, Move to workspace, Submit for approval)",
      "then": "The corresponding bulk action is initiated for the selected content items"
    },
    {
      "given": "A user is on the Content Library Page",
      "when": "The user hovers over a content card",
      "then": "Hover actions (Edit, Quick Preview, Submit for approval, More -> Duplicate, Archive, Export) are displayed"
    },
    {
      "given": "A user is on the Content Library Page and hovers over a content card",
      "when": "The user clicks 'Edit'",
      "then": "The user is navigated to the Content Editor for that content"
    },
    {
      "given": "A user is in the Content Editor",
      "when": "The user views the right-side panel",
      "then": "They can see and manage metadata such as tags, visibility, scheduledAt, assignee, and approvals"
    },
    {
      "given": "A user is in the Content Editor",
      "when": "The user interacts with the version indicator + dropdown in the top bar",
      "then": "The Version History Modal is opened, displaying a list of versions with versionNum, author, createdAt, short diff, and actions (Preview, Restore, Compare)"
    },
    {
      "given": "A user is in the Version History Modal",
      "when": "The user selects two versions and clicks 'Compare'",
      "then": "A diff view highlights changes using a text-diff library"
    },
    {
      "given": "A user is in the Content Editor or has opened the Approvals Drawer",
      "when": "The user views the Approvals Drawer",
      "then": "Current pending approvals, approver comments, and a 'request changes' button are displayed"
    },
    {
      "given": "A user is viewing pending approvals in the Approvals Drawer",
      "when": "The user clicks 'Approve'",
      "then": "The system allows an optional message and optionally auto-scheduling for publishing"
    },
    {
      "given": "A user is in the Content Editor",
      "when": "The user selects text and adds an inline comment",
      "then": "A comment anchor marker appears, and clicking it opens the comment thread in the side panel"
    },
    {
      "given": "A user is viewing a comment thread in the side panel",
      "when": "The user interacts with the resolve/unresolve action",
      "then": "The comment thread's status is updated accordingly"
    },
    {
      "given": "A user is logged in",
      "when": "An event occurs (e.g., approval request, publish success/error, export ready)",
      "then": "A notification appears in the Notifications Panel"
    },
    {
      "given": "A user is editing content",
      "when": "The user saves the content",
      "then": "The UI displays \"Saving...\" and the version count is optimistically updated"
    },
    {
      "given": "A user saves content",
      "when": "A conflict response is received from the server during an optimistic save",
      "then": "The system handles the conflict response appropriately (e.g., reverts optimistic update, shows error)"
    },
    {
      "given": "Two users concurrently edit the same content, and conflict detection is enabled via 'updatedAt' or version token",
      "when": "A user attempts to save content that has been modified by another user",
      "then": "The system applies a last-write-wins policy and notifies the user of the concurrent modification"
    },
    {
      "given": "A user performs a heavy operation, such as exporting many items",
      "when": "The user triggers a bulk action",
      "then": "The system starts the operation as a background job and shows progress in the notification center"
    },
    {
      "given": "A user with the 'creator' role",
      "when": "The creator attempts to create or update their own content",
      "then": "The tRPC middleware allows the action, enforcing RBAC"
    },
    {
      "given": "A user with the 'editor' role within a specific workspace",
      "when": "The editor attempts to edit content within that workspace",
      "then": "The tRPC middleware allows the action, enforcing RBAC"
    },
    {
      "given": "A user with the 'approver' role",
      "when": "The approver attempts to act on an approval",
      "then": "The tRPC middleware allows the action, enforcing RBAC"
    },
    {
      "given": "A user with the 'admin' role",
      "when": "The admin attempts to perform any action",
      "then": "The tRPC middleware allows the action, enforcing RBAC"
    },
    {
      "given": "A user requests content items",
      "when": "The system retrieves content items for the user",
      "then": "Only items belonging to workspaces the user is a member of are returned"
    },
    {
      "given": "A user needs to access a content blob (e.g., an attachment)",
      "when": "The system provides a URL for the content blob",
      "then": "The URL is a signed URL or temporary token that expires after a short TTL"
    },
    {
      "given": "A user performs an action such as create, update, approve, publish, or export",
      "when": "An action subject to auditing is successfully completed",
      "then": "An immutable record of the action is created in the Audit Logs"
    },
    {
      "given": "A publish job is initiated for a content item with a 'currentVersion'",
      "when": "The background worker fetches the content body via a signed URL, successfully calls the LinkedIn API to publish, and receives a success response",
      "then": "The Content.status is set to PUBLISHED, publishedAt is recorded, and an AuditLog entry is created"
    },
    {
      "given": "A publish job is initiated for a content item",
      "when": "The LinkedIn API call fails, triggering retry logic with exponential backoff, and all retries eventually fail",
      "then": "The Content.status is set to ERROR, and a notification is sent"
    },
    {
      "given": "An approver has requested changes to a content item",
      "when": "An editor views the content item",
      "then": "The editor sees highlights of the requested changes and a pinned comment"
    },
    {
      "given": "A content item has been scheduled for publication",
      "when": "The content item's version is updated after it has been scheduled",
      "then": "The system locks the scheduled content, and a new scheduling action is required for the updated version, with a notification to the user"
    },
    {
      "given": "A user creates multiple manual versions of content",
      "when": "The number of manual versions exceeds the retention policy limit (e.g., 100 versions)",
      "then": "The system retains only the most recent manual versions according to the policy (e.g., the last 100)"
    },
    {
      "given": "The system generates auto-saves for content",
      "when": "Auto-saves are created and aged over time",
      "then": "The system implements a soft retention policy for these auto-saves, allowing their eventual cleanup after a defined retention window (e.g., 30 days)"
    },
    {
      "given": "A user creates a new version of content with optional attachments.",
      "when": "The system processes the version creation request.",
      "then": "The content's currentVersionId is updated, an audit log entry for 'VERSION_CREATE' is recorded, a 'content.version_created' real-time event is published, and attachments are serialized for storage."
    },
    {
      "given": "New or updated content is saved.",
      "when": "The AI auto-tagging service processes the content.",
      "then": "Relevant tags are suggested and applied to the content."
    },
    {
      "given": "Content has remained inactive for a pre-defined period (e.g., X days).",
      "when": "The content lifecycle rules are executed.",
      "then": "The content is automatically archived."
    },
    {
      "given": "Multiple users have made conflicting edits to the same content.",
      "when": "A user attempts to save or merge their changes.",
      "then": "A 3-way diff UI is presented to help resolve the concurrent edits."
    },
    {
      "given": "A user wants to explore alternative versions of content without affecting the main draft.",
      "when": "The user creates a new branch for the content.",
      "then": "The user can develop and manage multiple parallel drafts independently."
    },
    {
      "given": "An existing content template is modified.",
      "when": "The template is saved.",
      "then": "A new version of the template is created, preserving its history."
    },
    {
      "given": "A user is creating new content in a specific workspace.",
      "when": "The user searches for available templates.",
      "then": "Templates from other workspaces are available for reuse."
    },
    {
      "given": "A user initiates an export or publishing operation for content.",
      "when": "The request is submitted to the system.",
      "then": "The operation is added to a job queue for asynchronous processing."
    },
    {
      "given": "A user is viewing content in the Editor UI.",
      "when": "The user accesses the version history feature.",
      "then": "A version modal displays the content's complete revision history."
    },
    {
      "given": "A user attempts to interact with a tRPC endpoint.",
      "when": "The RBAC middleware intercepts the request.",
      "then": "The user's permissions are validated, and access is granted or denied accordingly."
    },
    {
      "given": "Content contains attachments or external media stored in a secure location.",
      "when": "A user requests access to an attachment.",
      "then": "The system provides a signed URL with a limited Time-to-Live (TTL) for temporary access."
    },
    {
      "given": "A scheduled content item is edited.",
      "when": "The system applies the policy for edits on scheduled items (e.g., auto-requeue).",
      "then": "The scheduled item is automatically re-queued for approval or re-scheduling."
    },
    {
      "given": "a new user",
      "when": "they attempt to sign up using their email and password",
      "then": "they should be able to create an account and log in successfully."
    },
    {
      "given": "an existing user",
      "when": "they attempt to log in using an OAuth provider (e.g., LinkedIn)",
      "then": "they should be authenticated and granted access to their account."
    },
    {
      "given": "a user with an 'Admin' role",
      "when": "they attempt to access administrative settings or functions",
      "then": "they should be granted access to those features."
    },
    {
      "given": "a user with a 'Standard' role",
      "when": "they attempt to access administrative settings or functions",
      "then": "they should be denied access and informed of insufficient permissions."
    },
    {
      "given": "a user has Multi-Factor Authentication (MFA) enabled on their account",
      "when": "they successfully enter their primary login credentials",
      "then": "they should be prompted to complete a second factor of authentication before gaining full access."
    },
    {
      "given": "an enterprise user with Enterprise SSO (SAML/OAuth2) configured",
      "when": "they attempt to log in via their organization's SSO portal",
      "then": "they should be seamlessly authenticated and granted access to Scribl without entering separate credentials."
    },
    {
      "given": "a logged-in user",
      "when": "they update their profile information (e.g., name, avatar, contact details)",
      "then": "their profile details should be saved and reflected across the application."
    },
    {
      "given": "an admin user within an organization/team",
      "when": "they invite a new member to their team via email",
      "then": "the new member should receive an invitation and be able to join the team with a default role."
    },
    {
      "given": "a user who belongs to multiple workspaces",
      "when": "they select a different workspace from the application interface",
      "then": "the application content and context should switch to display data relevant to the chosen workspace."
    },
    {
      "given": "an admin user within an organization",
      "when": "they assign a different role to an existing team member",
      "then": "the team member's access privileges should be updated according to the new role."
    },
    {
      "given": "a user on a free or trial plan",
      "when": "they choose to subscribe to a paid plan",
      "then": "they should be directed to a secure billing portal (Stripe) to complete their subscription and payment."
    },
    {
      "given": "a user with an active subscription on a specific plan (e.g., Basic)",
      "when": "they decide to upgrade or downgrade to another plan (e.g., Premium or Free)",
      "then": "their subscription should be updated accordingly, with prorated charges or credits applied if applicable."
    },
    {
      "given": "a user with an active subscription",
      "when": "a billing period ends or a payment is successfully processed",
      "then": "they should receive an invoice and/or receipt for the transaction."
    },
    {
      "given": "a user in the AI content creation module",
      "when": "they provide a prompt or select a template for content generation",
      "then": "the AI should generate relevant content based on their input."
    },
    {
      "given": "multiple users collaborating on the same piece of content",
      "when": "one user makes edits or adds comments",
      "then": "other users should see these changes reflected in real-time or near real-time, and version history should be maintained."
    },
    {
      "given": "a user has created content ready for publication",
      "when": "they schedule the content to be published to a connected platform at a future date and time",
      "then": "the content should be automatically published at the specified time."
    },
    {
      "given": "a user has an important event or update (e.g., content approval, billing alert)",
      "when": "the event occurs",
      "then": "they should receive a notification within the application, via email, and optionally through integrated communication channels like Slack/Teams."
    },
    {
      "given": "a logged-in user",
      "when": "they access their personal analytics dashboard",
      "then": "they should see performance metrics and insights related to their content and activities."
    },
    {
      "given": "an admin user of an organization",
      "when": "they access the organization's admin dashboard",
      "then": "they should see aggregated usage, billing, and compliance data for their team."
    },
    {
      "given": "a user viewing a report or analytics data",
      "when": "they select an option to export the data (e.g., CSV, PDF)",
      "then": "the data should be downloaded in the chosen format."
    },
    {
      "given": "a user looking for assistance",
      "when": "they search the in-app knowledge base or FAQ section",
      "then": "relevant articles and solutions should be displayed."
    },
    {
      "given": "a new user on their first login",
      "when": "they navigate through the core features of the application",
      "then": "they should be guided by an interactive onboarding process highlighting key functionalities."
    },
    {
      "given": "a user encounters an issue or has a question",
      "when": "they submit a support ticket through the application's help interface",
      "then": "the ticket should be recorded and routed to the appropriate support system for resolution."
    },
    {
      "given": "sensitive user data (e.g., personal information, content)",
      "when": "it is stored on Scribl servers or transmitted between systems",
      "then": "it should be encrypted both at rest and in transit to protect against unauthorized access."
    },
    {
      "given": "a critical action is performed by a user (e.g., role change, data deletion)",
      "when": "the action occurs",
      "then": "an immutable audit log entry should be created, detailing the action, user, timestamp, and relevant context."
    },
    {
      "given": "an internal Scribl admin accessing the back-office module",
      "when": "they navigate to the customer management section",
      "then": "they should be able to view and manage all customer accounts, including their subscription status and details."
    },
    {
      "given": "an internal Scribl admin viewing a specific customer's account in the back-office module",
      "when": "they access the usage details",
      "then": "they should see detailed usage metrics such as AI tokens consumed and API calls made by the user/organization."
    },
    {
      "given": "an internal Scribl admin responding to a customer's billing inquiry",
      "when": "they use the back-office module to process a refund or cancel a subscription",
      "then": "the billing system should reflect the change, and the customer's account should be updated accordingly."
    },
    {
      "given": "an internal Scribl admin managing feature rollouts",
      "when": "they toggle a feature flag for a specific customer or user segment in the back-office module",
      "then": "the availability of that feature for the targeted customer(s) should change instantly."
    },
    {
      "given": "an internal Scribl admin assisting a user",
      "when": "they use the back-office module to manually extend a user's trial period or reset account settings",
      "then": "the user's account should be updated with the specified override."
    },
    {
      "given": "an enterprise customer with a custom domain configured",
      "when": "their users access Scribl via that custom domain",
      "then": "Scribl should be accessible through the custom domain and display the enterprise's custom branding."
    },
    {
      "given": "an enterprise user or integration partner with appropriate API credentials",
      "when": "they send an authenticated request to the Scribl public API",
      "then": "the API should respond with the requested data or perform the specified action according to the API documentation."
    },
    {
      "given": "an enterprise user has configured a webhook endpoint for their account",
      "when": "a specified event occurs within Scribl (e.g., content status change, new comment)",
      "then": "a structured data payload detailing the event should be automatically sent to the configured webhook URL."
    },
    {
      "given": "a user on a plan with a defined quota for AI tokens",
      "when": "they attempt to generate AI content that would exceed their remaining token limit",
      "then": "the system should prevent the action, inform the user they have reached their limit, and offer options to increase their quota."
    },
    {
      "given": "a user who is approaching their plan limits (e.g., 80% of AI tokens used)",
      "when": "they are active in the application",
      "then": "they should receive proactive notifications suggesting an upgrade or options to purchase additional usage."
    },
    {
      "given": "a new user signing up for Scribl",
      "when": "they complete the registration process",
      "then": "they should be prompted to review and explicitly accept the latest Terms of Service and Privacy Policy."
    },
    {
      "given": "an enterprise customer requiring data residency in a specific region (e.g., EU)",
      "when": "they provision their Scribl account",
      "then": "their data should be stored and processed exclusively within data centers located in the specified region."
    },
    {
      "given": "a user interacting with AI-generated content or a new feature",
      "when": "they are presented with an in-app feedback mechanism (e.g., thumbs up/down, survey popup)",
      "then": "their feedback should be captured and recorded for product improvement and analysis."
    },
    {
      "given": "an enterprise user attempts to log in",
      "when": "SSO is configured and active for their organization",
      "then": "they should be authenticated seamlessly via their enterprise identity provider."
    },
    {
      "given": "an enterprise needs to control data storage location",
      "when": "data residency policies are applied for a specific region",
      "then": "all associated content and user data should be stored within that region."
    },
    {
      "given": "an admin needs to understand AI/token usage",
      "when": "they access the usage metering dashboard",
      "then": "they should see detailed AI/token costs and usage enforcement metrics."
    },
    {
      "given": "a developer wants to integrate with Scribl",
      "when": "they access the public API documentation and generate an API key",
      "then": "they should be able to programmatically interact with Scribl resources and receive webhook notifications."
    },
    {
      "given": "a user encounters an issue or has a suggestion",
      "when": "they submit feedback via the integrated feedback module",
      "then": "their feedback should be captured for continuous improvement analysis."
    },
    {
      "given": "a user navigates to the login page",
      "when": "they choose 'Login with LinkedIn'",
      "then": "they should be authenticated successfully and redirected to the application."
    },
    {
      "given": "a new user has authenticated for the first time",
      "when": "they complete the guided onboarding by defining goals, brand voice, frequency, and niches",
      "then": "their profile should be configured with these preferences, ready for content creation."
    },
    {
      "given": "a user needs to select a subscription plan",
      "when": "they choose a plan (e.g., Pro) and provide payment details via Stripe integration",
      "then": "their subscription should be activated and the correct number of seats allocated."
    },
    {
      "given": "a user provides a prompt to the AI assistant",
      "when": "they request content variations for a social media post",
      "then": "the system should generate multiple unique content drafts based on the prompt."
    },
    {
      "given": "a user is creating new content",
      "when": "they use the chat and canvas editor to combine text and visuals",
      "then": "they should be able to preview the content in real-time before saving or publishing."
    },
    {
      "given": "a user wants to create new content efficiently",
      "when": "they select an industry-specific template for a post or article",
      "then": "a pre-formatted content draft should be loaded, ready for customization."
    },
    {
      "given": "a user is building a multi-slide carousel",
      "when": "they add multiple slides, incorporate text and images, and review compliance checks",
      "then": "they should be able to preview the entire carousel accurately before finalizing."
    },
    {
      "given": "a user is browsing the Template Marketplace",
      "when": "they search for community or premium templates relevant to their industry",
      "then": "they should be able to select, share, and potentially monetize their own templates."
    },
    {
      "given": "a user has created multiple content pieces",
      "when": "they access the centralized content library",
      "then": "they should see all their content organized and easily searchable."
    },
    {
      "given": "a content piece requires team review",
      "when": "an editor submits the content for approval",
      "then": "an assigned approver should be able to review, approve, or reject the content within a defined workflow."
    },
    {
      "given": "a content piece has undergone several edits",
      "when": "a user decides to revert to an older version",
      "then": "they should be able to access previous versions and roll back to a desired state."
    },
    {
      "given": "a user wants to schedule a post for future publication",
      "when": "they drag and drop content onto the calendar, set recurring options, and specify a timezone",
      "then": "the post should be scheduled for the exact date and time, respecting timezone differences."
    },
    {
      "given": "content is scheduled for automated publishing",
      "when": "the scheduled time arrives and the publishing platform is temporarily unavailable",
      "then": "the system should attempt to publish the content, implement retry logic, and send an alert if it consistently fails."
    },
    {
      "given": "content has been submitted for publishing",
      "when": "the publishing process completes or fails",
      "then": "the user should receive a notification confirming the success or failure of the publication."
    },
    {
      "given": "a user is viewing their engagement feed",
      "when": "they see prioritized posts from their network",
      "then": "they should be able to perform one-click actions such as liking, commenting, or sharing directly from the feed."
    },
    {
      "given": "a user is composing a comment or reply to a post",
      "when": "the AI assistant provides context-aware comment/reply suggestions",
      "then": "the user should be able to select a suggestion to quickly generate a thoughtful response."
    },
    {
      "given": "a user wants to assess their network's activity",
      "when": "they view their networking metrics",
      "then": "they should see detailed tracking of connection engagement, including likes, comments, and shares received."
    },
    {
      "given": "a user is seeking new content ideas",
      "when": "they access the trending topics module powered by AI and LinkedIn signals",
      "then": "they should see a curated list of relevant and popular subjects to inform their content strategy."
    },
    {
      "given": "a user wants to identify market opportunities",
      "when": "they request a competitor and gap analysis report",
      "then": "the system should provide insights into competitor activity and highlight content gaps to explore."
    },
    {
      "given": "a user has drafted new content",
      "when": "they request a predicted performance forecast from the AI",
      "then": "the AI should estimate the content's potential reach, engagement, and other metrics before publication."
    },
    {
      "given": "a user accesses the analytics dashboard",
      "when": "they view metrics for impressions, clicks, engagement, and follower growth over time",
      "then": "they should see a clear and comprehensive overview of their content's performance."
    },
    {
      "given": "a user is reviewing content performance data",
      "when": "they access the AI insights module",
      "then": "the system should suggest optimal posting times and highlight top-performing content based on data analysis."
    },
    {
      "given": "a user needs to share or store analytics data externally",
      "when": "they select an export option (CSV, PDF, or JSON) from the dashboard",
      "then": "the analytics data should be downloaded in the chosen format, ready for external use."
    },
    {
      "given": "an admin is managing a team within Scribl",
      "when": "they assign specific roles (admin, editor, approver, analyst) to different users",
      "then": "each user should have access and permissions corresponding to their assigned role."
    },
    {
      "given": "an organization operates across multiple regions or brands",
      "when": "an admin sets up multiple workspaces",
      "then": "teams can manage content and collaborate independently within their respective, segregated workspaces."
    },
    {
      "given": "an admin needs to investigate user activity or system changes",
      "when": "they access the audit and activity logs",
      "then": "they should see a detailed, immutable record of all user actions and system events."
    },
    {
      "given": "an admin is configuring user permissions for compliance needs",
      "when": "they assign granular controls, such as 'analytics-only' or 'create-only' access to a user",
      "then": "the user should only be able to perform actions explicitly permitted by their granular role."
    },
    {
      "given": "a content piece requires multi-step review before publishing",
      "when": "an editor submits the content for approval, triggering a defined approval hierarchy",
      "then": "the content should sequentially pass through all required approvers before it can be published."
    },
    {
      "given": "an organization needs to manage data lifecycle",
      "when": "retention policies are configured for content and user data",
      "then": "old content and data should be automatically archived or deleted according to the defined policy."
    },
    {
      "given": "a user is on a 'Normal' subscription plan",
      "when": "they decide to upgrade to a 'Pro' plan",
      "then": "their subscription should be updated immediately, and any prorated billing applied correctly."
    },
    {
      "given": "a user wants to review their financial information",
      "when": "they access the billing dashboard",
      "then": "they should see their subscription status, past invoices, and options to manage payment methods."
    },
    {
      "given": "a team has a monthly AI credit allocation",
      "when": "a user generates an article using the AI assistant",
      "then": "the AI credit usage should be accurately calculated based on the content type and deducted from the team's balance."
    },
    {
      "given": "a team's AI credit usage is nearing its limit",
      "when": "the usage approaches a predefined threshold",
      "then": "an alert should be triggered, and options to purchase extra packs or enable auto top-ups should be presented."
    },
    {
      "given": "an admin needs to manage team resources",
      "when": "they adjust the AI credit allocation for a specific team or user",
      "then": "that team's or user's available credits should immediately reflect the new allocation."
    },
    {
      "given": "a user has important updates (e.g., content approved, publishing failed)",
      "when": "an event triggers a notification",
      "then": "they should receive an alert via in-app notification, email, or an integrated channel like Slack/Teams."
    },
    {
      "given": "a user wants to manage their personal or brand settings",
      "when": "they access the Profile & Settings section",
      "then": "they should be able to update their brand voice, preferences, and request GDPR data export or deletion."
    },
    {
      "given": "a user is creating visual content",
      "when": "they search for images within the integrated Unsplash/Pexels stock image library",
      "then": "they should be able to select and use high-quality images with automatic attribution and caching."
    },
    {
      "given": "a user is looking for specific content or resources",
      "when": "they utilize the global search bar or apply advanced filters",
      "then": "relevant content, templates, or analytics data should be quickly displayed."
    },
    {
      "given": "a user accesses Scribl on a mobile device",
      "when": "they use the responsive PWA",
      "then": "they should be able to quickly create, approve, or publish content with an optimized mobile experience."
    },
    {
      "given": "an enterprise needs to onboard a large amount of existing data or perform bulk updates",
      "when": "an admin performs a data import or export via CSV/JSON",
      "then": "the system should successfully process the bulk data, facilitating setup or migration."
    },
    {
      "given": "a user requires assistance with Scribl",
      "when": "they access the integrated help center, guided onboarding tours, or submit a support ticket",
      "then": "they should receive timely and comprehensive support to resolve their queries."
    },
    {
      "given": "a user prefers a different language for the interface and AI content generation",
      "when": "they select a new UI language and specify it for AI content creation",
      "then": "the application interface and AI-generated content should switch to the selected language."
    },
    {
      "given": "a user wants to connect Scribl with other business tools",
      "when": "they configure integrations with platforms like Slack, CRM, Salesforce, or HubSpot",
      "then": "data and notifications should flow seamlessly between Scribl and the integrated platforms."
    },
    {
      "given": "content is being created using AI",
      "when": "the system performs uniqueness checks and AI safety/compliance checks",
      "then": "potential plagiarism, unsafe content, or non-compliant output should be flagged and remediated."
    },
    {
      "given": "a user interacts with the system, handling sensitive data",
      "when": "security measures like RBAC, audit logs, encryption, and GDPR compliance are enforced",
      "then": "their data and actions should be protected, audited, and conform to regulatory standards."
    },
    {
      "given": "an enterprise requires specific custom insights",
      "when": "they configure custom reporting options",
      "then": "they should receive tailored reports that align with their unique business intelligence needs."
    },
    {
      "given": "a user wants to publish content to various social media platforms",
      "when": "they select to publish to LinkedIn, or other platforms like X/Instagram/YouTube (when ready)",
      "then": "the content should be published correctly and optimally formatted for each chosen platform."
    },
    {
      "given": "a user has valid credentials",
      "when": "the user attempts to log in using password authentication",
      "then": "the user should be successfully authenticated and granted access"
    },
    {
      "given": "an administrator is logged in",
      "when": "the administrator creates a new user account with required profile information",
      "then": "the new user account should be successfully created and assigned an active status"
    },
    {
      "given": "an administrator defines a new role with specific permissions",
      "when": "the administrator assigns this role to a user",
      "then": "the user should inherit all permissions associated with that role"
    },
    {
      "given": "a user has an account with an external identity provider integrated via SAML/OAuth",
      "when": "the user attempts to log in to the application using Single Sign-On",
      "then": "the user should be authenticated by the external provider and automatically logged into the application"
    },
    {
      "given": "a new customer organization wishes to use the platform",
      "when": "the platform administrator performs tenant onboarding for the organization",
      "then": "the new tenant should be created with isolated configurations and data, accessible only to its users"
    },
    {
      "given": "an organization administrator is logged in",
      "when": "the administrator updates the organization's profile settings, such as contact information or domains",
      "then": "the organization's settings should be updated successfully and reflected across the organization"
    },
    {
      "given": "a user has permissions to manage teams",
      "when": "the user creates a new team and invites other members to it",
      "then": "the team should be created successfully, and invited members should receive notifications to join"
    },
    {
      "given": "a user has an active subscription to a basic plan",
      "when": "the user chooses to upgrade their subscription to a premium plan",
      "then": "the system should apply proration, update the plan, and generate an updated invoice for the user"
    },
    {
      "given": "a user is making a purchase",
      "when": "the user enters their credit card details via the payment form",
      "then": "the payment gateway should securely tokenize the card information and process the payment"
    },
    {
      "given": "a tenant consumes resources that are subject to usage metering (e.g., API calls)",
      "when": "the tenant makes API calls to the platform",
      "then": "the system should accurately meter the usage, apply rating rules, and include it in the tenant's usage report"
    },
    {
      "given": "a customer has a completed billing cycle with applicable services and usage",
      "when": "the system generates an invoice for the customer",
      "then": "the invoice should accurately calculate charges, apply relevant taxes (VAT/GST), and be available for review"
    },
    {
      "given": "a system event that triggers a notification (e.g., account activity)",
      "when": "the event occurs and the user has enabled email notifications",
      "then": "the user should receive a system-generated email notification according to their preferences"
    },
    {
      "given": "an administrator wants to create a personalized email",
      "when": "the administrator uses the WYSIWYG editor to design an email template with templating variables",
      "then": "the email template should be saved and capable of dynamic personalization when sent"
    },
    {
      "given": "a user performs an action within the application (e.g., updates a setting)",
      "when": "the user's action is completed",
      "then": "the system should record the action in an immutable audit log, including who, what, and when"
    },
    {
      "given": "the platform is subject to regulatory requirements like SOC2 or GDPR",
      "when": "an administrator requests a compliance report",
      "then": "the system should generate a report detailing compliance posture and relevant security controls"
    },
    {
      "given": "sensitive data is being stored in the database",
      "when": "the data is written to disk",
      "then": "the data should be encrypted at rest using a robust encryption scheme managed by a Key Management Service (KMS)"
    },
    {
      "given": "data is critical for business continuity",
      "when": "the system's scheduled backup process runs",
      "then": "a point-in-time backup of the data should be successfully created and stored, enabling future recovery"
    },
    {
      "given": "the application is actively running and processing requests",
      "when": "an operator views the monitoring dashboard",
      "then": "the dashboard should display real-time metrics, logs, and traces indicating the application's health and performance"
    },
    {
      "given": "an administrator wants to understand product usage trends",
      "when": "the administrator accesses the analytics module and selects a pre-built dashboard",
      "then": "the dashboard should display relevant business intelligence and key performance indicators based on product data"
    },
    {
      "given": "a user logs into the application for the first time",
      "when": "the user customizes their dashboard by adding and arranging widgets",
      "then": "the user's personalized dashboard layout should be saved and persist across sessions"
    },
    {
      "given": "a user is looking for specific information within the application",
      "when": "the user enters a search query into the global search bar and applies a faceted filter",
      "then": "the system should return relevant results across all entities, filtered by the specified criteria"
    },
    {
      "given": "a developer wants to integrate an external application with the platform's APIs",
      "when": "the developer creates a new API key in the developer portal",
      "then": "the system should generate a unique API key, enabling authenticated access to allowed API endpoints"
    },
    {
      "given": "an external system is subscribed to a platform event (e.g., 'user created')",
      "when": "a new user is created within the platform",
      "then": "the system should send a webhook notification to the external system with the relevant event data"
    },
    {
      "given": "a customer wants to synchronize user data between the platform and their CRM",
      "when": "an administrator configures a pre-built CRM connector and sets up data mapping",
      "then": "the connector should automatically synchronize user data between the two systems according to the defined rules"
    },
    {
      "given": "a business process requires multiple steps and approvals",
      "when": "an administrator designs a workflow using the visual workflow builder with conditional logic and human approval steps",
      "then": "the workflow should be saved and executable, automating the multi-step process with audit trails"
    },
    {
      "given": "a team needs to track its work items",
      "when": "a team member creates a new task, assigns it to a colleague, and sets a priority",
      "then": "the task should be created and visible to the assignee, with its status trackable through a defined workflow"
    },
    {
      "given": "a sales representative needs to review a customer's history",
      "when": "the representative accesses the customer's contact record in the CRM",
      "then": "the system should display a comprehensive interactions timeline, including all past communications and activities"
    },
    {
      "given": "a customer encounters an issue with the product",
      "when": "the customer submits a support ticket through the helpdesk portal",
      "then": "the ticket should be routed to the appropriate support team, and an SLA timer should begin tracking resolution time"
    },
    {
      "given": "a user needs immediate assistance from support",
      "when": "the user initiates a live chat session via the in-app widget",
      "then": "a support agent should be connected, and the user can engage in real-time communication"
    },
    {
      "given": "a user wants to store a new project document",
      "when": "the user uploads the document to the document management system",
      "then": "the document should be stored, versioned, and accessible based on assigned permissions"
    },
    {
      "given": "a user uploads a large media file to the platform",
      "when": "another user attempts to download or view the file",
      "then": "the file should be delivered efficiently via the Content Delivery Network (CDN) with minimal latency"
    },
    {
      "given": "an administrator needs to bulk update user data",
      "when": "the administrator uses the data import tool to upload a CSV file with updated user information",
      "then": "the system should validate the data, map it to existing fields, and successfully import/update the user records"
    },
    {
      "given": "a new feature is developed but not ready for all users",
      "when": "an administrator enables a feature flag with targeting rules for a specific group of beta testers",
      "then": "only the targeted beta testers should see and be able to use the new feature"
    },
    {
      "given": "a product manager wants to test two different UI variants for a new onboarding flow",
      "when": "the product manager configures an A/B test, defining variants and assigning a percentage of users to each",
      "then": "the system should randomly assign users to the specified variants and collect metrics for comparison"
    },
    {
      "given": "a user prefers to use the application in a language other than the default",
      "when": "the user changes their language preference in their settings",
      "then": "the application's user interface, dates, and number formats should immediately switch to the selected locale"
    },
    {
      "given": "a user wants to control their email notifications",
      "when": "the user navigates to their personal notification settings and disables certain email types",
      "then": "the system should save the user's preferences, and they should no longer receive disabled email notifications"
    },
    {
      "given": "users are collaborating on a document or task",
      "when": "a user adds an inline comment and @mentions a colleague",
      "then": "the comment should appear in the discussion thread, and the mentioned colleague should receive a notification"
    },
    {
      "given": "a user needs to schedule a meeting with a colleague",
      "when": "the user creates a new event in the shared calendar and invites the colleague",
      "then": "the event should appear on both users' calendars, and the colleague should receive an invitation"
    },
    {
      "given": "a product has multiple SKUs with defined stock levels",
      "when": "a customer places an order for a product",
      "then": "the system should accurately decrement the stock level for the purchased SKU and trigger reorder rules if necessary"
    },
    {
      "given": "a sales team needs to provide a price estimate to a prospect",
      "when": "a salesperson generates a quote for specific products and services",
      "then": "the system should create a detailed quote with line items, pricing, and terms, ready for customer review"
    },
    {
      "given": "an employee needs to purchase new office supplies",
      "when": "the employee creates a new purchase order request through the system",
      "then": "the purchase order should be routed for approval according to defined policies and recorded in the system"
    },
    {
      "given": "an HR administrator needs to manage employee information",
      "when": "the administrator updates an employee's profile with new contact details and role information",
      "then": "the employee's record should be updated successfully, and the changes should reflect in the organizational directory"
    },
    {
      "given": "an employee has completed work for a project over a period",
      "when": "the employee submits their timesheet with logged hours for tasks",
      "then": "the timesheet should be submitted for approval, and the recorded hours should be available for reporting or billing"
    },
    {
      "given": "an HR department needs to process monthly salaries",
      "when": "the payroll system calculates employee compensation based on defined salary rules and attendance",
      "then": "the system should generate accurate payslips for each employee, factoring in taxes and deductions"
    },
    {
      "given": "a user is consuming an API with an imposed rate limit of 100 requests per minute",
      "when": "the user sends 101 API requests within one minute",
      "then": "the 101st request should be throttled or rejected, and the user should receive a rate limit error"
    },
    {
      "given": "a service has an defined Service Level Agreement (SLA) for uptime",
      "when": "the service experiences a period of downtime exceeding the SLA threshold",
      "then": "the monitoring system should detect the breach, trigger an alert, and record the event for compliance reporting"
    },
    {
      "given": "a new user registers for the service",
      "when": "the user reviews and accepts the Privacy Policy and Terms of Service during onboarding",
      "then": "the system should record the user's consent, allowing data processing according to the agreed terms"
    },
    {
      "given": "an organization needs to adhere to internal security policies",
      "when": "an administrator accesses the GRC module to view the policy library",
      "then": "the system should display a comprehensive list of organizational policies and their current status"
    },
    {
      "given": "the application experiences a sudden increase in user traffic",
      "when": "the autoscaling policies detect the increased load",
      "then": "the system should automatically provision additional resources (e.g., servers, database capacity) to handle the demand"
    },
    {
      "given": "a developer wants to quickly integrate a new feature using the platform's API",
      "when": "the developer uses the official SDK provided in their preferred programming language",
      "then": "the SDK should streamline API calls and handle authentication, simplifying the integration process"
    },
    {
      "given": "a user wants to extend the platform's functionality with a third-party tool",
      "when": "the user browses the marketplace and installs an approved extension",
      "then": "the extension should be successfully installed with appropriate permissions and integrated into the platform"
    },
    {
      "given": "a security auditor needs to review user activity",
      "when": "the auditor generates an 'Access & Activity Report' for a specific user or time period",
      "then": "the report should provide a detailed, exportable log of user logins, actions, and access changes for compliance"
    },
    {
      "given": "the platform wants to gauge customer satisfaction",
      "when": "a user is presented with an NPS survey after a key interaction",
      "then": "the user should be able to provide feedback, and their response should be recorded for analytics and follow-up"
    },
    {
      "given": "a new user signs up for the service",
      "when": "the user starts their first session",
      "then": "the system should present an interactive guided tour, highlighting key features and prompting initial setup steps"
    },
    {
      "given": "a user interacts with various features of the application",
      "when": "the user clicks on a specific button or navigates to a new section",
      "then": "the system should track this event, contributing to feature usage analytics and product telemetry"
    },
    {
      "given": "a tenant decides to offboard from the platform",
      "when": "the tenant administrator requests a full data export of all their organizational data",
      "then": "the system should generate an encrypted export job containing all selectable datasets in a standard format, audited for compliance"
    },
    {
      "given": "a marketing team launches a promotional campaign",
      "when": "a customer applies a valid coupon code during checkout for a subscription",
      "then": "the pricing engine should apply the discount as per the coupon rules, adjusting the total billable amount"
    },
    {
      "given": "a global incident impacts multiple tenants on the platform",
      "when": "a Superadmin accesses the platform administration console",
      "then": "the Superadmin should view a global health status dashboard, allowing them to manage the incident and tenant overrides"
    },
    {
      "given": "a critical service outage occurs",
      "when": "a system operator updates the status page with incident details and impact",
      "then": "the public status page should reflect the current incident status, and subscribers should receive automated updates"
    },
    {
      "given": "a user submits a request that requires manager approval",
      "when": "the request enters the approval workflow",
      "then": "the system should automatically route the request to the designated approver, notifying them of pending action and tracking the approval status"
    }
  ]
}