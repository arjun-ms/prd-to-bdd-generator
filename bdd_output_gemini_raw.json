{
  "features": [
    {
      "given": "A new user accesses the Scribl platform for the first time.",
      "when": "The user attempts to sign up or log in.",
      "then": "The user should be prompted to authenticate via LinkedIn OAuth.",
      "and": "A Scribl user record should be created using the retrieved LinkedIn profile data."
    },
    {
      "given": "A new individual user has successfully authenticated via LinkedIn.",
      "when": "The user starts the onboarding flow.",
      "then": "The user should be guided through a multi-step process.",
      "and": "Progress through the onboarding steps should be auto-saved to prevent drop-offs."
    },
    {
      "given": "A team admin user is setting up their team's Scribl account.",
      "when": "The admin selects the number of seats and a subscription plan.",
      "then": "A real-time calculator should display the pricing and features associated with the selections.",
      "and": "Upon successful payment, access to the platform should be provisioned for the selected number of seats."
    },
    {
      "given": "A user is within the Scribl content creation interface, accessing the AI Assistant.",
      "when": "The user inputs an idea or prompt into the conversational interface.",
      "then": "The AI should generate multiple variations of posts, articles, or captions.",
      "and": "The user should be able to refine the drafts through iterative feedback provided to the AI."
    },
    {
      "given": "A user has generated content drafts using the AI Assistant.",
      "when": "The user interacts with the Chat Canvas.",
      "then": "The Chat Canvas should display a chat panel for continued AI interaction.",
      "and": "The Chat Canvas should provide a visual editor for modifying the content."
    },
    {
      "given": "A user is creating a new post.",
      "when": "The user drags and drops a text block, an image, and applies bold formatting to a section of text.",
      "then": "The post editor displays the elements in the desired arrangement and the text is formatted correctly."
    },
    {
      "given": "A user has composed content for a new post.",
      "when": "The user selects the \"Preview\" option.",
      "then": "The system displays the post exactly as it would appear on LinkedIn."
    },
    {
      "given": "A user wants to create a new post for a product launch.",
      "when": "The user selects a pre-designed template categorized under \"Product Launch\" and \"Tech Industry\".",
      "then": "The post editor populates with the structure of the selected template, ready for content input."
    },
    {
      "given": "A user has created a custom post structure.",
      "when": "The user saves this structure as a new custom template.",
      "then": "The custom template becomes available for all team members to select and use."
    },
    {
      "given": "A user wants to create a multi-slide LinkedIn carousel.",
      "when": "The user utilizes a \"Storytelling\" template from the Carousel Creator.",
      "then": "The Carousel Creator provides a live preview and ensures the slides adhere to LinkedIn's format requirements."
    },
    {
      "given": "A user is viewing the Content Library containing various content items.",
      "when": "The user applies filters for \"Status: Draft\" and \"Content Type: Article\".",
      "then": "The Content Library displays only articles that are currently in draft status."
    },
    {
      "given": "A user has selected multiple content items in the Content Library.",
      "when": "The user chooses to \"Delete\" the selected items.",
      "then": "All selected content items are removed from the Content Library, and the user receives a confirmation."
    },
    {
      "given": "An editor has submitted content for review, and an approver views the submission.",
      "when": "The approver adds a comment, requests a change, and then approves the content.",
      "then": "The content status changes to \"Approved\", moves to the scheduling phase, and the editor is notified of the approval and comments."
    },
    {
      "given": "A user has multiple saved drafts of a content item.",
      "when": "The user selects an earlier version from the version history and chooses to \"Rollback\".",
      "then": "The content editor reverts to the state of the selected prior version, and the changes are tracked."
    },
    {
      "given": "A user has prepared content and is viewing the Calendar Scheduling interface.",
      "when": "The user drags the content item to a specific future date and time slot, and sets it as a recurring post.",
      "then": "The content is scheduled for publication at the specified date and time, and appears on the calendar with its recurring instances."
    },
    {
      "given": "Content is scheduled to publish via LinkedIn's API.",
      "when": "The scheduled time arrives, but LinkedIn's API is temporarily unavailable.",
      "then": "The system attempts to publish the content using retry logic, and if it ultimately fails, an alert is sent to the user in-app and via email."
    },
    {
      "given": "A user has content scheduled for publication.",
      "when": "The content is successfully published on LinkedIn.",
      "then": "The user receives a confirmation notification in-app and via email."
    },
    {
      "given": "A user is viewing the Engage Feed, which displays relevant LinkedIn posts.",
      "when": "The user clicks the \"Like\" button on a prioritized post.",
      "then": "The \"Like\" action is executed on LinkedIn via API without the user leaving Scribl, and the post's engagement is reflected."
    },
    {
      "given": "A user is about to comment on a LinkedIn post from the Engage Feed.",
      "when": "The user requests AI suggestions for a professional comment, selects one, and posts it.",
      "then": "The AI-generated comment is published on LinkedIn via API, maintaining the specified tone and brand voice."
    },
    {
      "given": "A user is viewing their Networking Metrics.",
      "when": "The system analyzes the user's engagement levels with connections.",
      "then": "The system highlights specific prospects or influencers, indicating opportunities for relationship-building."
    },
    {
      "given": "A user is in the Discovery / Opportunities section.",
      "when": "The system analyzes LinkedIn data and market signals.",
      "then": "The system surfaces trending themes relevant to the user's niche."
    },
    {
      "given": "A user has configured competitor accounts for analysis.",
      "when": "The user requests a Competitor Analysis report.",
      "then": "The system displays the user's content performance benchmarked against similar accounts or competitors, highlighting performance differences."
    },
    {
      "given": "A user is seeking new content ideas.",
      "when": "The user reviews the Gap Analysis feature.",
      "then": "The system identifies content areas where competitors are active but the user is not, suggesting new directions for content creation."
    },
    {
      "given": "A user is considering a new content topic suggested by the system.",
      "when": "The user views the predicted performance for that topic.",
      "then": "The system displays an AI-forecasted expected engagement level for the topic before content creation begins."
    },
    {
      "given": "A user is viewing the Analytics Dashboard.",
      "when": "The user applies a filter for \"Time Range: Last 30 Days\" and \"Content Type: Carousel\".",
      "then": "The dashboard updates to display visual reports on impressions, clicks, engagement rates, and follower growth specifically for carousels published in the last 30 days."
    },
    {
      "given": "A user has a history of published content and engagement data.",
      "when": "The user accesses the AI Insights section.",
      "then": "Scribl analyzes past performance and provides tailored recommendations such as best posting times and content types with the highest engagement."
    },
    {
      "given": "A user is viewing an Analytics report.",
      "when": "The user selects to export the report in PDF format.",
      "then": "The system generates and downloads a PDF file containing the analytics data for team reviews."
    },
    {
      "given": "An admin is managing their team.",
      "when": "The admin invites a new member via email, assigns them an \"Editor\" role, and sets specific content creation permissions.",
      "then": "The new member receives an invitation, their role and permissions are recorded, and the seat usage count is updated."
    },
    {
      "given": "An enterprise account admin.",
      "when": "The admin creates a new workspace for the \"EMEA Marketing Team\".",
      "then": "A new workspace is provisioned with its own separate content library, analytics dashboard, and template repository, distinct from other workspaces."
    },
    {
      "given": "An admin needs to review activity for compliance.",
      "when": "The admin accesses the Audit & Activity Logs.",
      "then": "The system displays a chronological record of all key actions (created, edited, approved, published content) with timestamps and the actors responsible for each action."
    },
    {
      "given": "A user is managing their subscription.",
      "when": "The user updates their payment method and upgrades their subscription plan.",
      "then": "The system processes the payment method update, applies the new subscription plan with prorated billing, and provides an updated invoice."
    },
    {
      "given": "A user has a 'Normal' subscription",
      "when": "They attempt to access advanced analytics features",
      "then": "The system should restrict access and prompt them to upgrade their subscription."
    },
    {
      "given": "A user has a 'Pro' subscription",
      "when": "They utilize AI-powered features for content creation",
      "then": "Their AI credit usage should be unlimited."
    },
    {
      "given": "An 'Enterprise' user manages their account",
      "when": "They navigate to workspace management",
      "then": "They should be able to create and manage multiple separate workspaces."
    },
    {
      "given": "A user has a pending approval for a post",
      "when": "They log into the application",
      "then": "An in-app alert should notify them of the pending approval."
    },
    {
      "given": "A user successfully publishes a post",
      "when": "The publishing process is complete",
      "then": "An in-app alert should confirm the successful publication."
    },
    {
      "given": "An error occurs during a user action (e.g., content save failure)",
      "when": "The user performs the action",
      "then": "An in-app alert should inform the user of the error."
    },
    {
      "given": "A user's recurring payment fails",
      "when": "The system detects the failed payment",
      "then": "An email alert should be sent to the user regarding the critical update."
    },
    {
      "given": "A publishing error occurs for a user's scheduled post",
      "when": "The system detects the publishing error",
      "then": "An email alert should be sent to the user regarding the error."
    },
    {
      "given": "A team has enabled Slack integration for notifications",
      "when": "A critical event occurs (e.g., publishing error, approval request)",
      "then": "A real-time notification should be sent to the configured Slack channel."
    },
    {
      "given": "A user is on their profile settings page",
      "when": "They update their name, title, profile picture, or brand voice preferences and save",
      "then": "Their profile information should be updated successfully."
    },
    {
      "given": "A user is on their preferences page",
      "when": "They change their notification frequency or privacy controls and save",
      "then": "Their notification and privacy preferences should be updated."
    },
    {
      "given": "A user is on their preferences page",
      "when": "They select 'dark mode' for UI customization and save",
      "then": "The application UI should switch to dark mode."
    },
    {
      "given": "A user wants to export their personal data",
      "when": "They request data export from their settings",
      "then": "Their data should be prepared for export and provided according to GDPR guidelines."
    },
    {
      "given": "A user wants to delete their account",
      "when": "They request account deletion from their settings",
      "then": "Their account should be queued for deletion according to GDPR guidelines."
    },
    {
      "given": "A user is creating or editing a post",
      "when": "They use the image insertion tool and search for 'marketing'",
      "then": "Relevant stock images from Unsplash/Pexels should be displayed."
    },
    {
      "given": "A user has searched for and selected a stock image",
      "when": "They insert the image into their post",
      "then": "The image should be inserted, and required attribution should be automatically added."
    },
    {
      "given": "A user frequently uses a specific stock image",
      "when": "They attempt to insert that image again",
      "then": "The image should load faster from cache, improving performance."
    },
    {
      "given": "A user is on the main dashboard",
      "when": "They use the unified search bar to query 'Q4 campaign'",
      "then": "Search results should include relevant content, templates, analytics, and opportunities."
    },
    {
      "given": "A user has performed a search",
      "when": "They apply filters for 'content type: social media' and 'status: pending approval'",
      "then": "The search results should narrow down to only show social media content pending approval."
    },
    {
      "given": "A user accesses the application on a mobile browser",
      "when": "They navigate through different modules",
      "then": "The layouts should be optimized and responsive for the mobile screen size."
    },
    {
      "given": "A user is on a mobile device",
      "when": "They initiate a 'quick create' for a new post",
      "then": "A streamlined drafting workflow designed for small screens should be presented."
    },
    {
      "given": "A manager is on a mobile device",
      "when": "They receive an approval request",
      "then": "They should be able to approve or reject the content using a mobile-optimized workflow."
    },
    {
      "given": "A user wants to export their content",
      "when": "They select to export 'posts' in CSV format",
      "then": "A CSV file containing their post data should be downloaded."
    },
    {
      "given": "An Enterprise user is setting up their account",
      "when": "They bulk upload a list of team member emails via a CSV file",
      "then": "All team members should be added to their workspace."
    },
    {
      "given": "An Enterprise user wants to use pre-approved templates",
      "when": "They bulk upload custom templates via a JSON file",
      "then": "The templates should be imported and available for use in their workspace."
    },
    {
      "given": "A user needs help with a feature",
      "when": "They click on the 'Help' icon in-app",
      "then": "A link to the relevant FAQs and support documentation should be displayed."
    },
    {
      "given": "A new user logs in for the first time",
      "when": "The application detects a new user",
      "then": "An interactive walkthrough tour explaining each module should begin."
    },
    {
      "given": "A user encounters an issue",
      "when": "They use the in-app support tool to report an issue",
      "then": "A support ticket should be created in the integrated helpdesk platform (e.g., Zendesk)."
    },
    {
      "given": "A user's LinkedIn access token has expired",
      "when": "They attempt to perform an action requiring LinkedIn authentication",
      "then": "The system should prompt the user to re-authenticate with LinkedIn."
    },
    {
      "given": "A Pro subscription user's recurring payment fails",
      "when": "The payment system processes the failed payment",
      "then": "The user's plan should be downgraded (e.g., to Normal), and an administrator should be notified."
    },
    {
      "given": "A user requests AI-powered content generation",
      "when": "The AI API returns an error",
      "then": "The system should offer fallback templates and allow the user to retry the AI generation."
    },
    {
      "given": "A piece of content requires approval, and the approval deadline passes",
      "when": "The system checks for overdue approvals",
      "then": "Reminders should be sent to the approver, and escalation notifications should be triggered."
    },
    {
      "given": "A user is on the Scribl login page.",
      "when": "They select to log in with LinkedIn.",
      "then": "They are redirected to LinkedIn for authentication and then back to Scribl upon successful authentication."
    },
    {
      "given": "A new user has successfully authenticated.",
      "when": "They complete the guided onboarding flow by providing their goals, brand voice, frequency, and niches.",
      "then": "Their profile is configured with these preferences."
    },
    {
      "given": "A new user has completed onboarding.",
      "when": "They select a subscription plan and provide payment details via Stripe.",
      "then": "Their account is activated with the chosen subscription, and Stripe processes the payment."
    },
    {
      "given": "A user is in the content creation interface.",
      "when": "They provide a prompt to the AI assistant.",
      "then": "The AI assistant generates multiple content variations based on the prompt."
    },
    {
      "given": "A user is editing content in the canvas editor.",
      "when": "They modify text, add visuals, and request a preview.",
      "then": "The editor displays the updated content with visuals and a real-time preview."
    },
    {
      "given": "A user wants to create new content.",
      "when": "They select a template for a post, article, or carousel from a specific industry category.",
      "then": "A new content draft is pre-filled with the chosen template's structure and content."
    },
    {
      "given": "A user is using the carousel builder.",
      "when": "They create multiple slides, arrange them, and preview the carousel.",
      "then": "The carousel is built with the specified slides, displays a preview, and flags any compliance issues."
    },
    {
      "given": "A user is browsing the Template Marketplace.",
      "when": "They select a premium template or share a community template.",
      "then": "They can use the premium template after purchase or the community template is made available to others."
    },
    {
      "given": "A user has created multiple content drafts.",
      "when": "They navigate to the content library.",
      "then": "All their content drafts are displayed in a centralized view."
    },
    {
      "given": "A user has submitted content for approval.",
      "when": "An approver reviews the content and either approves or rejects it.",
      "then": "The content's status is updated accordingly, and the original creator is notified."
    },
    {
      "given": "A user has made multiple edits to a piece of content.",
      "when": "They view the content's version history and select an older version to restore.",
      "then": "The content is rolled back to the selected previous version."
    },
    {
      "given": "A user wants to schedule a post.",
      "when": "They drag and drop the post onto a specific date/time in the calendar, set it as recurring, and define a timezone.",
      "then": "The post is scheduled according to the specified date, time, recurrence, and timezone."
    },
    {
      "given": "A post is scheduled for automated publishing.",
      "when": "The scheduled time arrives, and an issue prevents immediate publishing.",
      "then": "The system attempts to re-publish the post and sends an alert if it consistently fails."
    },
    {
      "given": "A post has been published (or failed to publish).",
      "when": "The publishing attempt concludes.",
      "then": "The user receives a notification confirming the success or failure of the publishing action."
    },
    {
      "given": "A user navigates to the Engagement feed.",
      "when": "They view the displayed posts.",
      "then": "The feed shows posts prioritized for interaction, helping the user engage effectively."
    },
    {
      "given": "A user is viewing a post in the Engagement feed.",
      "when": "They click the 'Like' button or initiate a comment/share action.",
      "then": "The corresponding action (like, comment, or share) is performed on the post with minimal user input."
    },
    {
      "given": "A user is about to comment on a post or reply to a comment.",
      "when": "They open the comment/reply box.",
      "then": "The AI assistant provides relevant comment/reply suggestions."
    },
    {
      "given": "A user is reviewing their engagement performance.",
      "when": "They view the networking metrics.",
      "then": "The system displays tracking data for engagement with their connections."
    },
    {
      "given": "A user navigates to the Discovery section.",
      "when": "They view the 'Trending topics'.",
      "then": "The system displays current trending topics identified by AI and LinkedIn signals."
    },
    {
      "given": "A user wants to understand their market position.",
      "when": "They access the competitor & gap analysis feature.",
      "then": "The system provides insights into competitor performance and identifies content gaps."
    },
    {
      "given": "A user is creating new content.",
      "when": "They request a predicted performance analysis for the content.",
      "then": "The AI provides a forecast of how the content is likely to perform before it is published."
    },
    {
      "given": "A user navigates to the Analytics section.",
      "when": "They view the dashboards.",
      "then": "The dashboards display key metrics such as impressions, clicks, engagement rates, and follower growth."
    },
    {
      "given": "A user is reviewing their analytics.",
      "when": "They access the AI insights.",
      "then": "The AI suggests optimal posting times and identifies high-performing content."
    },
    {
      "given": "A user is viewing analytics data.",
      "when": "They select to export the data in CSV, PDF, or JSON format.",
      "then": "The system generates and downloads the analytics data in the chosen format."
    },
    {
      "given": "An admin user is managing team members.",
      "when": "They assign a specific role (e.g., Editor, Approver) to a team member.",
      "then": "The team member's access and capabilities are restricted/granted according to the assigned role."
    },
    {
      "given": "An organization requires separate content management.",
      "when": "An admin sets up multiple workspaces (e.g., for different regions or brands).",
      "then": "Each workspace operates independently with its own content and team members, configured for its specific purpose."
    },
    {
      "given": "An admin wants to review user actions.",
      "when": "They access the audit & activity logs.",
      "then": "The system displays a detailed history of user activities within the platform."
    },
    {
      "given": "A user attempts to perform an action.",
      "when": "Their assigned role's permissions are checked against the requested action.",
      "then": "The system grants or denies access to the action based on the functional RBAC and compliance requirements."
    },
    {
      "given": "An admin is configuring a custom role.",
      "when": "They enable or disable specific granular permissions like 'publish content' or 'view analytics only'.",
      "then": "Users assigned to that role will only have the exact permissions specified."
    },
    {
      "given": "Content requires multi-step approval.",
      "when": "A user submits content that triggers an approval hierarchy.",
      "then": "The content progresses through a defined sequence of reviewers before final approval."
    },
    {
      "given": "Content or data has reached its retention period.",
      "when": "The system applies the defined retention policy.",
      "then": "The content or data is archived or deleted according to the policy."
    },
    {
      "given": "A user creates data in a specific region (e.g., EU).",
      "when": "The system stores the data.",
      "then": "The data is stored in a server geographically located within the specified region to comply with data segregation requirements."
    },
    {
      "given": "A user is selecting a subscription.",
      "when": "They choose between Normal, Pro, or Enterprise tiered plans.",
      "then": "Their account is provisioned with the features and limits corresponding to the selected plan."
    },
    {
      "given": "A user wants to manage their subscription.",
      "when": "They access the billing dashboard.",
      "then": "The dashboard displays their subscription status, past invoices, and allows management of payment methods."
    },
    {
      "given": "A user is on a subscription plan.",
      "when": "They upgrade or downgrade their plan.",
      "then": "Their billing is adjusted immediately with prorated charges or credits for the remaining period."
    },
    {
      "given": "A user is on a specific subscription tier.",
      "when": "They generate AI content.",
      "then": "Their AI credit balance is debited from the allocation corresponding to their tier."
    },
    {
      "given": "A user creates AI-generated content of various types.",
      "when": "They generate a post, article, or carousel.",
      "then": "The AI credits are calculated and consumed differently based on the content type."
    },
    {
      "given": "An admin wants to monitor AI credit usage.",
      "when": "They view the usage tracking dashboards.",
      "then": "The dashboards display AI credit consumption per user and per team."
    },
    {
      "given": "A user's AI credits are running low.",
      "when": "Their credit balance falls below a threshold.",
      "then": "The system sends an alert and offers options to purchase extra credit packs or enable auto top-ups."
    },
    {
      "given": "An admin manages team resources.",
      "when": "They allocate specific AI credits to individual team members.",
      "then": "Each team member can only use up to the credits assigned by the admin."
    },
    {
      "given": "A significant event occurs (e.g., content approved, publishing failed).",
      "when": "The event triggers a notification.",
      "then": "The user receives an alert via in-app, email, or integrated third-party platforms like Slack/Teams."
    },
    {
      "given": "A user wants to manage their personal settings.",
      "when": "They access their Profile & Settings.",
      "then": "They can update their brand voice, preferences, and initiate GDPR data export or deletion requests."
    },
    {
      "given": "A user is creating content requiring visuals.",
      "when": "They search for an image in the stock image library.",
      "then": "The system integrates with Unsplash/Pexels, allows image selection with automatic attribution, and caches frequently used images."
    },
    {
      "given": "A user needs to find specific content or data.",
      "when": "They use the global search bar or apply advanced filters.",
      "then": "The system quickly returns relevant results based on the search query or applied filters."
    },
    {
      "given": "A user accesses Scribl on a mobile device.",
      "when": "They perform actions like creating, approving, or publishing content.",
      "then": "The responsive PWA provides an optimized interface and allows quick execution of these tasks."
    },
    {
      "given": "An enterprise user needs to manage data.",
      "when": "They initiate a bulk import or export of data in CSV or JSON format.",
      "then": "The system processes the bulk data operation, facilitating enterprise setup or data migration."
    },
    {
      "given": "A user requires assistance.",
      "when": "They access the help center, follow an onboarding tour, or submit a support ticket.",
      "then": "They receive guided assistance, documentation, or direct support from the helpdesk."
    },
    {
      "given": "A user prefers a different language.",
      "when": "They select a specific language for the UI or for AI content generation.",
      "then": "The user interface switches to the chosen language, and AI content can be generated in that language."
    },
    {
      "given": "A user wants to connect Scribl with other tools.",
      "when": "They configure an integration with Slack, CRM, email, calendar, Salesforce, or HubSpot.",
      "then": "Scribl seamlessly exchanges data and functionality with the chosen external system."
    },
    {
      "given": "A developer wants to extend Scribl's functionality.",
      "when": "They use the provided REST/GraphQL APIs, set up webhooks, and manage API keys.",
      "then": "They can programmatically interact with Scribl, subject to defined rate limits."
    },
    {
      "given": "a user has created new content",
      "when": "the user requests a uniqueness check for the content",
      "then": "the system should analyze the content for plagiarism and provide a report."
    },
    {
      "given": "a user has created new content",
      "when": "the user requests an AI safety check for the content",
      "then": "the system should scan the content for harmful or AI-generated patterns and provide a safety rating."
    },
    {
      "given": "a user with a specific role (e.g., 'Editor')",
      "when": "the user attempts to perform an action restricted to another role (e.g., 'Admin')",
      "then": "the system should deny access and prevent the action."
    },
    {
      "given": "an administrator user",
      "when": "the administrator assigns a 'Manager' role to a team member",
      "then": "the team member should gain the permissions associated with the 'Manager' role within their scope."
    },
    {
      "given": "a user performs a significant action (e.g., 'delete content item')",
      "when": "the action is completed",
      "then": "the system should record the user, action, target, and timestamp in an audit log."
    },
    {
      "given": "an administrator user",
      "when": "the administrator views the audit logs",
      "then": "the system should display a chronological record of all significant actions performed by users."
    },
    {
      "given": "a user requests their personal data to be deleted (right to be forgotten)",
      "when": "the deletion request is processed",
      "then": "the system should irrevocably remove all personal identifying information associated with that user, while retaining necessary anonymized data for legal or operational purposes."
    },
    {
      "given": "an enterprise user with an SSO-configured account",
      "when": "the user attempts to log in via their enterprise identity provider",
      "then": "the user should be successfully authenticated and granted access to the application."
    },
    {
      "given": "an enterprise administrator",
      "when": "the administrator defines parameters for a custom report (e.g., content performance by tag over a specific period)",
      "then": "the system should generate a report matching the specified criteria."
    },
    {
      "given": "an enterprise administrator needs to enforce specific compliance standards",
      "when": "the administrator activates a compliance pack (e.g., 'GDPR Compliance Pack')",
      "then": "the system should configure relevant settings, workflows, and checks to align with the chosen compliance standard."
    },
    {
      "given": "a user has a content item ready for publishing and their LinkedIn profile linked",
      "when": "the user schedules or publishes the content item to LinkedIn",
      "then": "the system should successfully post the content to the user's LinkedIn profile."
    },
    {
      "given": "the system architecture supports flexible integration with external platforms",
      "when": "new social media platforms (X, Instagram, YouTube) become available for integration",
      "then": "the system should allow for efficient development and rollout of publishing capabilities to these platforms."
    },
    {
      "given": "A new user account is being provisioned",
      "when": "The user account is created without an explicitly specified role",
      "then": "The user's role should default to 'EDITOR' based on the UserRole enum"
    },
    {
      "given": "A user account with a specific email address already exists",
      "when": "An attempt is made to create another user account using the same email address",
      "then": "The system should prevent the creation of the duplicate user account, enforcing email uniqueness"
    },
    {
      "given": "A team already exists with a specific, non-null slug",
      "when": "An attempt is made to create another team using the same slug",
      "then": "The system should prevent the creation of the duplicate team, enforcing slug uniqueness"
    },
    {
      "given": "A user account exists in the system",
      "when": "The user account is marked for deletion",
      "then": "The 'deletedAt' field of the user's record should be populated with a timestamp, indicating a soft deletion"
    },
    {
      "given": "A team exists in the system",
      "when": "The team is marked for deletion",
      "then": "The 'deletedAt' field of the team's record should be populated with a timestamp, indicating a soft deletion"
    },
    {
      "given": "A User account exists",
      "when": "A new Team is created",
      "then": "The Team can be optionally associated with an existing User as its owner, through the 'ownerId' field"
    },
    {
      "given": "A new data model is introduced into the system",
      "when": "The schema is validated against the architectural principles",
      "then": "The new data model must have a defined relation to either a User, a Team, or a Workspace entity"
    },
    {
      "given": "A User and a specific Team or Workspace exist",
      "when": "A User's role is defined within the context of that specific Team or Workspace",
      "then": "The system should record this context-specific role using the 'UserRoleRelation' model, distinct from the user's global default role"
    },
    {
      "given": "A user wants to manage a group of individuals and resources",
      "when": "A new team is created",
      "then": "The team is established, has a unique identifier, an owner, and can manage its lifecycle including soft-deletion"
    },
    {
      "given": "An active team exists and an administrator wants to expand the team",
      "when": "A user is invited to join the team",
      "then": "A TeamMember record is created with an 'invited' status, preventing duplicate invitations for the same user to the same team"
    },
    {
      "given": "A user has been invited to a team",
      "when": "The user accepts the team invitation",
      "then": "The 'acceptedAt' timestamp is recorded, and the user's status within the team is updated to reflect their active membership"
    },
    {
      "given": "An active team exists and a user is a member of that team",
      "when": "A seat of a specific type (e.g., 'SeatType') is assigned to the user within the team",
      "then": "A Seat record is created for the user on the team, preventing the same user from being assigned multiple seats on the same team"
    },
    {
      "given": "An active team exists and needs a dedicated collaborative space",
      "when": "A new workspace is created for the team",
      "then": "The workspace is associated with the team, has a unique name and an optional slug, and supports soft-deletion"
    },
    {
      "given": "A workspace exists and a user needs access to it",
      "when": "A user is associated with the workspace",
      "then": "A UserWorkspace record is created, defining the user's permission set within that workspace and preventing duplicate associations"
    },
    {
      "given": "A team requires external authentication or user management capabilities",
      "when": "The team links with a configured identity provider",
      "then": "An IdpLink record is created, associating the team with the specific identity provider for delegated authentication"
    },
    {
      "given": "A user wants to integrate their external social media presence with their profile",
      "when": "The user links their LinkedIn profile to their account",
      "then": "A LinkedInProfile record is created, storing their LinkedIn profile ID, display name, and securely encrypted access tokens and scopes"
    },
    {
      "given": "a user has successfully authenticated with LinkedIn",
      "when": "the system processes the LinkedIn profile connection",
      "then": "a 'LinkedInProfile' record is created for the user, storing their profile ID, access token, scope, and initial sync timestamp."
    },
    {
      "given": "an existing 'LinkedInProfile' record for a user",
      "when": "the system performs a successful data synchronization with LinkedIn",
      "then": "the 'lastSyncAt' field of the 'LinkedInProfile' record is updated to the current timestamp."
    },
    {
      "given": "a team exists in the system",
      "when": "a user belonging to that team creates a new brand voice with a unique name, description, and voice JSON configuration",
      "then": "a 'BrandVoice' record is created, associated with the team, containing the provided details."
    },
    {
      "given": "a new user is created in the system",
      "when": "the user accesses the onboarding section",
      "then": "an 'OnboardingProfile' record is automatically created for the user."
    },
    {
      "given": "an 'OnboardingProfile' exists for a user",
      "when": "the user completes all required onboarding steps",
      "then": "the 'onboardedAt' field in the user's 'OnboardingProfile' is updated to the current timestamp."
    },
    {
      "given": "a system administrator and a specific team or workspace",
      "when": "the administrator creates a new role with a unique name and description, associated with that team or workspace",
      "then": "a 'Role' record is created, linked to the specified team or workspace."
    },
    {
      "given": "an existing 'Role' and an existing 'Permission'",
      "when": "an administrator assigns the 'Permission' to the 'Role'",
      "then": "a 'RolePermission' record is created, establishing the relationship between the 'Role' and the 'Permission'."
    },
    {
      "given": "an existing 'RolePermission' record linking a specific 'Role' to a specific 'Permission'",
      "when": "an administrator attempts to assign the same 'Permission' to the same 'Role' again",
      "then": "the system prevents the creation of a duplicate 'RolePermission' record and confirms the existing assignment."
    },
    {
      "given": "an existing 'User', an existing 'Role', and a defined scope (e.g., a Team ID or Workspace ID)",
      "when": "an administrator assigns the 'Role' to the 'User' within that specific scope",
      "then": "a 'UserRoleRelation' record is created, linking the 'User' and 'Role' with the specified 'scopeType' and 'scopeId'."
    },
    {
      "given": "an existing 'UserRoleRelation' record for a specific 'User', 'Role', and 'Scope'",
      "when": "an administrator attempts to assign the same 'Role' to the same 'User' within the identical 'Scope' again",
      "then": "the system prevents the creation of a duplicate 'UserRoleRelation' record."
    },
    {
      "given": "a user and an associated team",
      "when": "the user creates a new template, providing a title, content type, and JSON schema, and associates it with their team",
      "then": "a 'Template' record is created, owned by the user, linked to the team, and storing the title, content type, and JSON schema."
    },
    {
      "given": "A user intends to create a new template",
      "when": "The user provides essential template details including ownerId, workspaceId, and type",
      "then": "A Template record is created with a version of 1, createdAt set to the current time, updatedAt set to the current time, sharedScope defaults to \"private\", and searchTsv is generated."
    },
    {
      "given": "An existing Template is available",
      "when": "A sharedByUser shares the Template with a targetWorkspace",
      "then": "A TemplateShare record is created, linking the templateId to the targetWorkspaceId, with sharedBy and createdAt recorded."
    },
    {
      "given": "An existing Template and a User designated as a publisher",
      "when": "The publisher initiates a listing for the Template on the marketplace, optionally providing pricingJson",
      "then": "A TemplateMarketplaceItem record is created, associating the templateId with the publisherId, listedAt is set, and status is optionally set."
    },
    {
      "given": "A user wants to create a new content entry",
      "when": "The user specifies an ownerId, type, and optionally teamId, workspaceId, title, body, and tags",
      "then": "A ContentItem record is created with status defaulting to DRAFT, version to 1, createdAt to the current time, updatedAt to the current time, and searchTsv is populated."
    },
    {
      "given": "An existing ContentItem",
      "when": "The content item's data (e.g., title, body, tags) is modified",
      "then": "The updatedAt timestamp of the ContentItem is updated, and the version number is incremented."
    },
    {
      "given": "A user is authorized to create content.",
      "when": "The user creates a new ContentItem with an initial body.",
      "then": "A new ContentItem should be created, and an initial ContentVersion linked to it, recording the provided body and the author."
    },
    {
      "given": "An existing ContentItem with at least one ContentVersion.",
      "when": "A user modifies the ContentItem's body and provides a change reason and an optional version label.",
      "then": "A new ContentVersion should be created, linked to the ContentItem, containing the updated body, change reason, version label, and the author."
    },
    {
      "given": "An existing ContentItem and an existing Image asset.",
      "when": "A user associates the Image with the ContentItem, specifying its display position and optional metadata.",
      "then": "A ContentMedia entry should be created, linking the ContentItem to the Image at the specified position with the given metadata."
    },
    {
      "given": "An existing ContentItem.",
      "when": "A user uploads a file as an attachment, providing its filename, content type, size, and storage path.",
      "then": "A new Attachment record should be created, linked to the ContentItem, storing the file's details."
    },
    {
      "given": "An existing ContentItem.",
      "when": "A user adds a new carousel slide to the ContentItem, providing its body content and intended position.",
      "then": "A new CarouselSlide record should be created, linked to the ContentItem, containing the slide's body and position."
    },
    {
      "given": "A ContentItem that has multiple ContentVersion records.",
      "when": "A user requests to view the version history of that ContentItem.",
      "then": "A list of all associated ContentVersion records, including author, change reason, version label, and creation timestamp, should be returned."
    },
    {
      "given": "An existing ContentItem.",
      "when": "A user initiates a soft delete operation for the ContentItem.",
      "then": "The 'deleted_at' field of the ContentItem should be populated with the current timestamp, marking it as soft-deleted."
    },
    {
      "given": "A ContentItem with multiple associated ContentMedia records, each linking to an Image.",
      "when": "A user requests to view all media associated with the ContentItem.",
      "then": "A list of ContentMedia entries, including details of the linked Images and their positions, should be returned."
    },
    {
      "given": "A ContentItem exists and an ApprovalHierarchy is configured for the workspace.",
      "when": "A user submits the ContentItem for approval.",
      "then": "An Approval record is created with status set to PENDING, linked to the ContentItem, submitter, and the first step of the ApprovalHierarchy."
    },
    {
      "given": "An Approval record exists with status PENDING, assigned to an approver at a specific step in an ApprovalHierarchy.",
      "when": "The assigned approver accepts the Approval.",
      "then": "An ApprovalTransition record is created, and the Approval record's status is updated to the next step or APPROVED if it's the final step."
    },
    {
      "given": "An Approval record exists with status PENDING, assigned to an approver.",
      "when": "The assigned approver rejects the Approval and provides comments.",
      "then": "An ApprovalTransition record is created with commentJson, and the Approval record's status is updated to REJECTED."
    },
    {
      "given": "A ContentItem and a Workspace exist.",
      "when": "A user creates a new Schedule for the ContentItem to be published at a specific scheduledAt date and time.",
      "then": "A Schedule record is created with status PENDING, scheduledAt populated, and recurrenceJson as null."
    },
    {
      "given": "A ContentItem and a Workspace exist.",
      "when": "A user creates a new Schedule for the ContentItem with a recurring pattern defined in recurrenceJson.",
      "then": "A Schedule record is created with status PENDING, scheduledAt populated, recurrenceJson populated, and nextRunAt calculated based on the recurrence."
    },
    {
      "given": "A Schedule record exists for a ContentItem with status PENDING and nextRunAt is in the past or present.",
      "when": "The scheduling system processes scheduled events.",
      "then": "A PublishJob is created, the Schedule's status is updated (e.g., to COMPLETED or PROCESSING), and nextRunAt is updated for recurring schedules."
    },
    {
      "given": "a content item exists and is ready for publishing",
      "when": "a new publish job is created without a specific run time or priority",
      "then": "the publish job status should be 'QUEUED', priority should be '100', and attempt count should be '0'"
    },
    {
      "given": "a content item and a specific future date and time are provided",
      "when": "a new publish job is created with the specified 'runAt' time",
      "then": "the publish job should be scheduled to execute at the designated 'runAt' time"
    },
    {
      "given": "a publish job with a unique 'idempotencyKey' has been created",
      "when": "an attempt is made to create another publish job with the same 'idempotencyKey'",
      "then": "the system should prevent the creation of a duplicate job and acknowledge the existing one"
    },
    {
      "given": "a publish job is in 'QUEUED' status",
      "when": "a worker successfully processes the publish job",
      "then": "the publish job's 'status' should be updated to 'PUBLISHED', 'publishedAt' should be set, and a 'JobAttempt' record should be created with no 'errorText'"
    },
    {
      "given": "a publish job is in 'QUEUED' status",
      "when": "a worker attempts to process the publish job but encounters an error",
      "then": "the publish job's 'status' should be updated to 'FAILED', 'lastError' should be populated, and a 'JobAttempt' record should be created with the 'errorText'"
    },
    {
      "given": "multiple publish jobs are in 'QUEUED' status with varying 'priority' values",
      "when": "the job processing system selects jobs for execution",
      "then": "jobs with a lower 'priority' value should be selected and processed before jobs with higher priority values"
    },
    {
      "given": "a publish job is being processed by a worker",
      "when": "the worker starts an attempt to publish the content",
      "then": "a 'JobAttempt' record should be created, linked to the 'publishJobId', with 'attemptAt' set and 'workerId' recorded"
    },
    {
      "given": "a publish job has successfully posted content to a specific platform",
      "when": "the platform post details are recorded",
      "then": "a 'PlatformPost' record should be created, linked to the 'publishJobId', with 'platform', 'externalPostId', and 'publishedAt' set, and a successful 'status'"
    },
    {
      "given": "a user interacts with a content item within the application",
      "when": "an 'EngagementAction' (e.g., 'like', 'view') is performed on the 'contentItemId'",
      "then": "an 'Engagement' record should be created, linking the 'userId' to the 'contentItemId' and the specific 'action'"
    },
    {
      "given": "a user interacts with an external social media post associated with an application's publish job",
      "when": "an 'EngagementAction' is performed on the 'externalPostId'",
      "then": "an 'Engagement' record should be created, linking the 'userId' to the 'externalPostId' and the specific 'action'"
    },
    {
      "given": "a user is active within a specific workspace",
      "when": "an engagement feed is generated or updated for that user and workspace",
      "then": "an 'EngagementFeed' record should be created or refreshed, containing the 'feedJson' for the 'userId' and 'workspaceId', with 'generatedAt' timestamp"
    },
    {
      "given": "the system has evaluated trending data for a workspace and topic",
      "when": "a new trending signal is identified or updated",
      "then": "a 'TrendingSignal' record should be created or updated, linked to the 'workspaceId' and 'topic', including 'signalJson', 'score', and 'evaluatedAt'"
    },
    {
      "given": "a user within a workspace wants to track a competitor's social account",
      "when": "a new competitor account is added for the workspace with an 'externalAccountId'",
      "then": "a 'CompetitorAccount' record should be created, linked to the 'workspaceId', containing the 'externalAccountId' and optionally a 'name' and 'addedBy' user"
    },
    {
      "given": "A user wants to manage competitor information within a workspace.",
      "when": "A new competitor account is added with a unique external identifier.",
      "then": "The system should create a 'CompetitorAccount' record, associating it with the 'workspaceId' and 'externalAccountId', automatically setting the 'addedAt' timestamp."
    },
    {
      "given": "An existing 'CompetitorAccount' is being monitored for performance.",
      "when": "A new snapshot of the competitor's metrics is captured.",
      "then": "The system should create a 'CompetitorSnapshot' record, linked to the 'competitorAccountId', storing the 'metricsJson', optional 'rawDataJson', and the 'snapshotAt' timestamp."
    },
    {
      "given": "A user or system interacts with an AI model.",
      "when": "An AI prompt is sent, and a response is generated.",
      "then": "The system should log an 'AiPrompt' record, including the 'userId', 'prompt' text, optional 'contextJson', 'model' used, 'responseSnippet', 'tokensIn', 'tokensOut', 'cost', and a 'correlationId'."
    },
    {
      "given": "AI services are utilized by users or teams.",
      "when": "AI resources are consumed (e.g., tokens processed).",
      "then": "The system should update or create an 'AiUsage' record, aggregating 'tokensUsed' and 'costEstimate' for the respective 'userId', 'workspaceId', or 'teamId'."
    },
    {
      "given": "The platform needs to offer different AI credit bundles.",
      "when": "A new AI credit pack is defined with specific attributes.",
      "then": "The system should create an 'AiCreditPack' record, detailing the 'plan' name, total 'credits', 'currency', and 'price'."
    },
    {
      "given": "A team or user requires an allocation of AI credits.",
      "when": "AI credits are allocated to a 'teamId' or 'userId'.",
      "then": "The system should create an 'AiCreditAllocation' record, setting 'creditsTotal' and 'creditsRemaining' to the allocated amount, and timestamping the 'allocatedAt'."
    },
    {
      "given": "AI credits have been allocated to a user or team, and usage occurs.",
      "when": "Credits are consumed from or added to an 'AiCreditAllocation'.",
      "then": "The system should create an 'AiCreditLedger' entry, linked to the 'allocationId', recording the 'delta' (change in credits), the 'balanceAfter' the transaction, and an optional 'reason'."
    },
    {
      "given": "An AI credit ledger exists to track transactions.",
      "when": "A new credit transaction is recorded for a user and allocation, specifying its type, amount, and reason.",
      "then": "The transaction is stored with a default creation timestamp, and can be retrieved efficiently by either the allocation ID or the user ID."
    },
    {
      "given": "A team and an available AI credit pack exist.",
      "when": "A request is made to top up credits for the team using the specified pack, including the amount and credits.",
      "then": "A new credit top-up record is created with the provided details, an initial status, and links to the respective team and credit pack."
    },
    {
      "given": "A quota counter system is in place for tracking resource consumption.",
      "when": "The system attempts to increment the 'consumed' value for a specific metric within a given period for a team and workspace.",
      "then": "If a unique counter for that team, workspace, metric, and period already exists, its 'consumed' value is updated; otherwise, a new counter is created with the initial consumed value, ensuring the uniqueness constraint is maintained."
    },
    {
      "given": "A user is interacting with a workspace that offers help tours.",
      "when": "The user completes a specific help tour, identified by its unique key, within that workspace.",
      "then": "A record is created marking the tour as completed for that user in that workspace, and any subsequent attempts to complete the same tour by the same user in the same workspace do not create duplicate completion records."
    },
    {
      "given": "A workspace is available for configuring external services.",
      "when": "A new integration of a specific type (e.g., 'Slack', 'Jira') is set up and configured for the workspace.",
      "then": "The integration's details, configuration (as JSON), and status are stored, and the integration can be efficiently looked up by its workspace and type."
    },
    {
      "given": "An active integration exists within the system.",
      "when": "A new event related to that integration is received, containing an event type and a payload.",
      "then": "An integration event record is created, capturing the event type, payload, an initial status, a default received timestamp, and can be queried by the integration ID and event type."
    },
    {
      "given": "A workspace requires secure access for external applications.",
      "when": "A new API key is generated for the workspace with a descriptive name and optional scopes.",
      "then": "A new API key record is created, storing a hash of the key, an active status by default, a creation timestamp, and the key can be retrieved based on the workspace ID and its active status."
    },
    {
      "given": "A content item has undergone a plagiarism analysis.",
      "when": "The plagiarism check engine returns a result, including a score, detailed result JSON, and the engine used.",
      "then": "A plagiarism check record is created for the content item, capturing the engine used, the score, the full result JSON, and the timestamp of when the check was performed."
    },
    {
      "given": "A content item has been subjected to a compliance review.",
      "when": "A compliance check tool provides a result for a specific type of compliance check on the content item.",
      "then": "A content compliance record is created for the content item, storing the check type and the detailed result in JSON format."
    },
    {
      "given": "a content item exists",
      "when": "the content item is checked for compliance",
      "then": "its compliance status and result are recorded"
    },
    {
      "given": "a content item exists",
      "when": "analytical metrics are collected for it",
      "then": "the metrics are recorded in the analytics system"
    },
    {
      "given": "a user in a workspace requests to export a report with specific parameters",
      "when": "the report export process is initiated",
      "then": "a report export record is created with a 'requested' status and appropriate details"
    },
    {
      "given": "a workspace administrator wants to define how data should be retained",
      "when": "they create a new retention policy with a name and rules",
      "then": "the retention policy is saved for the workspace"
    },
    {
      "given": "a team administrator needs to configure data residency for a specific region",
      "when": "they specify the data residency configuration for that region",
      "then": "the region's data configuration is stored for the team"
    },
    {
      "given": "a user within a workspace experiences an issue and needs assistance",
      "when": "they create a support ticket with a subject, body, status, and priority",
      "then": "the support ticket is recorded and associated with their workspace"
    },
    {
      "given": "a user is interacting with a help tour in a workspace",
      "when": "they complete a specific step or the entire help tour",
      "then": "the completion status for that help tour key is updated for the user"
    },
    {
      "given": "an administrator wants to add a new language option to the system",
      "when": "they create a new locale with a unique code and name",
      "then": "the new locale is available for use in the system"
    },
    {
      "given": "a locale exists and a translation is needed for a specific text",
      "when": "a translation is provided for that locale, optionally scoped to a workspace",
      "then": "the translation is saved and linked to the respective locale and workspace (if applicable)"
    },
    {
      "given": "A specific locale, a workspace, a translation key, and translation text",
      "when": "A new translation is created",
      "then": "A 'Translation' record is stored with the provided details, associated with the workspace, and an 'updatedAt' timestamp is recorded."
    },
    {
      "given": "An existing workspace, a user, a file path, and an import type",
      "when": "A new import job is initiated",
      "then": "An 'ImportJob' record is created with a unique ID, linked to the workspace and user, with 'filePath', 'type', 'status' (e.g., 'PENDING'), and a 'createdAt' timestamp. 'completedAt' and 'paramsJson' are initially null."
    },
    {
      "given": "An existing import job with status 'PENDING'",
      "when": "The import process completes successfully",
      "then": "The 'status' of the 'ImportJob' is updated to 'COMPLETED' and 'completedAt' is set to the current timestamp."
    },
    {
      "given": "An existing workspace, a user, a file path, and an export format",
      "when": "A new export job is initiated",
      "then": "An 'ExportJob' record is created with a unique ID, linked to the workspace and user, with 'filePath', 'format', 'status' (e.g., 'PENDING'), and a 'createdAt' timestamp. 'completedAt' and 'paramsJson' are initially null."
    },
    {
      "given": "An existing export job with status 'PENDING'",
      "when": "The export process completes successfully",
      "then": "The 'status' of the 'ExportJob' is updated to 'COMPLETED' and 'completedAt' is set to the current timestamp."
    },
    {
      "given": "A unique name for a stock image provider and optional configuration details",
      "when": "A new stock image provider is registered",
      "then": "A 'StockImageProvider' record is created with a unique ID, the specified name, optional 'configJson', and a 'createdAt' timestamp."
    },
    {
      "given": "An existing stock image provider, a unique 'providerImageId', optional metadata, and an optional owner user",
      "when": "A stock image is cached",
      "then": "A 'StockImageCache' record is created with a unique ID, linked to the provider, storing the 'providerImageId', optional 'ownerId' and 'metadata', and an optional 'cachedAt' timestamp."
    },
    {
      "given": "An existing team, a 'PlanTier', and an initial subscription status",
      "when": "A new subscription is created for the team",
      "then": "A 'Subscription' record is created with a unique ID, linked to the team, with the specified 'plan' and 'status', a 'createdAt' timestamp, and optional 'stripeSubscriptionId' and 'nextBillingAt' are set."
    },
    {
      "given": "An existing subscription, an amount, and an 'InvoiceStatus'",
      "when": "A new invoice is generated for the subscription",
      "then": "An 'Invoice' record is created with a unique ID, linked to the subscription, with the specified 'amount' and 'status', a 'createdAt' timestamp, and optional 'stripeInvoiceId', 'paidAt', and 'pdfUrl' are null."
    },
    {
      "given": "An existing invoice with a 'status' other than 'PAID'",
      "when": "The invoice is successfully processed as paid",
      "then": "The 'status' of the 'Invoice' is updated to 'PAID' and 'paidAt' is set to the current timestamp."
    },
    {
      "given": "An existing user, a notification type, a channel, and optional payload data",
      "when": "A new notification is created for the user",
      "then": "A 'Notification' record is created with a unique ID, linked to the user, with the specified 'type', 'channel', and optional 'payload'. Its 'status' defaults to 'PENDING', and 'sentAt' and 'readAt' are initially null."
    },
    {
      "given": "An existing notification with 'status' 'PENDING'",
      "when": "The notification is successfully sent to the user",
      "then": "The 'status' of the 'Notification' is updated to 'SENT' and 'sentAt' is set to the current timestamp."
    },
    {
      "given": "An existing notification that has been sent (status 'SENT')",
      "when": "The user views or acknowledges the notification",
      "then": "The 'readAt' timestamp of the 'Notification' is set to the current time."
    },
    {
      "given": "The system supports defining roles and associating them with organizational units",
      "when": "A new role is defined or an existing role's scope is modified",
      "then": "The role can be explicitly scoped to a Team, a Workspace, or be designated as global (without a specific Team or Workspace association)"
    },
    {
      "given": "A Role and a Permission are defined within the system",
      "when": "An administrative action links one or more Permissions to a specific Role",
      "then": "The Role is granted the associated Permissions through a dedicated RolePermission relationship"
    },
    {
      "given": "A User and a Role exist in the system",
      "when": "The Role is assigned to the User",
      "then": "The User gains the capabilities defined by the assigned Role via the UserRoleRelation, strongly linked to both User and Role"
    },
    {
      "given": "Translations are available, some defined globally and others optionally scoped to a specific Workspace",
      "when": "Content needs to be displayed in a specific locale for a given Workspace",
      "then": "The system retrieves the Workspace-specific translation if available, otherwise it retrieves the global translation for that locale"
    },
    {
      "given": "The system's data models are designed to ensure referential integrity and prevent orphaned records",
      "when": "A non-core data model (i.e., not User, Team, or Workspace) is part of the system's schema",
      "then": "The non-core data model is directly linked via a foreign key to a User, Team, or Workspace, or it serves as a join/ledger table connected to a parent allocation"
    },
    {
      "given": "A PostgreSQL database instance",
      "when": "The Scribl migration script is executed",
      "then": "A schema named \"extensions\" should be created if it does not already exist"
    },
    {
      "given": "A PostgreSQL database instance and the 'extensions' schema exists",
      "when": "The Scribl migration script is executed",
      "then": "The 'pgcrypto' extension should be installed into the 'extensions' schema if it is not already installed"
    },
    {
      "given": "The 'pgcrypto' extension is installed in the 'extensions' schema",
      "when": "The Scribl migration script is executed",
      "then": "The 'gen_random_uuid()' function should be available within the 'extensions' schema"
    },
    {
      "given": "A PostgreSQL database instance",
      "when": "The Scribl migration script is executed",
      "then": "The 'pg_trgm' extension should be installed into the 'public' schema if it is not already installed"
    },
    {
      "given": "A PostgreSQL database instance",
      "when": "The Scribl migration script is executed",
      "then": "The 'btree_gist' extension should be installed into the 'public' schema if it is not already installed"
    },
    {
      "given": "The extension setup is complete",
      "when": "The Scribl migration script proceeds to its main migration section",
      "then": "The subsequent main migration operations should be initiated within a transaction block"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'user_role' ENUM creation is executed",
      "then": "The 'user_role' ENUM type should exist with values 'ADMIN', 'EDITOR', 'APPROVER', 'VIEWER'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'seat_type' ENUM creation is executed",
      "then": "The 'seat_type' ENUM type should exist with values 'STANDARD', 'ADMIN'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'content_type' ENUM creation is executed",
      "then": "The 'content_type' ENUM type should exist with values 'POST', 'ARTICLE', 'CAROUSEL'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'content_status' ENUM creation is executed",
      "then": "The 'content_status' ENUM type should exist with values 'DRAFT', 'SCHEDULED', 'PUBLISHED', 'ARCHIVED'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'schedule_status' ENUM creation is executed",
      "then": "The 'schedule_status' ENUM type should exist with values 'PENDING', 'COMPLETED', 'FAILED'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'approval_status' ENUM creation is executed",
      "then": "The 'approval_status' ENUM type should exist with values 'PENDING', 'APPROVED', 'REJECTED'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'plan_tier' ENUM creation is executed",
      "then": "The 'plan_tier' ENUM type should exist with values 'NORMAL', 'PRO', 'ENTERPRISE'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'invoice_status' ENUM creation is executed",
      "then": "The 'invoice_status' ENUM type should exist with values 'PENDING', 'PAID', 'FAILED', 'VOID'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'notification_channel' ENUM creation is executed",
      "then": "The 'notification_channel' ENUM type should exist with values 'IN_APP', 'EMAIL', 'SLACK', 'TEAMS'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'notification_status' ENUM creation is executed",
      "then": "The 'notification_status' ENUM type should exist with values 'PENDING', 'SENT', 'READ'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'webhook_status' ENUM creation is executed",
      "then": "The 'webhook_status' ENUM type should exist with values 'PENDING', 'PROCESSED', 'FAILED'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'publish_job_status' ENUM creation is executed",
      "then": "The 'publish_job_status' ENUM type should exist with values 'QUEUED', 'RUNNING', 'FAILED', 'SUCCESS', 'CANCELLED', 'DLQ'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'engagement_action' ENUM creation is executed",
      "then": "The 'engagement_action' ENUM type should exist with values 'LIKE', 'COMMENT', 'SHARE', 'CLICK'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'publish_platform' ENUM creation is executed",
      "then": "The 'publish_platform' ENUM type should exist with values 'LINKEDIN', 'X', 'INSTAGRAM', 'YOUTUBE', 'FACEBOOK'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'integration_type' ENUM creation is executed",
      "then": "The 'integration_type' ENUM type should exist with values 'SLACK', 'CRM', 'CALENDAR', 'SALESFORCE', 'HUBSPOT', 'UNSPLASH', 'PEXELS'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'support_priority' ENUM creation is executed",
      "then": "The 'support_priority' ENUM type should exist with values 'LOW', 'MEDIUM', 'HIGH', 'URGENT'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'support_status' ENUM creation is executed",
      "then": "The 'support_status' ENUM type should exist with values 'OPEN', 'PENDING', 'RESOLVED', 'CLOSED'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'compliance_status' ENUM creation is executed",
      "then": "The 'compliance_status' ENUM type should exist with values 'PASS', 'WARN', 'FAIL'"
    },
    {
      "given": "A PostgreSQL database environment",
      "when": "The idempotent script for 'plagiarism_engine' ENUM creation is executed",
      "then": "The 'plagiarism_engine' ENUM type should exist with values 'INTERNAL', 'EXTERNAL'"
    },
    {
      "given": "A new user wishes to register.",
      "when": "The user provides a unique email address.",
      "then": "A new 'users' record is created with a unique ID, the provided email, a default 'EDITOR' role, and current timestamps for creation and update."
    },
    {
      "given": "An authenticated user exists.",
      "when": "The user creates a new team with a unique name.",
      "then": "A new 'teams' record is created with a unique ID, the provided name, a generated slug, the user as owner, a 'NORMAL' plan, and a 'seat_count' of 1."
    },
    {
      "given": "An existing team and a user who is not yet a member of that team.",
      "when": "An authorized team administrator invites the user to the team with a specified role.",
      "then": "A 'team_members' record is created, linking the user and team, with the given role and an 'invited' status."
    },
    {
      "given": "A user has an 'invited' status in a 'team_members' record for a specific team.",
      "when": "The user accepts the team invitation.",
      "then": "The 'status' in the 'team_members' record is updated to an active status (e.g., 'active'), and 'accepted_at' is set."
    },
    {
      "given": "An existing team and an active team member.",
      "when": "A seat of a specific type is assigned to the team member.",
      "then": "A 'seats' record is created, linking the team and user, with the specified 'seat_type' and 'assigned_at' timestamp."
    },
    {
      "given": "An existing team.",
      "when": "A user within that team creates a new workspace with a unique name.",
      "then": "A 'workspaces' record is created, linked to the team, with the provided name and a generated slug."
    },
    {
      "given": "An existing user and an existing workspace.",
      "when": "An authorized user grants the user access to the workspace with a defined 'permission_set'.",
      "then": "A 'user_workspaces' record is created, linking the user and workspace, with the specified 'permission_set'."
    },
    {
      "given": "A user is already an active member of a specific team.",
      "when": "An attempt is made to add the same user to the same team again.",
      "then": "The system prevents the creation of a duplicate 'team_members' record due to the unique constraint."
    },
    {
      "given": "A user already has an active seat assignment for a specific team.",
      "when": "An attempt is made to assign another seat to the same user in the same team.",
      "then": "The system prevents the creation of a duplicate 'seats' record due to the unique constraint."
    },
    {
      "given": "A user already has an access entry for a specific workspace.",
      "when": "An attempt is made to grant the same user access to the same workspace again.",
      "then": "The system prevents the creation of a duplicate 'user_workspaces' record due to the unique constraint."
    },
    {
      "given": "A user record exists with associated team memberships, seats, and workspace access entries.",
      "when": "The user record is deleted.",
      "then": "All related 'team_members', 'seats', and 'user_workspaces' records for that user are automatically deleted due to cascading delete constraints."
    },
    {
      "given": "A team record exists with associated team members, seats, and workspaces.",
      "when": "The team record is deleted.",
      "then": "All related 'team_members', 'seats', and 'workspaces' records for that team are automatically deleted due to cascading delete constraints. (This also implicitly deletes associated 'user_workspaces' records for deleted workspaces)."
    },
    {
      "given": "An authenticated user belongs to a specific team and workspace.",
      "when": "The user creates a new content item specifying its type, title, body, and tags.",
      "then": "A new 'content_items' record is created with a unique ID, 'DRAFT' status, owner, team, workspace, and an initial version of 1."
    },
    {
      "given": "An existing content item with version 1 is available.",
      "when": "A user updates the content item's title or body, and provides a change reason.",
      "then": "A new 'content_versions' record is created linked to the content item, the 'content_item.version' is incremented, and 'content_item.current_version_id' is updated to the new version's ID."
    },
    {
      "given": "An existing content item and an uploaded image are available.",
      "when": "The user associates the image with the content item at a specified position.",
      "then": "A new 'content_media' record is created, linking the content item and the image with the given position."
    },
    {
      "given": "An existing content item and a file to be attached.",
      "when": "The user uploads the file and links it to the content item.",
      "then": "A new 'attachments' record is created storing the file's metadata (filename, content type, size, storage path) and a link to the content item."
    },
    {
      "given": "An authenticated user with administrative privileges for a workspace.",
      "when": "The user defines a new approval workflow by specifying a name and a sequence of approval steps.",
      "then": "A new 'approval_hierarchies' record is created for the workspace, storing the workflow name and its step configuration."
    },
    {
      "given": "A content item is in 'DRAFT' status and an approval hierarchy is defined for its workspace.",
      "when": "The user submits the content item for approval.",
      "then": "A new 'approvals' record is created linked to the content item and the specified approval hierarchy, with a 'PENDING' status."
    },
    {
      "given": "A content item has an active approval process in 'PENDING' status, and the current user is an assigned approver for the active step.",
      "when": "The approver approves the current step of the content item, optionally adding a comment.",
      "then": "An 'approval_transitions' record is created logging the approval, and the 'approvals.status' is updated to reflect the next step or 'APPROVED' if it's the final step."
    },
    {
      "given": "A content item has an active approval process in 'PENDING' status, and the current user is an assigned approver for the active step.",
      "when": "The approver rejects the current step of the content item, providing a mandatory comment.",
      "then": "An 'approval_transitions' record is created logging the rejection, the 'approvals.status' is updated to 'REJECTED', and the rejection comment is recorded."
    },
    {
      "given": "An existing content item is configured as a carousel.",
      "when": "The user adds a new slide to the carousel content item at a specific position, including its body content.",
      "then": "A new 'carousel_slides' record is created, linking to the content item with the specified position and body content."
    },
    {
      "given": "A user has a content item ready for publication and has linked at least one platform_profile.",
      "when": "The user creates a new schedule for the content item, specifying a future scheduled_at and a linked platform_profile.",
      "then": "A new entry is created in the 'schedules' table with status 'PENDING', and a corresponding 'publish_job' is created with status 'QUEUED' and run_at matching the scheduled_at."
    },
    {
      "given": "A publish_job exists with status 'QUEUED', an associated schedule, content_item, and platform_profile.",
      "when": "The publish_job's run_at time has passed, and the publishing worker picks up and processes the job.",
      "then": "The content item is successfully posted to the external platform, the 'publish_job''s status is updated to 'COMPLETED', 'published_at' is set, and a new 'platform_post' record is created with the external_post_id."
    },
    {
      "given": "A publish_job exists with status 'QUEUED' and attempt_count less than the maximum retry limit.",
      "when": "The publish_job's run_at time has passed, and the publishing worker attempts to process the job but encounters an error during external platform interaction.",
      "then": "A new 'job_attempt' record is created with error_text, the 'publish_job''s status is updated to 'FAILED_RETRYABLE', its 'attempt_count' is incremented, and 'next_run_at' for a retry is set."
    },
    {
      "given": "A user is logged into the application and wishes to connect a social media profile.",
      "when": "The user initiates the process to link a LinkedIn profile, authenticates successfully with LinkedIn, and grants necessary permissions.",
      "then": "A new entry is created in the 'linked_in_profiles' table, storing the linkedin_profile_id, display_name, encrypted access_token_enc, refresh_token_enc, and expires_at."
    },
    {
      "given": "A user has a content item ready for publication and has linked at least one platform_profile.",
      "when": "The user creates a new schedule for the content item, specifying an initial scheduled_at, a linked platform_profile, and a valid recurrence_json for daily publication.",
      "then": "A new entry is created in the 'schedules' table with status 'PENDING', recurrence_json populated, and next_run_at set to the calculated next occurrence."
    },
    {
      "given": "A content item exists in the system.",
      "when": "Analytics data is collected for that content item.",
      "then": "The analytics data, including metrics, should be recorded in the 'analytics' table and linked to the content item."
    },
    {
      "given": "A user interacts with a content item or an external post.",
      "when": "The user performs an engagement action (e.g., like, share, comment) related to the content or post.",
      "then": "A new engagement record should be created in the 'engagements' table, linking the user, the content/post, and the specific action taken."
    },
    {
      "given": "A user belongs to a specific workspace and has recorded engagement data.",
      "when": "An engagement feed is requested or scheduled for generation for that user within their workspace.",
      "then": "A personalized engagement feed (JSON) should be generated and stored in the 'engagement_feed' table, linked to the user and workspace, along with its generation timestamp."
    },
    {
      "given": "A workspace has various content and engagement data available for analysis.",
      "when": "The system evaluates this data to identify trending topics or signals.",
      "then": "Trending signals, including the topic, associated data (JSON), and a calculated score, should be recorded in the 'trending_signals' table for the respective workspace."
    },
    {
      "given": "A user within a workspace wishes to track a new competitor.",
      "when": "The competitor's account details are provided and added to the system.",
      "then": "A new competitor account record should be created in the 'competitor_accounts' table, including its external ID, name, and the workspace it belongs to."
    },
    {
      "given": "A competitor account is being tracked within a workspace.",
      "when": "The system performs a scheduled or manual snapshot of the competitor's performance metrics.",
      "then": "A new snapshot record should be created in the 'competitor_snapshots' table, containing detailed metrics and raw data for that competitor at the specific snapshot time."
    },
    {
      "given": "A user initiates an AI interaction",
      "when": "The AI model processes the prompt and generates a response",
      "then": "The system records the prompt, response, model, token usage, and estimated cost in `ai_prompts`"
    },
    {
      "given": "An AI interaction has been processed and recorded",
      "when": "The system updates the aggregated AI usage",
      "then": "The `ai_usage` table reflects the tokens used and an updated cost estimate for the user, workspace, or team"
    },
    {
      "given": "A system administrator wants to offer AI credit packages",
      "when": "A new AI credit pack is defined with specific plan, credits, currency, and price",
      "then": "The `ai_credit_packs` table stores the details of the new credit pack"
    },
    {
      "given": "A team or user is entitled to a certain amount of AI credits",
      "when": "Credits are allocated to the team or user",
      "then": "The `ai_credit_allocations` table shows the total and remaining credits for that entity"
    },
    {
      "given": "A change occurs to a user's or team's AI credit balance (e.g., usage, top-up)",
      "when": "The credit balance is updated",
      "then": "A record is added to the `ai_credit_ledger` detailing the delta, balance after, and reason for the change"
    },
    {
      "given": "A team wants to purchase additional AI credits",
      "when": "A credit pack is selected and a purchase is made",
      "then": "A `credit_topups` record is created, linking the team and pack, with the purchased amount and status"
    },
    {
      "given": "A user performs an action that contributes to a specific quota metric (e.g., number of AI calls per month)",
      "when": "The system processes the action",
      "then": "The `quota_counters` table is updated, incrementing the `consumed` amount for the relevant team, workspace, metric, and period"
    },
    {
      "given": "A user starts or completes a guided help tour",
      "when": "The user interacts with the help tour",
      "then": "The `help_tours` table records the user's progress, including completion status and key for the tour"
    },
    {
      "given": "The application needs to support a new language",
      "when": "A new locale is added to the system",
      "then": "The `locales` table contains the new locale's code and name"
    },
    {
      "given": "The application needs to display text in a specific locale",
      "when": "A request is made for content associated with a key and locale",
      "then": "The `translations` table provides the localized text for the given key, locale, and optional workspace"
    },
    {
      "given": "A workspace exists and is configured for integrations.",
      "when": "A user creates a new integration of a specific type with valid configuration.",
      "then": "An 'integrations' record is created, associated with the workspace, with an initial status and the provided configuration."
    },
    {
      "given": "An active integration exists.",
      "when": "An external system or internal process triggers an event related to the integration.",
      "then": "An 'integration_events' record is created, linked to the integration, with the event type, payload, and a 'PENDING' status."
    },
    {
      "given": "A workspace exists.",
      "when": "A user creates a new API key, providing a name, desired scopes, and optional rate limits.",
      "then": "An 'api_keys' record is created, associated with the workspace, with a generated key hash, specified scopes, rate limits, and an 'active' status."
    },
    {
      "given": "An active API key exists for a workspace.",
      "when": "An external application successfully authenticates and uses the API key.",
      "then": "The 'last_used_at' timestamp for that API key is updated."
    },
    {
      "given": "A user is logged into a workspace and provides a file path, import type, and optional parameters for an import operation.",
      "when": "The user initiates an import job.",
      "then": "An 'import_jobs' record is created with a 'PENDING' status, linked to the user and workspace, including the file path, type, and parameters."
    },
    {
      "given": "An import job exists with a 'RUNNING' status.",
      "when": "The import process successfully completes.",
      "then": "The 'import_jobs' status is updated to 'COMPLETED' and the 'completed_at' timestamp is set."
    },
    {
      "given": "A user is logged into a workspace and specifies output format, file path, and optional parameters for an export operation.",
      "when": "The user initiates an export job.",
      "then": "An 'export_jobs' record is created with a 'PENDING' status, linked to the user and workspace, including the file path, format, and parameters."
    },
    {
      "given": "An export job exists with a 'RUNNING' status.",
      "when": "The export process successfully completes.",
      "then": "The 'export_jobs' status is updated to 'COMPLETED' and the 'completed_at' timestamp is set."
    },
    {
      "given": "An administrator is managing system configurations.",
      "when": "A new stock image provider is added or an existing one is updated with its configuration.",
      "then": "A 'stock_image_providers' record is created or updated with the provider's name and configuration."
    },
    {
      "given": "A stock image provider is configured and an image is requested by a user.",
      "when": "The system fetches an image from the provider and it's intended for caching.",
      "then": "A 'stock_image_cache' record is created, linked to the provider and user, storing the provider's image ID and metadata."
    },
    {
      "given": "A team exists and selects a specific plan tier.",
      "when": "A new subscription is created for the team.",
      "then": "A 'subscriptions' record is created, linked to the team, with the chosen plan tier, an initial status, and the next billing date."
    },
    {
      "given": "An active subscription exists for a team.",
      "when": "A billing period ends or a payment is due for the subscription.",
      "then": "An 'invoices' record is created, linked to the subscription, with the calculated amount, a 'PENDING' status, and a PDF URL if available."
    },
    {
      "given": "An invoice exists with a 'PENDING' status.",
      "when": "Payment for the invoice is successfully received and confirmed.",
      "then": "The 'invoices' status is updated to 'PAID' and the 'paid_at' timestamp is set."
    },
    {
      "given": "The system is configured to receive webhook events from an external provider.",
      "when": "A webhook event is received by the system with a payload and optional signature.",
      "then": "A 'webhook_events' record is created with the provider, event type, payload, signature, and a 'PENDING' status."
    },
    {
      "given": "A 'webhook_events' record exists with a 'PENDING' status.",
      "when": "The system attempts to process the webhook event.",
      "then": "The 'webhook_events' status is updated to 'PROCESSED' or 'FAILED', the 'processed_at' timestamp is set, and 'retries' may be incremented on failure."
    },
    {
      "given": "A user performs an auditable action within the system",
      "when": "The system processes the action",
      "then": "An entry is created in the \"audit_logs\" table, detailing the actor, action, target, and metadata"
    },
    {
      "given": "A user from a specific workspace needs assistance",
      "when": "The user submits a support ticket with a subject and body",
      "then": "A new entry is created in the \"support_tickets\" table with an initial status, priority, and requester details"
    },
    {
      "given": "An existing support ticket",
      "when": "An authorized support agent updates its status or assigns it to another agent",
      "then": "The \"support_tickets\" entry is updated with the new status, assigned agent, and an updated timestamp"
    },
    {
      "given": "An administrator for a specific workspace",
      "when": "The administrator defines a new data retention policy with a name and a set of rules",
      "then": "A new entry is created in the \"retention_policies\" table for that workspace"
    },
    {
      "given": "A specific team and a geographic region",
      "when": "An administrator configures data residency rules for that team within the specified region",
      "then": "A new entry is created in the \"region_data_config\" table, detailing the region and its associated data residency JSON"
    },
    {
      "given": "A user performs an action that triggers a security concern (e.g., failed login, unusual activity)",
      "when": "The system detects the security-related event",
      "then": "A new entry is created in the \"security_events\" table, capturing the user, event type, and relevant metadata"
    },
    {
      "given": "An administrator with permission to manage system capabilities",
      "when": "The administrator defines a new permission with a unique code and description",
      "then": "A new entry is created in the \"permissions\" table"
    },
    {
      "given": "An administrator with permission to manage user access",
      "when": "The administrator creates a new role with a name and description, optionally scoped to a team or workspace",
      "then": "A new entry is created in the \"roles\" table"
    },
    {
      "given": "An existing role and an existing permission",
      "when": "An administrator assigns the permission to the role",
      "then": "A new entry is created in the \"role_permissions\" table, linking the role and permission"
    },
    {
      "given": "An existing user and an existing role",
      "when": "An administrator assigns the role to the user, optionally defining a scope",
      "then": "A new entry is created in the \"user_roles\" table, linking the user, role, and its defined scope"
    },
    {
      "given": "A team administrator is logged in and an identity provider (e.g., Okta, Azure AD) configuration is defined.",
      "when": "The administrator attempts to link this identity provider to their team via the application settings.",
      "then": "A new 'idp_links' record is created, successfully associating the team with the specified identity provider."
    },
    {
      "given": "A user is logged into the application and is a member of a team.",
      "when": "They navigate to the 'Brand Voices' section and create a new brand voice, providing a name, description, and JSON configuration for the voice.",
      "then": "A 'brand_voices' record is created in the database, uniquely identified and linked to their team."
    },
    {
      "given": "A new user has registered for the application and is proceeding through the initial onboarding process.",
      "when": "The user inputs their professional goals and selects an existing brand voice from a list of available options for their team.",
      "then": "An 'onboarding_profiles' record is created, linking the user, their team, their specified goals, and the chosen brand voice, with an 'onboarded_at' timestamp."
    },
    {
      "given": "A user is logged in, belongs to a team, and has access to a workspace.",
      "when": "They create a new content template, specifying its title, type, and defining its structure via a JSON schema.",
      "then": "A 'templates' record is created, owned by the user and associated with their team and workspace, with a default 'private' shared scope."
    },
    {
      "given": "A user has created a template within their workspace and wishes to make it available to another workspace.",
      "when": "The user initiates a share action for the template, targeting a specific other workspace.",
      "then": "A 'template_shares' record is created, linking the original template to the target workspace and recording the user who performed the sharing."
    },
    {
      "given": "A user has created a template and intends to offer it for sale or public use in a marketplace.",
      "when": "They publish the template to the marketplace, providing details such as pricing information.",
      "then": "A 'template_marketplace_items' record is created, associating the template with the publisher, specified pricing, and a 'listed' status, along with a 'listed_at' timestamp."
    },
    {
      "given": "A content item has been created and is marked for plagiarism analysis.",
      "when": "The system automatically or manually initiates a plagiarism check using a configured engine.",
      "then": "A 'plagiarism_checks' record is created, storing the result JSON, a calculated score, and the 'checked_at' timestamp for the content item."
    },
    {
      "given": "A content item exists and is subject to organizational or regulatory compliance rules.",
      "when": "The system performs a compliance check of a specific type on the content item.",
      "then": "A 'content_compliance' record is created, capturing the check type, result JSON, status of compliance, and the 'checked_at' timestamp for the content item."
    },
    {
      "given": "A user is logged in, accessing a specific workspace, and requires a report of its data.",
      "when": "The user requests an export of a report, specifying the desired format (e.g., CSV, PDF) and any relevant parameters.",
      "then": "A 'report_exports' record is created with a 'pending' status, detailing the requestor, workspace, format, parameters, and the 'requested_at' timestamp."
    },
    {
      "given": "A 'report_exports' record exists with a 'pending' status, indicating an outstanding export request.",
      "when": "The system successfully processes the export request, generates the report file, and stores it in the specified location.",
      "then": "The 'report_exports' record is updated to include the 'file_path', its 'status' is changed to 'completed', and the 'completed_at' timestamp is set."
    },
    {
      "given": "The public.update_updated_at_column() function exists, is defined as SECURITY DEFINER, and a table has an 'updated_at' column.",
      "when": "A row in that table is updated.",
      "then": "The 'updated_at' column of the row should be automatically set to the current timestamp (NOW()), and the function should execute with a cleared 'search_path' for security."
    },
    {
      "given": "A database environment where some tables may or may not have an 'updated_at' column, and the 'update_<table_name>_updated_at' triggers may or may not already exist.",
      "when": "The idempotent script to attach 'updated_at' triggers is executed.",
      "then": "For each table with an 'updated_at' column, a 'BEFORE UPDATE' trigger named 'update_<table_name>_updated_at' should be created if it doesn't already exist, executing 'public.update_updated_at_column()'."
    },
    {
      "given": "The public.update_search_tsv() function exists, is defined as SECURITY DEFINER, and a 'content_items' table.",
      "when": "A new 'content_items' row is inserted or an existing one is updated.",
      "then": "The 'search_tsv' column should be populated by combining 'title' (weight 'A'), 'body' (weight 'B'), and 'tags' (weight 'C') into a 'simple' tsvector, and the function should execute with a cleared 'search_path' for security."
    },
    {
      "given": "The public.update_search_tsv() function exists, is defined as SECURITY DEFINER, and a 'templates' table.",
      "when": "A new 'templates' row is inserted or an existing one is updated.",
      "then": "The 'search_tsv' column should be populated by combining 'title' (weight 'A') and 'schema_json' (weight 'B') into a 'simple' tsvector, and the function should execute with a cleared 'search_path' for security."
    },
    {
      "given": "A database environment where 'trg_content_items_search_tsv' and 'trg_templates_search_tsv' triggers may or may not already exist.",
      "when": "The idempotent script to attach 'search_tsv' triggers is executed.",
      "then": "A 'BEFORE INSERT OR UPDATE' trigger named 'trg_content_items_search_tsv' should be created on 'content_items' if it doesn't already exist, and a 'BEFORE INSERT OR UPDATE' trigger named 'trg_templates_search_tsv' should be created on 'templates' if it doesn't already exist, both executing 'public.update_search_tsv()'."
    },
    {
      "given": "A content_item exists, whose 'current_version_id' is linked to an existing content_version",
      "when": "The linked content_version is deleted",
      "then": "The 'current_version_id' of the content_item should be set to NULL"
    },
    {
      "given": "A content_item exists, created by a specific user",
      "when": "That user is deleted",
      "then": "The 'created_by' field of the content_item should be set to NULL"
    },
    {
      "given": "A content_item exists, last updated by a specific user",
      "when": "That user is deleted",
      "then": "The 'updated_by' field of the content_item should be set to NULL"
    },
    {
      "given": "A publish_job exists, created by a specific user",
      "when": "That user is deleted",
      "then": "The 'created_by' field of the publish_job should be set to NULL"
    },
    {
      "given": "An approval record exists, created by a specific user",
      "when": "That user is deleted",
      "then": "The 'created_by' field of the approval record should be set to NULL"
    },
    {
      "given": "An approval record exists, last updated by a specific user",
      "when": "That user is deleted",
      "then": "The 'updated_by' field of the approval record should be set to NULL"
    },
    {
      "given": "An approval record exists, assigned to a specific user as 'approver_id'",
      "when": "That user is deleted",
      "then": "The 'approver_id' field of the approval record should be set to NULL"
    },
    {
      "given": "A workspace exists, and there are platform_profiles associated with this workspace",
      "when": "The workspace is deleted",
      "then": "All platform_profiles associated with that workspace should also be deleted"
    },
    {
      "given": "A publish_job exists, linked to an existing schedule",
      "when": "The linked schedule is deleted",
      "then": "The 'schedule_id' of the publish_job should be set to NULL"
    },
    {
      "given": "A template exists, owned by a specific user",
      "when": "That user is deleted",
      "then": "The 'owner_id' field of the template should be set to NULL"
    },
    {
      "given": "the application performs frequent lookups on core entities related to users, teams, and content items",
      "when": "queries are executed to find users by role, teams by owner or slug, workspaces by team, team members by user or team, content items by owner, team, workspace, status, type, or creation date",
      "then": "these common lookup operations are significantly accelerated by dedicated B-tree indexes on the relevant columns."
    },
    {
      "given": "the application manages content versioning and associated media assets",
      "when": "queries are performed to retrieve content versions by content item or author, or content media by content item or image",
      "then": "these retrieval operations are fast and efficient, facilitating content history and asset management."
    },
    {
      "given": "the application processes schedules and manages publishing job lifecycles",
      "when": "users or system services query schedules by scheduled time, status, or content item, or publish jobs by status, run time, content item, or associated schedule",
      "then": "these workflow-critical lookups are optimized for performance, ensuring timely processing and monitoring."
    },
    {
      "given": "the application tracks user analytics and engagements within content",
      "when": "data analysts or reporting tools query analytics by content item or recorded time, or user engagements by user, content item, or action",
      "then": "data retrieval for reporting and insights is efficient, allowing for quick analysis of user behavior."
    },
    {
      "given": "the application integrates AI features and maintains a comprehensive audit trail of system activities",
      "when": "administrators or system components query AI prompts or usage by user, team, or creation date, or audit logs by actor or target entity type and ID",
      "then": "these operational, AI-related, and security-related data retrievals are performed quickly and efficiently."
    },
    {
      "given": "the system implements approval processes and manages platform integrations via platform profiles",
      "when": "users or services query approvals by approver, creator, or updater, or platform profiles by workspace",
      "then": "these specific data access patterns are optimized for speed, enhancing administrative and integration capabilities."
    },
    {
      "given": "the application needs to establish a robust system for delivering notifications to users",
      "when": "the system stores new notifications or retrieves existing notifications for a specific user ID or by notification status",
      "then": "a dedicated 'notifications' table is created with B-tree indexes on 'user_id' and 'status' to ensure efficient storage and retrieval of notification data."
    },
    {
      "given": "the system stores complex, semi-structured data in JSONB fields, uses arrays for tags, and requires full-text search capabilities",
      "when": "users or services perform queries or searches within 'content_items.metadata', 'templates.schema_json', 'competitor_snapshots.metrics_json', 'ai_prompts.context_json', 'integration_events.payload', 'content_items.tags', or execute full-text searches on 'content_items.search_tsv' or 'templates.search_tsv'",
      "then": "these advanced search and query operations are highly performant due to the implementation of GIN (Generalized Inverted Index) indexes."
    },
    {
      "given": "the system processes critical publish jobs that require idempotent submission to prevent duplicates",
      "when": "a new publish job is submitted with an 'idempotency_key' for a specific workspace or platform profile",
      "then": "the system ensures that only one such job is processed by enforcing uniqueness based on 'workspace_id' or 'platform_profile_id' combined with the 'idempotency_key' (when present), preventing accidental re-publishing."
    },
    {
      "given": "the system continuously manages a queue of publish jobs and their leases",
      "when": "the job scheduler attempts to retrieve pending 'QUEUED' jobs or identifies jobs with expired leases",
      "then": "the system can quickly select jobs by 'priority' and 'run_at' and efficiently manage job leases by 'lease_expires_at', optimizing job processing throughput."
    },
    {
      "given": "Existing rows in 'content_items' have a NULL 'search_tsv' value",
      "when": "The 'updated_at' column for these rows is set to the current timestamp",
      "then": "The 'search_tsv' column for these 'content_items' rows should be populated by the associated trigger"
    },
    {
      "given": "Existing rows in 'templates' have a NULL 'search_tsv' value",
      "when": "The 'updated_at' column for these rows is set to the current timestamp",
      "then": "The 'search_tsv' column for these 'templates' rows should be populated by the associated trigger"
    },
    {
      "given": "The 'permissions' table exists",
      "when": "A predefined set of permissions is inserted with an 'ON CONFLICT (code) DO NOTHING' clause",
      "then": "The 'permissions' table should contain all predefined permissions, and no duplicates should be created if they already exist"
    },
    {
      "given": "The 'locales' table exists",
      "when": "A predefined set of locales is inserted with an 'ON CONFLICT (code) DO NOTHING' clause",
      "then": "The 'locales' table should contain all predefined locales, and no duplicates should be created if they already exist"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'users_select_own' is configured on the 'public.users' table",
      "when": "A user attempts to SELECT data from the 'public.users' table",
      "then": "The user should only be able to retrieve rows where the 'id' matches their authenticated 'auth.uid()'"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'users_update_own' is configured on the 'public.users' table",
      "when": "A user attempts to UPDATE data in the 'public.users' table",
      "then": "The user should only be able to update rows where the 'id' matches their authenticated 'auth.uid()', and the update should ensure the 'id' remains theirs"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'content_items_select_owner' is configured on the 'public.content_items' table",
      "when": "A user attempts to SELECT data from the 'public.content_items' table",
      "then": "The user should only be able to retrieve rows where the 'owner_id' matches their authenticated 'auth.uid()'"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'content_items_insert_owner' is configured on the 'public.content_items' table",
      "when": "A user attempts to INSERT data into the 'public.content_items' table",
      "then": "The user should only be able to insert rows where the 'owner_id' matches their authenticated 'auth.uid()'"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'content_items_update_owner' is configured on the 'public.content_items' table",
      "when": "A user attempts to UPDATE data in the 'public.content_items' table",
      "then": "The user should only be able to update rows where the 'owner_id' matches their authenticated 'auth.uid()', and the update should ensure the 'owner_id' remains theirs"
    },
    {
      "given": "A Row Level Security (RLS) policy named 'content_items_delete_owner' is configured on the 'public.content_items' table",
      "when": "A user attempts to DELETE data from the 'public.content_items' table",
      "then": "The user should only be able to delete rows where the 'owner_id' matches their authenticated 'auth.uid()'"
    },
    {
      "given": "A database with a 'team_members' table and a 'users' table",
      "when": "A membership-based RLS policy is enabled on relevant tables to check if the user exists in 'team_members' for the requested team/workspace",
      "then": "The user should only be able to access data for workspaces where they are a member, and data for other workspaces should be restricted"
    },
    {
      "given": "RLS policies have been reviewed and tested",
      "when": "The 'ALTER TABLE ... ENABLE ROW LEVEL SECURITY;' commands are executed for 'users', 'content_items', 'templates', 'workspaces', 'ai_prompts', 'ai_usage', and 'subscriptions' tables",
      "then": "Row Level Security should be activated on these specified tables, preparing the database to enforce RLS policies"
    },
    {
      "given": "A user attempts to sign in to Scribl using LinkedIn OAuth",
      "when": "The LinkedIn OAuth flow completes successfully, providing necessary user details",
      "then": "A 'LinkedInProfile' record should be created or updated, a corresponding 'User' record should be created or retrieved, and the user should be assigned an appropriate 'Team' and 'Workspace' context"
    },
    {
      "given": "A 'ContentItem' has been created and is marked as not requiring approval",
      "when": "The 'ContentItem' is scheduled for publication to LinkedIn, and the system processes the scheduled publication",
      "then": "A 'PublishJob' should be enqueued, a background worker should process the job by calling the LinkedIn API, the 'PublishJob.publishedAt' timestamp should be recorded, and the 'ContentItem' status should be updated to 'published'"
    },
    {
      "given": "A 'ContentItem' has been created, marked as requiring approval, and has been successfully approved by an authorized user",
      "when": "The approved 'ContentItem' is scheduled for publication to LinkedIn, and the system processes the scheduled publication",
      "then": "A 'PublishJob' should be enqueued, a background worker should process the job by calling the LinkedIn API, the 'PublishJob.publishedAt' timestamp should be recorded, and the 'ContentItem' status should be updated to 'published'"
    },
    {
      "given": "A user wants to authenticate via LinkedIn",
      "when": "They request to start LinkedIn OAuth",
      "then": "The system redirects the user to LinkedIn for authorization"
    },
    {
      "given": "A user has authorized on LinkedIn and been redirected back with a code",
      "when": "The system receives the LinkedIn OAuth callback with an authorization code",
      "then": "The system exchanges the code, creates/merges User and LinkedInProfile, and responds with JWT/session and User summary"
    },
    {
      "given": "The application is in development mode",
      "when": "A request is made to create a demo/test user",
      "then": "The system creates a demo/test user and provides authentication"
    },
    {
      "given": "A user is undergoing the onboarding process",
      "when": "They submit progress for a specific onboarding step",
      "then": "The system saves the progress and updates the user's preferences"
    },
    {
      "given": "A user has started the onboarding process",
      "when": "A request is made to retrieve their onboarding progress",
      "then": "The system returns the current onboarding progress for the user"
    },
    {
      "given": "Content items exist for a workspace with various statuses",
      "when": "A request is made to get a paginated list of content items with filters (workspaceId, status, query)",
      "then": "The system returns a paginated list of content items matching the filters"
    },
    {
      "given": "A user wants to create a new content item",
      "when": "They make a request to create a content item with required details (workspaceId, type, title, body, tags)",
      "then": "The system creates and stores the new content item"
    },
    {
      "given": "A specific content item exists",
      "when": "A request is made to retrieve that content item by its ID",
      "then": "The system returns the details of the requested content item"
    },
    {
      "given": "A specific content item exists",
      "when": "A request is made to update that content item by its ID with partial data",
      "then": "The system updates the specified fields of the content item"
    },
    {
      "given": "A specific content item exists",
      "when": "A request is made to duplicate that content item by its ID",
      "then": "The system creates a new content item that is a copy of the original"
    },
    {
      "given": "A specific content item exists",
      "when": "A request is made to create a new version for it with a new body and label",
      "then": "The system creates and stores a new version for the content item"
    },
    {
      "given": "A specific content item has multiple versions",
      "when": "A request is made to retrieve all versions of that content item",
      "then": "The system returns a list of all versions associated with the content item"
    },
    {
      "given": "Templates exist for a given workspace",
      "when": "A request is made to retrieve templates for a specific workspace",
      "then": "The system returns a list of templates for that workspace"
    },
    {
      "given": "A user wants to create a new template",
      "when": "They make a request to create a new template",
      "then": "The system creates and stores the new template"
    },
    {
      "given": "A specific template exists",
      "when": "A request is made to share the template to a target workspace",
      "then": "The system shares the template with the specified target workspace"
    },
    {
      "given": "A user wants to generate AI content",
      "when": "They make a request to generate AI content with a prompt and context",
      "then": "The system generates content variations, logs the prompt and usage, enforces per-plan quotas, and returns the generated content and costs"
    },
    {
      "given": "A user has used the AI assistant",
      "when": "A request is made to check the AI usage for that user",
      "then": "The system returns the AI usage data for quota checks"
    },
    {
      "given": "A user is interacting with the chat canvas in a workspace",
      "when": "A request is made to save the current session state as a snapshot for a workspace",
      "then": "The system saves the chat canvas session state"
    },
    {
      "given": "Snapshots of chat canvas session states exist for a workspace",
      "when": "A request is made to retrieve snapshots for a workspace",
      "then": "The system returns the saved chat canvas session states"
    },
    {
      "given": "A content item is ready to be scheduled for publishing",
      "when": "A request is made to create a new schedule for the content item",
      "then": "The system creates a Schedule entry and enqueues a PublishJob with QUEUED status"
    },
    {
      "given": "Schedules exist for a workspace within a certain time range",
      "when": "A request is made to retrieve schedules for a workspace within a specified range",
      "then": "The system returns a list of schedules matching the criteria"
    },
    {
      "given": "A content item is ready to be published to LinkedIn",
      "when": "A request is made to publish a specific content item to a LinkedIn profile",
      "then": "The system creates a PublishJob and triggers a worker to process it"
    },
    {
      "given": "A content item is ready for approval",
      "when": "A request is made to submit the content item for approval",
      "then": "The system creates an approval request for the content item"
    },
    {
      "given": "An approval request exists for a content item",
      "when": "A request is made to update the status of an approval request (e.g., APPROVED, REJECTED) with comments",
      "then": "The system updates the status and comments of the specified approval request"
    },
    {
      "given": "There are posts available for engagement in a workspace",
      "when": "A request is made to retrieve an engagement feed for a workspace with filters",
      "then": "The system returns a feed of posts suitable for engagement"
    },
    {
      "given": "A user wants to perform an engagement action on an external post",
      "when": "They make a request to perform a like, comment, or share action on an external post using a LinkedInProfile token",
      "then": "The system performs the specified engagement action via the LinkedIn API"
    },
    {
      "given": "Opportunities exist for a workspace within a certain time range",
      "when": "A request is made to retrieve opportunities for a workspace within a specified range",
      "then": "The system returns a list of opportunities matching the criteria"
    },
    {
      "given": "The opportunity data might be stale",
      "when": "A request is made to manually refresh opportunities",
      "then": "The system enqueues a background job to refresh opportunity data"
    },
    {
      "given": "Analytics data exists for a workspace",
      "when": "A request is made to retrieve an analytics overview for a workspace within a specified range",
      "then": "The system returns aggregated analytics data for the workspace"
    },
    {
      "given": "Analytics data exists for a specific content item",
      "when": "A request is made to retrieve analytics for that content item",
      "then": "The system returns detailed analytics data for the content item"
    },
    {
      "given": "A Stripe webhook event occurs (e.g., invoice.payment_succeeded)",
      "when": "The system receives a Stripe webhook notification",
      "then": "The system handles the event idempotently, verifies the signature, persists it as a WebhookEvent, and marks it as processed"
    },
    {
      "given": "A team has an active subscription",
      "when": "A request is made to retrieve subscription details for that team",
      "then": "The system returns the subscription information for the specified team"
    },
    {
      "given": "A team wants to change its subscription plan",
      "when": "A request is made to upgrade a team's billing plan",
      "then": "The system calls the Stripe API to update the subscription plan"
    },
    {
      "given": "The system is running",
      "when": "An admin requests a health check",
      "then": "The system returns its liveness status and dependency check results"
    },
    {
      "given": "A publish job previously failed",
      "when": "An admin requests to retry a specific publish job",
      "then": "The system re-enqueues or retries the specified publish job"
    },
    {
      "given": "A webhook event is received by the system",
      "when": "The system processes the incoming webhook",
      "then": "The system verifies the signature, handles the event idempotently, persists the event in WebhookEvent, and marks it as processed"
    },
    {
      "given": "A PublishJob is enqueued",
      "when": "A worker dequeues a PublishJob from the 'publish-queue'",
      "then": "The worker processes the job respecting concurrency, ensures idempotency, validates LinkedIn token, refreshes it if needed, and calls LinkedIn API with retries"
    },
    {
      "given": "A heavy AI task is initiated",
      "when": "The AI task is enqueued to the 'ai-queue'",
      "then": "The worker processes the AI task with longer timeouts and retry/backoff policies"
    },
    {
      "given": "A worker is processing jobs that interact with external APIs (e.g., LinkedIn, AI provider)",
      "when": "The worker makes an external API call",
      "then": "The worker respects per-account/per-team rate limits"
    },
    {
      "given": "A background job execution fails",
      "when": "The worker attempts to re-process the failed job",
      "then": "The worker applies an exponential backoff with jitter, respects max attempts, and records JobAttempt records"
    },
    {
      "given": "A background job repeatedly fails",
      "when": "The system detects repeated failures for a job",
      "then": "The system escalates the issue via PagerDuty"
    },
    {
      "given": "A PublishJob has completed successfully",
      "when": "The system processes the successful job completion",
      "then": "PublishJob.status is updated to COMPLETED, publishedAt is set, ContentItem.status is updated to PUBLISHED, and an Analytics placeholder event is created"
    },
    {
      "given": "A PublishJob has failed an attempt",
      "when": "The system processes the failed job",
      "then": "attemptCount for the PublishJob is incremented, lastError is set, a JobAttempt row is created, and the job is re-enqueued with backoff"
    },
    {
      "given": "A PublishJob has failed multiple times, reaching its attempt limit",
      "when": "The system processes the failed job",
      "then": "attemptCount for the PublishJob is incremented, lastError is set, a JobAttempt row is created, and the PublishJob.status is marked as FAILED"
    },
    {
      "given": "Data is stored in the PostgreSQL database",
      "when": "The system performs queries based on userId, workspaceId, status, scheduledAt, or createdAt",
      "then": "The queries utilize existing indexes for efficient retrieval"
    },
    {
      "given": "Data is stored in JSONB fields",
      "when": "The system filters data using these JSONB fields",
      "then": "The queries utilize GIN indexes for efficient filtering"
    },
    {
      "given": "Content is stored in the database",
      "when": "A user performs a full-text search",
      "then": "The search uses Postgres tsvector + GIN indexes for relevant results"
    },
    {
      "given": "Audit logs, AI prompts, competitor snapshots, or webhook events are generated",
      "when": "These time-series data are stored in the database",
      "then": "The data is stored in time-partitioned tables for improved performance and management"
    },
    {
      "given": "A LinkedIn access token or refresh token is received",
      "when": "The system stores the token in the database",
      "then": "The token is encrypted using KMS before being written to accessTokenEnc or refreshTokenEnc"
    },
    {
      "given": "A User or ContentItem is marked for deletion",
      "when": "The system processes the deletion request",
      "then": "The 'deletedAt' field is set, and the record is not physically removed from the database"
    },
    {
      "given": "Old snapshots or job attempts exist in the database",
      "when": "The retention policy is enforced (e.g., after 13 months)",
      "then": "The old data is either purged or archived to S3"
    },
    {
      "given": "A user attempts to log in",
      "when": "The user authenticates via LinkedIn OAuth",
      "then": "A session is established using Supabase or a JWT with rotated keys"
    },
    {
      "given": "An enterprise user attempts to log in using SSO",
      "when": "The user authenticates via SAML/OIDC through the configured Identity Provider",
      "then": "The user is successfully authenticated, utilizing the encrypted IdP configuration"
    },
    {
      "given": "A user attempts to perform an action",
      "when": "The backend enforces Role-Based Access Control (RBAC)",
      "then": "The action is permitted or denied based on the UserRole and per-resource permission sets"
    },
    {
      "given": "The system needs to access provider keys (OpenAI, Stripe, LinkedIn)",
      "when": "The system retrieves these keys",
      "then": "The keys are securely fetched from a secret manager (AWS/GCP Secrets Manager)"
    },
    {
      "given": "A user requests their personal data",
      "when": "The system processes a GET /api/users/:id/export request",
      "then": "The user's data is exported to satisfy GDPR requirements"
    },
    {
      "given": "A user requests their personal data to be deleted",
      "when": "The system processes a DELETE /api/users/:id request",
      "then": "The user's data is purged through defined workflows to satisfy GDPR requirements"
    },
    {
      "given": "A user or team makes repeated API calls (e.g., AI calls, LinkedIn calls)",
      "when": "The system detects requests exceeding predefined rate limits",
      "then": "The subsequent requests are throttled to prevent abuse"
    },
    {
      "given": "An error occurs in the system",
      "when": "The error is captured",
      "then": "The error is reported to Sentry with environment tags (teamId, workspaceId, requestId)"
    },
    {
      "given": "The system is operational",
      "when": "Various operations occur (HTTP requests, queue activity, publishes, AI usage)",
      "then": "Prometheus metrics (e.g., http_request_duration_seconds, queue_length, publish_success_rate, ai_tokens_used) are exported"
    },
    {
      "given": "The system performs an operation",
      "when": "A log event is generated",
      "then": "The log is emitted as structured JSON containing correlation IDs and stored in a central store"
    },
    {
      "given": "A user initiates an action that involves multiple services (API, AI provider, publish job)",
      "when": "The action propagates through the services",
      "then": "OpenTelemetry spans are generated to trace the entire distributed flow"
    },
    {
      "given": "The publish pipeline experiences sustained errors",
      "when": "The error rate exceeds a defined threshold",
      "then": "An alert is sent to PagerDuty indicating a potential outage"
    },
    {
      "given": "A Stripe webhook fails",
      "when": "The failure is detected by the system",
      "then": "An alert is sent to PagerDuty due to potential billing impact"
    },
    {
      "given": "The database experiences a spike in connections or a high error rate",
      "when": "These abnormal conditions are detected",
      "then": "An alert is sent to PagerDuty to notify operations"
    },
    {
      "given": "Business logic for content lifecycle, approvals, or AI prompt generation is implemented",
      "when": "Unit tests are executed",
      "then": "The core business logic functions as expected"
    },
    {
      "given": "Endpoints and database interactions are implemented, including the schedule-to-publish flow",
      "when": "Integration tests are executed against a test DB (with mocked LinkedIn)",
      "then": "The system components integrate correctly and the end-to-end flow functions"
    },
    {
      "given": "Integrations with external services like Stripe or LinkedIn, or AI responses are defined",
      "when": "Contract tests are executed (with mocks for external services and schema validation for AI)",
      "then": "The system adheres to the external service contracts and AI response schemas"
    },
    {
      "given": "A complete user journey from onboarding to publishing content",
      "when": "End-to-End (E2E) tests are executed (with mocked external calls in CI)",
      "then": "The entire user workflow functions correctly from an end-user perspective"
    },
    {
      "given": "The system is under simulated publish bursts or AI-heavy usage",
      "when": "Load tests are executed using k6 or Gatling",
      "then": "The system maintains expected performance and stability under load"
    },
    {
      "given": "New code is developed",
      "when": "SAST, DAST, and dependency scanning are performed",
      "then": "Potential security vulnerabilities and outdated dependencies are identified and addressed"
    },
    {
      "given": "A feature branch is pushed to GitHub",
      "when": "The GitHub Actions CI pipeline is triggered",
      "then": "Linting, unit tests, migrations check, prisma generate, build, and integration tests are executed, providing immediate feedback"
    },
    {
      "given": "A feature branch has passed CI checks",
      "when": "The pipeline deploys the changes to staging",
      "then": "Smoke tests are run to verify basic functionality on the staging environment"
    },
    {
      "given": "Changes are ready for production deployment",
      "when": "A manual/gated production deployment is initiated",
      "then": "Migration approvals are required before deployment proceeds"
    },
    {
      "given": "Schema changes are made in the development environment",
      "when": "A developer runs `prisma migrate dev --create-only`",
      "then": "A new SQL migration file is generated for review"
    },
    {
      "given": "A new SQL migration file is generated",
      "when": "The SQL is reviewed by the team",
      "then": "Indexes, partitions, and potential long-running operations are carefully checked for impact"
    },
    {
      "given": "A reviewed migration is ready for testing",
      "when": "The migration is applied in staging, data migrations are run, and smoke tests are performed",
      "then": "The schema changes and data transformations function correctly without impacting core functionality in staging"
    },
    {
      "given": "A migration can be applied without locking critical tables",
      "when": "The migration is deployed to production",
      "then": "The changes are applied without requiring a maintenance window (zero-downtime)"
    },
    {
      "given": "A migration requires locks on critical tables",
      "when": "The migration is deployed to production",
      "then": "The deployment occurs within a maintenance window to minimize impact"
    },
    {
      "given": "A schema change has been deployed to production",
      "when": "A need for rollback arises",
      "then": "A plan to revert schema changes (backup/restore or reverse migration) is executed successfully"
    },
    {
      "given": "A new feature is developed and deployed to production",
      "when": "The feature is gated behind a FeatureFlag",
      "then": "The feature can be gradually rolled out and controlled for specific user segments or environments"
    },
    {
      "given": "a publish pipeline operation is initiated",
      "when": "the publish_jobs report failures",
      "then": "an operator should check the failure rates, worker logs, and LinkedIn API status."
    },
    {
      "given": "there are failed publish jobs",
      "when": "an operator identifies the failed jobs",
      "then": "the operator can retry the failed jobs automatically or manually using 'admin/retry-publish'."
    },
    {
      "given": "the AI provider experiences an outage or quota is exceeded",
      "when": "the system attempts to use the AI provider",
      "then": "the system should switch to a degraded mode using cached templates, notify users of the degraded service, and backfill AI-generated content once the provider is restored."
    },
    {
      "given": "a Stripe webhook event is received",
      "when": "the system fails to process the webhook event",
      "then": "an operator should reprocess 'webhook_events', reconcile payments, and notify the finance team."
    },
    {
      "given": "high publish latency is detected",
      "when": "the system is under load",
      "then": "an operator should scale workers, check rate limits, and potentially add more concurrency with careful rate-limiting per account."
    },
    {
      "given": "an incident has been detected",
      "when": "the on-call engineer investigates the incident",
      "then": "the engineer should triage via Grafana/Sentry, escalate to the relevant owner (billing/publish/AI provider), and re-route traffic or enable maintenance mode if necessary."
    },
    {
      "given": "content is created or updated",
      "when": "the content save operation completes",
      "then": "triggers or a background job should produce and update the 'search_index.tsv'."
    },
    {
      "given": "an image is associated with content",
      "when": "the content is saved",
      "then": "a 'ContentMedia' entry should be created, mapping the image to the content."
    },
    {
      "given": "data exists in 'audit_logs', 'webhook_events', 'competitor_snapshots', or 'ai_prompts'",
      "when": "the data ages beyond its defined retention period",
      "then": "the system should apply implemented retention and partitioning policies."
    },
    {
      "given": "a user attempts to log in via an OIDC or SAML provider",
      "when": "the user completes the authentication flow with their IdentityProvider",
      "then": "the system should link the user to an 'IdpLink' and successfully authenticate them."
    },
    {
      "given": "a user or team performs operations that consume AI or LinkedIn resources",
      "when": "the rate of operations exceeds the defined per-user/team throttle limits",
      "then": "the system should apply rate-limiting to prevent overuse."
    },
    {
      "given": "a developer needs to set up a local or staging environment",
      "when": "they provision the environment",
      "then": "seed/staging data should be available with demo accounts (e.g., admin@scribl.test, editor@scribl.test, approver@scribl.test, viewer@scribl.test)."
    },
    {
      "given": "an external developer wants to integrate with the Scribl Public API",
      "when": "they access the API documentation",
      "then": "a generated OpenAPI specification should be available, detailing public endpoints, authentication, and operations."
    },
    {
      "given": "a client wants to initiate LinkedIn OAuth",
      "when": "the '/auth/linkedin/start' endpoint is accessed with an optional 'redirect' parameter",
      "then": "the system should return a '302 Redirect' to the LinkedIn OAuth authorization URL."
    },
    {
      "given": "LinkedIn has redirected back to the '/auth/linkedin/callback' endpoint with an authorization 'code'",
      "when": "the system receives the callback",
      "then": "the server should exchange the code for tokens, create or merge a User and LinkedInProfile, and return a session (JWT cookie or token)."
    },
    {
      "given": "A user has successfully authenticated with an identity provider",
      "when": "The application receives a valid 'code' and 'state' in the query parameters",
      "then": "The system should return a 200 OK response with the User summary and a session token"
    },
    {
      "given": "A user attempts to authenticate",
      "when": "The application receives an invalid 'code' or 'state' in the query parameters",
      "then": "The system should return a 400 Bad Request response indicating \"Invalid code / state\""
    },
    {
      "given": "A user attempts to authenticate",
      "when": "The authentication process encounters an internal server error",
      "then": "The system should return a 500 Internal Server Error response"
    },
    {
      "given": "The application is in a development environment",
      "when": "A POST request is made to '/auth/demo-login' with a specified 'role' (e.g., \"EDITOR\")",
      "then": "The system should return a 200 OK response with a demo user token"
    },
    {
      "given": "The application is in a production environment",
      "when": "A POST request is made to '/auth/demo-login'",
      "then": "The system should return a 403 Forbidden response indicating \"Disabled in production\""
    },
    {
      "given": "A valid 'userId' exists",
      "when": "A GET request is made to '/users/{userId}/onboarding'",
      "then": "The system should return a 200 OK response with the onboarding progress object for the specified user"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a valid 'userId' exists",
      "when": "A POST request is made to '/users/{userId}/onboarding' with a 'step' and 'payload'",
      "then": "The system should return a 200 OK response indicating \"Saved\""
    },
    {
      "given": "A user is unauthenticated or has an invalid 'bearerAuth' token",
      "when": "A POST request is made to '/users/{userId}/onboarding'",
      "then": "The system should return a 401 Unauthorized response"
    },
    {
      "given": "Content items exist in the system, potentially associated with a 'workspaceId', 'status', or matching a 'q' (query)",
      "when": "A GET request is made to '/contents', optionally with 'workspaceId', 'status', 'q', 'page', and 'pageSize' query parameters",
      "then": "The system should return a 200 OK response with a paginated list of content items"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/contents' with a valid 'ContentCreateRequest' payload",
      "then": "The system should return a 201 Created response with the newly created 'ContentItem'"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/contents' with an invalid 'ContentCreateRequest' payload",
      "then": "The system should return a 400 Bad Request response indicating a \"Validation error\""
    },
    {
      "given": "A content item with a specific 'id' exists",
      "when": "A GET request is made to '/contents/{id}' with a valid content 'id'",
      "then": "The system should return a 200 OK response with the requested 'ContentItem'"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a content item with a specific 'id' exists",
      "when": "A PATCH request is made to '/contents/{id}' with a 'ContentUpdateRequest' payload",
      "then": "The system should return a 200 OK response with the updated 'ContentItem'"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a content item with a specific 'id' exists",
      "when": "A POST request is made to '/contents/{id}' to duplicate it",
      "then": "The system should return a 201 Created response with the duplicated 'ContentItem'"
    },
    {
      "given": "A content item with a specific 'id' exists and has associated versions",
      "when": "A GET request is made to '/contents/{id}/versions'",
      "then": "The system should return a 200 OK response with an array of 'ContentVersion' objects"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a content item with a specific 'id' exists",
      "when": "A POST request is made to '/contents/{id}/versions' with a 'ContentVersionCreate' payload",
      "then": "The system should return a 201 Created response with the newly created 'ContentVersion'"
    },
    {
      "given": "Templates exist in the system, potentially associated with a 'workspaceId'",
      "when": "A GET request is made to '/templates', optionally with a 'workspaceId' query parameter",
      "then": "The system should return a 200 OK response with an array of 'Template' objects"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/templates' with a valid 'TemplateCreate' payload",
      "then": "The system should return a 201 Created response with the newly created 'Template'"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a template with a specific 'id' exists",
      "when": "A POST request is made to '/templates/{id}/share' with a 'targetWorkspaceId'",
      "then": "The system should return a 200 OK response indicating \"Shared\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/templates/{id}/share' with an 'id' that does not correspond to an existing template",
      "then": "The system should return a 404 Not Found response indicating \"Template not found\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/ai/generate' with a valid 'AiGenerateRequest' payload",
      "then": "The system should return a 200 OK response with AI variations and metadata ('AiGenerateResponse')"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and their AI generation quota has been exceeded",
      "when": "A POST request is made to '/ai/generate'",
      "then": "The system should return a 429 Too Many Requests response indicating \"Quota exceeded\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a workspace with a specific 'id' exists",
      "when": "A POST request is made to '/workspaces/{id}/snapshots' with a 'sessionState' payload",
      "then": "The system should return a 201 Created response indicating \"Snapshot saved\""
    },
    {
      "given": "A workspace with a specific 'id' exists and has saved snapshots",
      "when": "A GET request is made to '/workspaces/{id}/snapshots'",
      "then": "The system should return a 200 OK response with an array of workspace snapshots"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/schedules' with a valid 'ScheduleCreateRequest' payload",
      "then": "The system should return a 201 Created response with the created 'Schedule' object, indicating the job has been queued"
    },
    {
      "given": "Schedules exist in the system, potentially filtered by 'workspaceId', 'rangeStart', and 'rangeEnd'",
      "when": "A GET request is made to '/schedules', optionally with 'workspaceId', 'rangeStart', and 'rangeEnd' query parameters",
      "then": "The system should return a 200 OK response with a list of 'Schedule' objects"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and valid 'contentId' and 'linkedInProfileId' exist",
      "when": "A POST request is made to '/publish/linkedin' with 'contentId', 'linkedInProfileId', and 'scheduledAt'",
      "then": "The system should return a 202 Accepted response with a 'PublishJob' object, indicating the job has been created"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and a 'contentId' exists",
      "when": "A POST request is made to '/approvals' with 'contentId' and 'submittedBy'",
      "then": "The system should return a 201 Created response indicating \"Submitted\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and an approval with 'approvalId' exists",
      "when": "A PATCH request is made to '/approvals' with 'approvalId', a new 'status' (e.g., 'APPROVED', 'REJECTED'), and optional 'comments'",
      "then": "The system should return a 200 OK response indicating \"Updated\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and the system has recommended posts for engagement for a 'workspaceId'",
      "when": "A GET request is made to '/engage/feed', optionally with a 'workspaceId' query parameter",
      "then": "The system should return a 200 OK response with an array of recommended posts, including 'postId', 'author', 'excerpt', and 'reasons'"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and an 'externalPostId' exists",
      "when": "A POST request is made to '/engage/action' with 'userId', an 'action' (like, comment, or share), 'externalPostId', and optional 'text' (for comments)",
      "then": "The system should return a 200 OK response indicating \"Action performed\""
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token and has exceeded the rate limit for engagement actions",
      "when": "A POST request is made to '/engage/action'",
      "then": "The system should return a 429 Too Many Requests response indicating \"Rate limited\""
    },
    {
      "given": "Opportunities exist for a specific 'workspaceId'",
      "when": "A GET request is made to '/opportunities', optionally with a 'workspaceId' query parameter",
      "then": "The system should return a 200 OK response with an array of 'Opportunity' objects"
    },
    {
      "given": "A user is authenticated with a valid 'bearerAuth' token",
      "when": "A POST request is made to '/opportunities', optionally with a 'workspaceId' payload, to trigger a refresh",
      "then": "The system should return a 202 Accepted response indicating \"Refresh enqueued\""
    },
    {
      "given": "Analytics data is available for a specific 'workspaceId' and date 'rangeStart'/'rangeEnd'",
      "when": "A GET request is made to '/analytics/overview', optionally with 'workspaceId', 'rangeStart', and 'rangeEnd' query parameters",
      "then": "The system should return a 200 OK response with the 'AnalyticsOverview' metrics"
    },
    {
      "given": "The system is configured to receive Stripe webhook events",
      "when": "A POST request is received at '/webhooks/stripe' containing a Stripe event payload",
      "then": "The system should return a 200 OK response, persist the event to 'WebhookEvent', and process it asynchronously"
    },
    {
      "given": "An incoming request contains a valid \"Stripe-Signature\" header.",
      "when": "The system attempts to validate the \"Stripe-Signature\" header.",
      "then": "The signature is successfully validated and the request is processed."
    },
    {
      "given": "An incoming request contains an invalid \"Stripe-Signature\" header.",
      "when": "The system attempts to validate the \"Stripe-Signature\" header.",
      "then": "The signature validation fails and the request is rejected."
    },
    {
      "given": "An incoming request does not contain a \"Stripe-Signature\" header.",
      "when": "The system attempts to validate the \"Stripe-Signature\" header.",
      "then": "The signature validation fails due to the missing header and the request is rejected."
    },
    {
      "given": "a valid webhook event payload and a correct signature in the 'Stripe-Signature' header",
      "when": "a POST request is sent to the webhook endpoint",
      "then": "the system should accept the request and respond with a 200 status code"
    },
    {
      "given": "a valid team ID",
      "when": "a GET request is made to '/billing/subscription/{teamId}' with the team ID",
      "then": "the system should return a 200 status code and the subscription details for the specified team"
    },
    {
      "given": "the system and its dependencies (DB, Redis) are healthy",
      "when": "a GET request is made to '/admin/health'",
      "then": "the system should return a 200 status code with a health report indicating 'healthy' status for all components"
    },
    {
      "given": "an authenticated admin user with a valid JWT token and a 'publishJobId' for a failed job",
      "when": "a POST request is made to '/admin/retry-publish' with the 'publishJobId' in the request body",
      "then": "the system should enqueue the retry job and respond with a 200 status code"
    },
    {
      "given": "A user wants to authenticate using their LinkedIn account",
      "when": "The user accesses the `/auth/linkedin/start` endpoint, optionally providing a `redirect` URL",
      "then": "The system redirects the user to LinkedIn's authorization page with a `302` status"
    },
    {
      "given": "A user has successfully authorized the application on LinkedIn",
      "when": "LinkedIn redirects the user back to the application's `/auth/linkedin/callback` endpoint with a valid `code` and `state`",
      "then": "The system processes the OAuth callback, authenticates the user, and returns an `AuthResponse` with a `token` and `user` details with a `200` status"
    },
    {
      "given": "A user attempts to complete LinkedIn OAuth",
      "when": "LinkedIn redirects the user back to the application's `/auth/linkedin/callback` endpoint with an invalid or missing `code` or `state`",
      "then": "The system returns a `400 Bad Request` error"
    },
    {
      "given": "The application is running in a non-production environment",
      "when": "A developer sends a POST request to `/auth/demo-login`, optionally specifying a `role`",
      "then": "The system creates a temporary demo user and returns an `AuthResponse` with a token for that user with a `200` status"
    },
    {
      "given": "The application is running in a production environment",
      "when": "A user sends a POST request to `/auth/demo-login`",
      "then": "The system returns a `403 Forbidden` error"
    },
    {
      "given": "A user is authenticated",
      "when": "The user requests their onboarding progress via `GET /users/{userId}/onboarding`",
      "then": "The system returns the `OnboardingProgress` object, including completed steps and progress percentage with a `200` status"
    },
    {
      "given": "An authenticated user is in the process of onboarding",
      "when": "The user sends a POST request to `/users/{userId}/onboarding` with a `step` and `payload`",
      "then": "The system saves the onboarding step and returns a `200 OK` status"
    },
    {
      "given": "A user is not authenticated",
      "when": "The user attempts to `GET` or `POST` to `/users/{userId}/onboarding`",
      "then": "The system returns a `401 Unauthorized` error"
    },
    {
      "given": "A new user attempts to sign up for Scribl.",
      "when": "The user authenticates with their LinkedIn account.",
      "then": "The system retrieves their name, title, connections, and profile picture from LinkedIn AND creates a Scribl user record using this data, ensuring authenticity and a seamless workflow."
    },
    {
      "given": "A new user has authenticated with LinkedIn and is presented with the guided onboarding flow.",
      "when": "The user provides their goals, brand voice preferences, posting frequency, and niche selections.",
      "then": "The system collects and stores all the provided information to complete the onboarding process."
    },
    {
      "given": "A new user has authenticated with LinkedIn and starts the guided onboarding flow.",
      "when": "The user fills in some steps but navigates away before completing the entire process.",
      "then": "The system auto-saves the user's progress for the completed steps to prevent drop-offs."
    },
    {
      "given": "A team administrator is configuring their team's subscription.",
      "when": "The administrator selects a number of seats and a subscription plan.",
      "then": "A real-time calculator displays the pricing and features, and upon confirmation, payment is processed via Stripe before access is provisioned."
    },
    {
      "given": "A Team Admin (or designated Org-Admin) wants to connect their organization's LinkedIn page to Scribl.",
      "when": "The Admin authenticates with LinkedIn OAuth as an admin of the organization page and consents to required organization scopes (e.g., rw_organization_admin, w_organization_social, r_organization_social).",
      "then": "The system stores encrypted org-level tokens in a `OrganizationLinkedInAccount` record AND lists the available OrgPages (URNs) associated with that account."
    },
    {
      "given": "A Team Admin has successfully connected an Organization LinkedIn Account with available Org Pages.",
      "when": "The Admin assigns a specific team member 'publish' or 'manage_media' rights for a particular Org Page.",
      "then": "The system implements role-based Org Page Grants by updating the server-controlled mapping to reflect the team member's granted permissions for that Org Page."
    },
    {
      "given": "A team member has been explicitly granted 'publish' rights for an Org Page by a Team Admin.",
      "when": "The team member attempts to publish content to that specific Org Page through Scribl.",
      "then": "The server-side publish pipeline processes the request, enforcing grant checks, approvals (if applicable), idempotency, and audit logs, successfully publishing the content using the org token or a delegated user's token."
    },
    {
      "given": "A team member has 'publish' rights for an Org Page, and an approval workflow is configured for that Org Page.",
      "when": "The team member attempts to publish content to that Org Page.",
      "then": "The server-side publish pipeline places the content into an 'awaiting approval' state AND notifies the designated Approver or Org Admin before actual publication."
    },
    {
      "given": "An admin user is logged in to the application.",
      "when": "The admin requests to connect an Org LinkedIn Page by calling GET /api/teams/:teamId/linkedin/org/start?redirect=...",
      "then": "The system should build a LinkedIn OAuth URL with 'r_organization_social', 'w_organization_social', and 'r_liteprofile' scopes, store the state and teamId, and redirect the user to LinkedIn for authentication."
    },
    {
      "given": "An admin user has successfully authenticated with LinkedIn and has been redirected back to the application with a 'code' and 'state' in the URL.",
      "when": "The system receives the callback request via GET /api/teams/:teamId/linkedin/org/callback?code=...&state=...",
      "then": "The system should validate the 'state', exchange the 'code' for an org access token, call the LinkedIn API to list organizations the user administers, persist 'OrganizationLinkedInAccount' for selected orgs, fetch page details and create 'OrgLinkedInPage' records for each connected org, create an 'AuditLog' entry 'team.linkedin.org_connected', and notify team admins."
    },
    {
      "given": "An authenticating user attempts to connect an Org LinkedIn Page.",
      "when": "The system processes the LinkedIn callback and fetches pages the user administers.",
      "then": "The system should only surface pages that the authenticating user actually administers, as required by LinkedIn."
    },
    {
      "given": "A team has connected Organization LinkedIn Accounts and associated pages.",
      "when": "A user requests to view connected org accounts and pages by calling GET /api/teams/:teamId/linkedin/orgs",
      "then": "The system should return a list of connected organization LinkedIn accounts and their associated pages."
    },
    {
      "given": "An Admin or Manager user is logged in.",
      "when": "The user requests to grant access to a team member for an Org LinkedIn Page by calling POST /api/teams/:teamId/linkedin/orgs/:orgId/grant with { userId, pageId, role }",
      "then": "The system should create an 'OrgPageAccess' record, send a notification to the user who has been granted rights, and create an 'AuditLog' entry 'org.page_access_granted'."
    },
    {
      "given": "An Admin or Manager user has previously granted access to a team member for an Org LinkedIn Page.",
      "when": "The user requests to revoke access for a team member by calling DELETE /api/teams/:teamId/linkedin/orgs/:orgId/grant/:grantId",
      "then": "The system should delete the corresponding 'OrgPageAccess' record."
    },
    {
      "given": "A workspace exists and a user wants to configure its publishing settings.",
      "when": "The user sends a PATCH /api/workspaces/:workspaceId/settings request to link a workspace to a particular 'OrgLinkedInPage' and set a default publish identity.",
      "then": "The system should associate the workspace with the specified 'OrgLinkedInPage'(s) and store the default publish identity (org/individual)."
    },
    {
      "given": "A workspace is configured with linked OrgLinkedInPages.",
      "when": "A user requests to list available pages for a workspace by calling GET /api/workspaces/:workspaceId/pages",
      "then": "The system should return a list of OrgLinkedInPages that are available for that workspace."
    },
    {
      "given": "A user is in the same team as the 'orgAccountId' and has an 'OrgPageAccess.role' of 'PUBLISHER', 'Admin', or 'Approver'.",
      "and": "The 'OrganizationLinkedInAccount.tokenExpiresAt' is valid or successfully refreshed.",
      "when": "The user requests to publish content to an Org LinkedIn Page by calling POST /api/publish/linkedin/org with { contentId, orgAccountId, pageId, scheduledForUtc, idempotencyKey }",
      "then": "The system should enqueue a 'PublishJob' using the 'orgAccountId' and 'OrgPage URN' to the publish worker."
    },
    {
      "given": "A user is in the same team as the 'orgAccountId'.",
      "and": "The workspace requires content approval, and the user is not an Approver.",
      "when": "The user requests to publish content to an Org LinkedIn Page by calling POST /api/publish/linkedin/org with { contentId, orgAccountId, pageId, scheduledForUtc, idempotencyKey }",
      "then": "The system should create the 'PublishJob' as 'pending_approval' instead of enqueuing it for immediate publishing."
    },
    {
      "given": "A user attempts to publish content to an Org LinkedIn Page.",
      "and": "The 'OrganizationLinkedInAccount.tokenExpiresAt' is expired.",
      "when": "The system checks the org token validity.",
      "then": "The system should attempt to refresh the token, or fail with an actionable message if a refresh is not possible."
    },
    {
      "given": "A 'PublishJob' has a 'linkedInProfileId' pointing to an organization account.",
      "when": "The publish worker executes the 'PublishJob'.",
      "then": "The worker should use 'OrganizationLinkedInAccount.accessTokenEnc' and publish using LinkedIn's organizational entity endpoints, storing the org post URN returned by LinkedIn in 'PublishJob.resultPayload'."
    },
    {
      "given": "An admin user is logged in to the application and navigating the UI.",
      "when": "The admin clicks 'Connect LinkedIn Page', views the CTA and required scopes explanation, and then clicks to proceed.",
      "then": "The UI should redirect to LinkedIn OAuth, and upon return, display a list of pages the authenticating admin user administers with checkboxes for selection."
    },
    {
      "given": "An admin is on the Team Admin page and a LinkedIn organization page is available for connection",
      "when": "The admin selects one or more LinkedIn pages to connect to the Team, then confirms and saves",
      "then": "A success state is shown with a quick link to 'Grant page access to your members', and new OrgLinkedInPage and OrganizationLinkedInAccount records are created"
    },
    {
      "given": "An admin is on the Team Admin page with connected LinkedIn organization pages",
      "when": "The admin navigates to the 'LinkedIn Pages' section",
      "then": "Each connected page card is displayed showing its name, connectedBy, lastSyncedAt, and status"
    },
    {
      "given": "An admin is viewing a connected LinkedIn page card in the Team Admin UI",
      "when": "The admin clicks 'Grant access', selects team members, and assigns a role (PUBLISHER/APPROVER/MANAGER) in the modal",
      "then": "The system displays any potential seat/billing impact"
    },
    {
      "given": "An admin has granted access to a team member for a LinkedIn page",
      "when": "The admin chooses to revoke access for that member and confirms the action",
      "then": "A confirmation dialog is shown, and the audit trail (who granted, when) is displayed"
    },
    {
      "given": "A user is in the content editor/publish modal, and the workspace has connected organization pages",
      "when": "The user selects a 'Company Page' from the 'Publish as' option and has the PUBLISHER role for that page",
      "then": "The user can proceed to publish content as the selected company page"
    },
    {
      "given": "A user is in the content editor/publish modal, and the workspace has connected organization pages",
      "when": "The user selects a 'Company Page' from the 'Publish as' option but does not have the PUBLISHER role for that page",
      "then": "The option to publish as that page is disabled, showing 'You need publisher access. Request access', and a request button is available"
    },
    {
      "given": "A user lacks PUBLISHER role for a company page in the content editor/publish modal",
      "when": "The user clicks the 'Request access' button",
      "then": "An access request is sent to admins, creating a notification and an AuditLog entry"
    },
    {
      "given": "A workspace requires approval for company posts, and a user has created content to be published as a company page",
      "when": "The user submits the content for publish",
      "then": "A pending approval is created, and 'posting as {Company Page}' is clearly shown in the Approvals queue"
    },
    {
      "given": "A user is viewing the Publish Jobs/History",
      "when": "The user applies filters for 'publishedBy' and 'publishedAs' (org page vs personal)",
      "then": "The list of posts is filtered accordingly"
    },
    {
      "given": "Analytics data is being generated for published posts",
      "when": "A post is published as an organization",
      "then": "The post in analytics is tagged by 'publishedAs: ORGANIZATION'"
    },
    {
      "given": "An organization LinkedIn account is connected",
      "when": "The access token is stored by the system",
      "then": "The organization token is stored encrypted, and access is restricted to a service account that can decrypt it only on the publisher app server"
    },
    {
      "given": "An admin attempts to connect an organization LinkedIn page",
      "when": "The system verifies LinkedIn scopes at connect time and finds missing required scopes",
      "then": "The connection is refused, and the admin is instructed to request the correct scopes"
    },
    {
      "given": "A post is being sent to LinkedIn by the system",
      "when": "The system prepares the publishing request",
      "then": "An 'idempotencyKey' is used to prevent duplicate postings"
    },
    {
      "given": "An access grant or change occurs for an organization page",
      "when": "The event is processed by the system",
      "then": "The grant/change is audited, and the history is shown to Org owners"
    },
    {
      "given": "An organization LinkedIn account is active and posts are scheduled",
      "when": "LinkedIn returns a 401 status code during a publish attempt or sync, indicating token revocation",
      "then": "The organization account is marked 'active = false', admins are notified, and scheduled organization publishes are paused"
    },
    {
      "given": "A publisher worker receives a 'publishTarget' payload with type 'ORGANIZATION'",
      "when": "The worker processes the payload to publish content",
      "then": "The worker decrypts 'OrganizationLinkedInAccount.accessTokenEnc', prepares the payload with 'owner: pageUrn', uploads media using the org token (with asset registration), publishes, and upon success, writes 'PublishJob.resultPayload.orgPostUrn'"
    },
    {
      "given": "An admin attempts to connect an organization LinkedIn page",
      "when": "The system performs a pre-flight check and validates the connecting LinkedIn user is not an admin of the organization page from the LinkedIn response",
      "then": "The connection is refused"
    },
    {
      "given": "The product policy ties billing only to 'Editors' and PUBLISHER/APPROVER mapping is independent of seat types",
      "when": "PUBLISHER or APPROVER access is granted to a user for an organization page",
      "then": "No seat change is required"
    },
    {
      "given": "OrgPage access is defined as a billable entitlement",
      "when": "PUBLISHER or APPROVER access is granted to a user for an organization page",
      "then": "The pricing and seat change modal is shown while granting access"
    },
    {
      "given": "An Admin is logged into Scribl and has admin rights for a LinkedIn Company Page",
      "when": "The Admin navigates to 'LinkedIn Pages', selects 'Connect LinkedIn Page', authorizes Scribl on LinkedIn, and chooses pages to connect from the returned list",
      "then": "The system stores the Org LinkedIn account and page entries, and displays a success message"
    },
    {
      "given": "An Admin is logged into Scribl",
      "when": "The Admin navigates to an Org Page card, selects 'Grant Access', chooses a team member and assigns the 'PUBLISHER' role, then confirms",
      "then": "An 'OrgPageAccess' record is created for the team member and the page, the team member receives a notification, and can now select the Org Page in the composer publish menu"
    },
    {
      "given": "A team member has the 'PUBLISHER' role for an Org Page, and the content is approved (or approvals are disabled)",
      "when": "The team member selects the Org Page in the composer and initiates a publish action",
      "then": "A 'PublishJob' is created, executed using the Org account, includes 'publishedAs' metadata, stores the returned Org post URN, and the team member receives a success notification"
    },
    {
      "given": "A team member does NOT have the 'PUBLISHER' role for an Org Page",
      "when": "The team member attempts to publish content as that Org Page",
      "then": "The publish action is blocked, and an 'Insufficient permission' error message is displayed"
    },
    {
      "given": "A team member has the 'PUBLISHER' role for an Org Page, and approvals are enabled for the Org Page, but the content is not yet approved",
      "when": "The team member attempts to publish the content as that Org Page",
      "then": "A pending approval request is created, and the content is not immediately published"
    },
    {
      "given": "An Org LinkedIn Account is connected and has scheduled publishes, but its LinkedIn token subsequently expires or is revoked",
      "when": "A scheduled publish job attempts to execute using the expired/revoked token or a system check identifies the invalid token",
      "then": "The 'OrganizationLinkedInAccount.active' status is set to 'false', scheduled Org publishes are paused, an admin notification is sent, and the publisher returns a 401 error"
    },
    {
      "given": "An action related to Org Page management or content publishing occurs",
      "when": "An Admin grants/revokes access to an Org Page, or a user publishes content as an Org",
      "then": "An entry detailing the action, user, and relevant context is recorded in the 'AuditLog'"
    },
    {
      "given": "An Org LinkedIn Page is connected in Scribl, and the connecting user's admin rights for that page are revoked on LinkedIn",
      "when": "The system attempts to interact with the LinkedIn page (e.g., publish, fetch analytics) or performs a re-validation check",
      "then": "The system detects the permission change, potentially revokes Scribl's access, marks the Org account inactive, and notifies admins to re-validate or reconnect"
    },
    {
      "given": "An Org LinkedIn Account is connected, and an organization is actively publishing content",
      "when": "The organization attempts to publish content that exceeds LinkedIn's per-org rate limits",
      "then": "The publish request is throttled, queued for retry, and not immediately rejected, to ensure compliance with LinkedIn limits"
    },
    {
      "given": "A team manages multiple LinkedIn Org Pages and uses Scribl workspaces",
      "when": "An Admin configures Scribl workspaces",
      "then": "The system allows mapping different Org Pages to different Scribl workspaces for better organization and access control"
    },
    {
      "given": "A team is configured to use SSO, and SSO group admins are defined",
      "when": "An SSO group admin is identified during the Org connection or SSO synchronization process",
      "then": "The system auto-maps the SSO group admin to an 'Org Manager' role within Scribl for the relevant Org Pages"
    },
    {
      "given": "A user is authenticated and associated with a specific team and workspace.",
      "when": "The user attempts to access or modify business data (e.g., ContentItem, Template, Analytics).",
      "then": "The user should only be able to access or modify data that is explicitly scoped to their associated teamId and optionally workspaceId, based on their roles."
    },
    {
      "given": "A user is associated with Team A.",
      "when": "The user attempts to access data explicitly belonging to Team B.",
      "then": "The system should deny access and prevent the user from viewing or modifying data outside of their authorized team scope."
    },
    {
      "given": "A new business data entity (e.g., ContentItem, LinkedInPost, Notification) is created in the application.",
      "when": "The application persists this entity to the database.",
      "then": "The database record for the entity should reliably include a 'teamId' and, where applicable, a 'workspaceId' to ensure strong multi-tenancy."
    },
    {
      "given": "A team has reached its maximum allowed seat count according to its subscription plan.",
      "when": "An administrator attempts to invite a new user to join the team or a new user attempts to activate an invitation.",
      "then": "The system should prevent the new user from being successfully added or activated, enforcing the configured seat count limit."
    },
    {
      "given": "A user performs a key action within the application (e.g., creating content, changing workspace settings, inviting a team member).",
      "when": "The action is successfully completed.",
      "then": "An 'AuditLog' entry should be created, comprehensively recording the 'actor', 'timestamp', 'action' performed, relevant 'metadata', 'teamId', and 'workspaceId' (if applicable)."
    },
    {
      "given": "A user is actively working within a selected workspace in the user interface.",
      "when": "The user navigates to sections displaying templates, content items, or analytics.",
      "then": "The UI should only display templates, content, and analytics that are explicitly scoped to the currently selected workspace, or to the team/global scope where explicitly allowed."
    },
    {
      "given": "Postgres Row-Level Security (RLS) is enabled and configured with policies for tenant-scoped models.",
      "when": "The application initiates a database session or transaction and sets the 'app.current_team' variable to the user's current teamId.",
      "then": "The database should automatically restrict all queries within that session/transaction to only return rows where the 'team_id' matches the 'app.current_team', providing a robust database-level defense."
    },
    {
      "given": "A 'content_item' table exists in the database",
      "when": "Row Level Security is enabled on 'content_item' and a policy 'content_item_tenant_isolation' is created",
      "then": "The policy should restrict access to 'content_item' rows where 'team_id' matches 'current_setting('app.current_team')'"
    },
    {
      "given": "Row Level Security is enabled and a 'content_item_tenant_isolation' policy is active",
      "when": "A database connection executes 'SET LOCAL app.current_team = '...' for a request",
      "then": "Subsequent queries on 'content_item' within that connection should only return items belonging to the specified 'team_id'"
    },
    {
      "given": "A user is authenticated and part of an active team",
      "when": "The user attempts to create a 'ContentItem' via the ORM/Prisma middleware",
      "then": "The 'ContentItem' should be assigned the 'teamId' corresponding to the user's active team"
    },
    {
      "given": "A user is authenticated and part of an active team",
      "when": "The user attempts to read 'ContentItem's via the ORM/Prisma middleware",
      "then": "The read query should implicitly include a 'where: { teamId: req.user.activeTeamId }' clause, filtering results by the user's active team"
    },
    {
      "given": "An incoming request contains a valid session cookie",
      "when": "The 'authMiddleware' processes the request",
      "then": "The 'userId' should be extracted, the user object attached to 'req.user', and 'userContext' containing 'userId', 'teamId', 'workspaceId', and 'roles' should be attached to 'req.context'"
    },
    {
      "given": "An authenticated user makes a request with a specified 'teamId'",
      "when": "The 'authMiddleware' attempts to load the user's membership for that 'teamId'",
      "then": "If the user is not a member of the specified 'teamId', the middleware should return a '403 Forbidden' response"
    },
    {
      "given": "The application uses Row Level Security (RLS) and an authenticated user makes a request with a valid 'teamId'",
      "when": "The 'authMiddleware' processes the request",
      "then": "'SET LOCAL app.current_team = '...' should be executed on the database connection, using the 'teamId' from the request context"
    },
    {
      "given": "An authenticated user is a member of ':teamId'",
      "when": "A 'GET /api/teams/:teamId/workspaces' request is made",
      "then": "The API should return a list of workspaces associated with ':teamId', provided the user has team membership"
    },
    {
      "given": "An authenticated user with 'ADMIN' or 'OWNER' role within ':teamId'",
      "when": "A 'POST /api/teams/:teamId/workspaces' request is made to create a new workspace",
      "then": "The API should successfully create the workspace within ':teamId'"
    },
    {
      "given": "An authenticated user with 'MEMBER' role within ':teamId'",
      "when": "A 'POST /api/teams/:teamId/workspaces' request is made to create a new workspace",
      "then": "The API should return an authorization error (e.g., '403 Forbidden')"
    },
    {
      "given": "An authenticated user with appropriate RBAC permissions for ':workspaceId' within ':teamId'",
      "when": "A 'GET /api/teams/:teamId/workspaces/:workspaceId/content?status=&type=' request is made",
      "then": "The API should return a list of content items for the specified workspace, filtered by RBAC"
    },
    {
      "given": "An authenticated user within ':teamId' and available seats",
      "when": "A 'POST /api/teams/:teamId/invite' request is made with invite details",
      "then": "Invites should be created, seat checks performed, and an entry logged in the AuditLog"
    },
    {
      "given": "An authenticated user is making an API request that involves tenant data",
      "when": "The API returns data",
      "then": "The API should never return cross-team lists or cross-tenant data not explicitly scoped to the user's current team/workspace"
    },
    {
      "given": "A user is logged in and navigating the application",
      "when": "The global layout is displayed",
      "then": "A 'Team switcher' should be visible in the top-left, displaying the current Team, and a 'Workspace switcher' dropdown should be visible next to it"
    },
    {
      "given": "A user is logged in and navigating through Team and Workspace",
      "when": "Any page is displayed",
      "then": "Breadcrumbs indicating 'Team > Workspace > Page' should be shown, and the header should display plan/seat summary (e.g., 'Seats: 3/10')"
    },
    {
      "given": "A user with appropriate permissions accesses the Team Admin Console",
      "when": "The Team Admin Console is displayed",
      "then": "Pages for 'Team settings', 'Members', 'Workspaces', 'Templates (team-scoped)', and 'Audit' should be accessible"
    },
    {
      "given": "A user initiates the invite process from the Team Admin Console",
      "when": "The Invite modal is displayed",
      "then": "The modal should include a multi-email input, a role selector, an optional initial workspace assignment, a real-time seat usage preview, blocking if seats are exceeded, and options to show invite expiration and resend"
    },
    {
      "given": "A user is viewing content, analytics, or templates within a workspace",
      "when": "The user interacts with the workspace selector",
      "then": "The displayed content, analytics, or templates should dynamically filter to show only items relevant to the currently selected workspace"
    },
    {
      "given": "A user is creating content within a specific workspace",
      "when": "The user attempts to save the content",
      "then": "The content is automatically associated with the current workspace"
    },
    {
      "given": "A user is creating content",
      "when": "The user has permissions to access multiple workspaces and uses the workspace selection dropdown",
      "then": "The user can select another workspace to associate the content with"
    },
    {
      "given": "A user is viewing the templates gallery",
      "when": "The gallery loads",
      "then": "Each template displays its scope badge (Personal, Workspace, Team, Global)"
    },
    {
      "given": "A user is saving a template",
      "when": "The user selects 'Save to Personal' as the scope",
      "then": "The template is saved with a Personal scope"
    },
    {
      "given": "A user is saving a template",
      "when": "The user selects 'Save to Workspace' as the scope",
      "then": "The template is saved with a Workspace scope"
    },
    {
      "given": "A user is saving a template",
      "when": "The user selects 'Save to Team' as the scope",
      "then": "The template is saved with a Team scope"
    },
    {
      "given": "A user is not a member of a specific team",
      "when": "The user attempts to navigate to the unauthorized team's interface",
      "then": "A clear message indicating access is denied is displayed, along with a CTA to request access"
    },
    {
      "given": "A user attempts to perform an action within a workspace",
      "when": "The user does not have the necessary permissions for that action",
      "then": "An explanation of the denied access is displayed, including a link to request access"
    },
    {
      "given": "An administrator is logged in",
      "when": "The administrator navigates to the Audit Viewer page",
      "then": "The Audit Viewer UI is displayed"
    },
    {
      "given": "The Audit Viewer UI is displayed",
      "when": "The administrator uses the search bar or applies filters (actor, time range, action type, targetType)",
      "then": "The displayed audit entries are updated to match the search and filter criteria"
    },
    {
      "given": "The Audit Viewer UI is displayed with audit entries",
      "when": "The administrator initiates a CSV export",
      "then": "A CSV file containing the displayed audit entries is downloaded"
    },
    {
      "given": "The Audit Viewer UI is displayed with a list of audit entries",
      "when": "The administrator selects an individual audit entry",
      "then": "A detail panel appears, showing metadata for the entry and a link to the associated entity (if applicable)"
    },
    {
      "given": "The system is configured with seat-counting policies",
      "when": "Team members are assigned roles",
      "then": "Roles such as OWNER, ADMIN, and EDITOR are counted towards seat usage"
    },
    {
      "given": "The system is configured with seat-counting policies",
      "when": "A team member is assigned the 'Viewer' role",
      "then": "The system allows flexibility to configure whether 'Viewer' roles consume seats or are free"
    },
    {
      "given": "A team has N available seats, and the current 'seatsUsed + pendingInvites + newInvites' is less than or equal to N",
      "when": "A user attempts to create new invites",
      "then": "The invite creation process proceeds successfully"
    },
    {
      "given": "A team has N available seats, and the current 'seatsUsed + pendingInvites + newInvites' is greater than N",
      "when": "A user attempts to create new invites",
      "then": "The invite creation is blocked, and an upgrade CTA is displayed"
    },
    {
      "given": "Only one seat remains available in a team, and multiple users simultaneously attempt to accept invites for that team",
      "when": "The invite acceptance process is initiated by these users",
      "then": "A transactional check ensures only one user successfully claims the last seat, preventing overselling"
    },
    {
      "given": "A user's role is being changed to a seat-consuming role",
      "when": "There are enough available seats to accommodate this role change",
      "then": "The role change is processed successfully"
    },
    {
      "given": "A user's role is being changed to a seat-consuming role",
      "when": "There are insufficient available seats to accommodate this role change",
      "then": "The role change is blocked"
    },
    {
      "given": "A user's role is being changed to a seat-consuming role by an administrator",
      "when": "There are insufficient available seats to accommodate this role change",
      "then": "The administrator is prompted for confirmation to increase the seat count or override the block"
    },
    {
      "given": "An SSO/SCIM provisioning attempt is made to add new users to a team",
      "when": "The number of users to be added exceeds the available seat count",
      "then": "A SCIM error is returned, indicating insufficient seats"
    },
    {
      "given": "An administrator is viewing the Team Admin section",
      "when": "The Team Admin page loads",
      "then": "A seat meter is displayed, showing 'Used / Total' seat count"
    },
    {
      "given": "An administrator is in the Team Admin section, about to send invites",
      "when": "The administrator specifies a number of invites to send",
      "then": "The seat meter displays a predictive count, showing 'X / Y' after sending the invites"
    },
    {
      "given": "A user attempts to send invites",
      "when": "There are insufficient seats available for the new invites",
      "then": "The invite creation is blocked, and an upgrade modal is displayed"
    },
    {
      "given": "A user performs an authentication-related action (login, logout, token refresh)",
      "when": "The action is completed",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "A team-related action occurs (created, updated, seat changes, billing events)",
      "when": "The action is completed",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "An invite-related action occurs (created, accepted, revoked)",
      "when": "The action is completed",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "A membership-related action occurs (role changes, removals)",
      "when": "The action is completed",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "A content lifecycle action occurs (create/edit/commit/version, submit for approval, approve/reject, schedule, publish)",
      "when": "The action is completed",
      "then": "The event (including its result for publish) is logged in the audit system"
    },
    {
      "given": "An organization-level LinkedIn connection/disconnection or page grant/revoke occurs",
      "when": "The action is completed",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "A critical system event occurs (webhook processing failures, payment failures)",
      "when": "The event occurs",
      "then": "The event is logged in the audit system"
    },
    {
      "given": "The AuditLog schema is defined",
      "when": "An audit log entry is created",
      "then": "The 'teamId' and 'workspaceId' fields are available, allowing for null values for system-level events"
    },
    {
      "given": "The system needs to log an event",
      "when": "A service layer component calls the 'audit(actorId, teamId, workspaceId, action, targetType, targetId, meta)' helper",
      "then": "The event is processed for audit logging through the centralized helper"
    },
    {
      "given": "The system experiences a high volume of audit logging requests",
      "when": "Audit events are generated",
      "then": "A queue is utilized for processing heavy audit writes, ensuring ordering for important events"
    },
    {
      "given": "An audit event contains sensitive or large data",
      "when": "The event is logged",
      "then": "The 'meta' field stores a short reference or minimal data, avoiding PII leaks and large raw payloads"
    },
    {
      "given": "An administrator is viewing the audit logs",
      "when": "The administrator applies date-range and action filters and then initiates a CSV export",
      "then": "A CSV file containing the filtered audit logs is downloaded"
    },
    {
      "given": "Audit logs are being stored",
      "when": "The retention policy is applied",
      "then": "Audit logs are retained for a default period of 12-24 months"
    },
    {
      "given": "An Enterprise customer requests extended audit log retention",
      "when": "The request is processed",
      "then": "The system allows for longer retention periods for the Enterprise customer"
    },
    {
      "given": "Existing tenant-scoped tables in the database",
      "when": "A schema migration is executed",
      "then": "'teamId' and 'workspaceId' columns are added to these tables, allowing null values initially, and appropriate indexes are created"
    },
    {
      "given": "Existing ContentItem records without a 'teamId'",
      "when": "The backfill script is executed for ContentItem",
      "then": "The 'teamId' for each ContentItem is derived from its associated workspace or owner team membership and backfilled"
    },
    {
      "given": "A large volume of data needs backfilling for 'teamId' and 'workspaceId'",
      "when": "The backfill script is executed",
      "then": "The backfill runs in batches, logs its progress, and allows for manual inspection of any mismatches or inconsistencies"
    },
    {
      "given": "A user with an 'Editor' role is logged in.",
      "when": "The user attempts to create content in a workspace to which they are assigned.",
      "then": "The content is successfully created in that workspace."
    },
    {
      "given": "A user with an 'Editor' role is logged in.",
      "when": "The user attempts to modify content or settings in a workspace to which they are not assigned.",
      "then": "The system returns a '403 Forbidden' error, and the modification is not performed."
    },
    {
      "given": "There is only one seat remaining in a team.",
      "when": "Multiple users simultaneously attempt to accept an invitation to join the team.",
      "then": "Only one user successfully accepts the invitation and becomes a team member, and the remaining seat count becomes zero. Other users attempting to accept the invitation receive an error (e.g., 'no seats available')."
    },
    {
      "given": "A user creates a new template.",
      "when": "The user saves the template with a scope set to 'Team'.",
      "then": "All other members of that team can view and access the newly created template."
    },
    {
      "given": "A user creates a new template.",
      "when": "The user saves the template with a scope set to 'Workspace'.",
      "then": "Only members of that specific workspace can view and access the newly created template, and other team members outside the workspace cannot."
    },
    {
      "given": "A user performs a key action (e.g., creating content, inviting a member, publishing).",
      "when": "The action is successfully completed.",
      "then": "An 'AuditLog' entry is written with the correct 'actorId', 'teamId', 'workspaceId', 'action', 'targetType', 'targetId', and relevant metadata."
    },
    {
      "given": "An administrator creates an invitation for a new user.",
      "when": "The new user accepts the invitation via LinkedIn authentication.",
      "then": "A 'TeamMember' record is created for the user, and the total available seats for the team are decremented."
    },
    {
      "given": "A user creates a new workspace.",
      "when": "The new workspace is successfully created.",
      "then": "The new workspace starts with its own distinct set of templates and content, entirely separate and isolated from other existing workspaces."
    },
    {
      "given": "A user has an existing workspace with associated content and templates.",
      "when": "The user deletes the workspace.",
      "then": "The workspace, along with all its associated content and templates, is permanently removed, and other workspaces are unaffected."
    },
    {
      "given": "A user belongs to Team A.",
      "when": "The user attempts to retrieve content (e.g., via API) by guessing or specifying an ID that belongs to Team B.",
      "then": "The system returns a '403 Forbidden' error or an empty result, ensuring no sensitive data from Team B is leaked to the user in Team A."
    },
    {
      "given": "The system is under heavy publishing load (e.g., many users publishing content simultaneously).",
      "when": "Key actions trigger audit log writes.",
      "then": "The audit logging mechanism successfully handles the high volume of write requests without significant performance degradation or data loss."
    },
    {
      "given": "The system is configured for SCIM provisioning.",
      "when": "A large batch of users is provisioned simultaneously, especially near the seat capacity limit.",
      "then": "The SCIM provisioning process correctly manages seat allocation and concurrency, ensuring that the seat enforcement policies are upheld without over-provisioning or race conditions."
    },
    {
      "given": "A user is viewing analytics.",
      "when": "No specific team or workspace filter is applied by default, or the user selects a specific workspace.",
      "then": "The displayed analytics data is filtered to show only information relevant to the currently selected or default workspace."
    },
    {
      "given": "Row-Level Security (RLS) policies are enabled on the database.",
      "when": "A database user attempts to directly access rows from a team to which they do not belong (e.g., via SQL query).",
      "then": "The RLS policies prevent the database user from retrieving or modifying data belonging to other teams, enforcing data isolation at the database level."
    },
    {
      "given": "A user is logged in and has access to their \"My Space\" personal workspace.",
      "when": "The user creates a new template and saves it as a \"My Space Template\" (personal scope).",
      "then": "The template is stored in the user's personal workspace, is visible only to that user, and is inaccessible to any other user or team member."
    },
    {
      "given": "A user has one or more \"My Space Templates\".",
      "when": "The user attempts to create, edit, delete, version, or instantiate one of their personal templates when creating new content.",
      "then": "The user can successfully perform all these actions on their personal templates."
    },
    {
      "given": "A user has a \"My Space Template\" and has write rights to a specific workspace.",
      "when": "The user attempts to promote their personal template to the scope of that workspace.",
      "then": "The template is successfully promoted and becomes visible to all members of that specific workspace."
    },
    {
      "given": "A user has a \"My Space Template\".",
      "when": "The user attempts to promote their personal template to a team-wide or global scope, requiring admin approval.",
      "then": "An admin approval process is initiated, and upon approval, the template becomes visible to all team members or globally, respectively."
    },
    {
      "given": "A template is created or updated.",
      "when": "The template is saved.",
      "then": "It includes metadata such as type, category, industry, placeholders, and a preview image."
    },
    {
      "given": "A template is marked as promoted.",
      "when": "The template is saved.",
      "then": "Performance statistics can be associated with the template."
    },
    {
      "given": "A user belonging to a team creates a template within a team workspace.",
      "when": "The template is saved.",
      "then": "The template's storage is isolated and associated with the teamId, and it always has an ownerId."
    },
    {
      "given": "An individual user (not part of a team) creates a template in their 'My Space'.",
      "when": "The template is saved.",
      "then": "The template's storage is associated with the ownerId (the user's ID)."
    },
    {
      "given": "A user is actively editing a template.",
      "when": "The user makes modifications to the template.",
      "then": "The template edits are automatically saved at regular intervals."
    },
    {
      "given": "A user is actively editing a template.",
      "when": "The user makes modifications to the template over time.",
      "then": "Previous versions of the template are maintained for rollback or history."
    },
    {
      "given": "A user has created personal templates and also has access to team-shared templates.",
      "when": "The user searches for templates using the template picker.",
      "then": "The search results prioritize and display the user's personal templates first."
    },
    {
      "given": "A new user registers for the service.",
      "when": "The user logs in for the first time.",
      "then": "A private 'My Space' workspace is automatically created as their default workspace."
    },
    {
      "given": "A user stores data within their 'My Space' workspace.",
      "when": "The user has not explicitly promoted or shared the data.",
      "then": "All data stored within 'My Space' remains private to the user."
    },
    {
      "given": "An organization has an Enterprise plan.",
      "when": "The team administrator configures workspaces for the team.",
      "then": "Multiple team-scoped 'Team Spaces' can be created."
    },
    {
      "given": "Multiple team members are collaborating within a 'Team Space'.",
      "when": "They create and share content within that space.",
      "then": "Templates, content, and analytics within these 'Team Spaces' are shared among team members."
    },
    {
      "given": "A user is attempting to upload a new file (e.g., an image or content item).",
      "when": "The user's or team's allocated storage quota is nearly full or already exceeded, and an upload request is initiated.",
      "then": "The system prevents the upload due to insufficient quota."
    },
    {
      "given": "A user attempts to upload a file while their quota is exceeded.",
      "when": "The upload is prevented.",
      "then": "The UI displays an error message along with an option to upgrade the plan."
    },
    {
      "given": "A user is viewing their account or workspace settings.",
      "when": "The UI loads the storage information.",
      "then": "A visual usage meter is displayed, showing the current storage consumption relative to the total allocated quota."
    },
    {
      "given": "StorageUsedBytes fields are updated transactionally during content creation/deletion.",
      "when": "A scheduled background job runs for storage reconciliation.",
      "then": "The system verifies and corrects any discrepancies between the stored storageUsedBytes values and the actual disk usage."
    },
    {
      "given": "A user is on an 'Individual' (free or normal) plan.",
      "when": "The user's storage quota is determined.",
      "then": "The user is allocated a personal storage quota of 5 GB."
    },
    {
      "given": "A user is on a 'Pro' plan.",
      "when": "The user's storage quota is determined.",
      "then": "The user is allocated a personal storage quota of 50 GB."
    },
    {
      "given": "An organization is on an 'Enterprise' plan.",
      "when": "The team's storage quota is determined.",
      "then": "The team is allocated a base storage quota of 100 GB, shared across all team members and workspaces."
    },
    {
      "given": "An organization is on an 'Enterprise' plan.",
      "when": "They require more storage than the base quota.",
      "then": "Additional storage can be provisioned via per-seat add-ons."
    },
    {
      "given": "A user uploads content into a 'Team Space' associated with an Enterprise team.",
      "when": "The content is successfully stored.",
      "then": "The storage used is deducted from the Team.storageUsedBytes and contributes to the overall Team.storageQuotaBytes."
    },
    {
      "given": "A user attempts to perform any read or write operation on content or data.",
      "when": "The request is processed by the system.",
      "then": "The operation is automatically scoped by teamId or workspaceId."
    },
    {
      "given": "A user attempts to perform any read or write operation on content or data.",
      "when": "The request is processed by the system.",
      "then": "Role-Based Access Control (RBAC) rules are enforced to ensure the user has the necessary permissions."
    },
    {
      "given": "Content or images are uploaded and stored in external services like S3 or Supabase.",
      "when": "The system determines the storage location.",
      "then": "The upload paths, S3/Supabase buckets, and keys are physically separated or logically namespaced to ensure data isolation per user or team (e.g., 'teams/{teamId}/workspaces/{workspaceId}/images/{id}.jpg' or 'users/{userId}/images/{id}.jpg')."
    },
    {
      "given": "A user or team's storage usage changes or they approach/exceed their quota.",
      "when": "The system detects these quota-related events.",
      "then": "Billing records are updated for quota changes and overages."
    },
    {
      "given": "An administrator wishes to monitor storage usage.",
      "when": "The administrator accesses the admin UI.",
      "then": "The admin UI provides a detailed view of storage usage per user and per team."
    },
    {
      "given": "A user or team is nearing their storage quota.",
      "when": "The system detects this condition.",
      "then": "Notifications are sent to alert the users/teams."
    },
    {
      "given": "A user has a personal quota of X bytes and has Y bytes used, where Y < X.",
      "when": "The user attempts to upload a file of size S bytes to 'My Space' where S <= (X - Y).",
      "then": "The upload is allowed, and User.storageUsedBytes is incremented by S (as reserved)."
    },
    {
      "given": "A user has a personal quota of X bytes and has Y bytes used, where Y < X.",
      "when": "The user attempts to upload a file of size S bytes to 'My Space' where S > (X - Y).",
      "then": "The upload is blocked with a 422 response, and a 'Quota exceeded, upgrade' CTA is shown."
    },
    {
      "given": "A workspace has a specific quota of X bytes and has Y bytes used, where Y < X.",
      "when": "A user attempts to upload a file of size S bytes to this workspace where S <= (X - Y).",
      "then": "The upload is allowed, and workspace.storageUsedBytes is incremented by S (as reserved)."
    },
    {
      "given": "A workspace has a specific quota of X bytes and has Y bytes used, where Y < X.",
      "when": "A user attempts to upload a file of size S bytes to this workspace where S > (X - Y).",
      "then": "The upload is blocked with a 422 response, and a 'Quota exceeded, upgrade' CTA is shown."
    },
    {
      "given": "A team workspace does not have a specific workspace quota, but its associated team has a quota of X bytes and has Y bytes used, where Y < X.",
      "when": "A user attempts to upload a file of size S bytes to this team workspace where S <= (X - Y).",
      "then": "The upload is allowed, and team.storageUsedBytes is incremented by S (as reserved)."
    },
    {
      "given": "A team workspace does not have a specific workspace quota, but its associated team has a quota of X bytes and has Y bytes used, where Y < X.",
      "when": "A user attempts to upload a file of size S bytes to this team workspace where S > (X - Y).",
      "then": "The upload is blocked with a 422 response, and a 'Quota exceeded, upgrade' CTA is shown."
    },
    {
      "given": "The system is configured to allow overage billing, and a user/workspace/team has exhausted its quota.",
      "when": "The user attempts to upload a file that exceeds the remaining quota.",
      "then": "The upload is allowed, and the system integrates with billing to charge for the overage."
    },
    {
      "given": "The system is configured NOT to allow overage billing, and a user/workspace/team has exhausted its quota.",
      "when": "The user attempts to upload a file that exceeds the remaining quota.",
      "then": "The upload is blocked with a 422 response, and a 'Quota exceeded, upgrade' CTA is shown."
    },
    {
      "given": "A file exists and consumes storage from a user/workspace/team, which has N bytes used.",
      "when": "The file is successfully deleted.",
      "then": "The corresponding storageUsedBytes counter (user/workspace/team) is decremented by the file's size, and the image record is marked as deleted."
    },
    {
      "given": "An admin user is authenticated.",
      "when": "The admin grants temporary extra quota to a user or team.",
      "then": "The extra quota is applied, and a record is created in the TeamFeature or QuotaOverride model with an expiry date."
    },
    {
      "given": "A user requests an upload URL for a file of 'sizeBytes', and the 'sizeBytes' is within the determined effective quota.",
      "when": "The server receives a POST request to '/api/media/upload-url' with valid 'workspaceId', 'fileName', 'contentType', and 'sizeBytes'.",
      "then": "The server responds with a 200 OK, returns a presigned URL, creates an Image record in DB in 'uploading' state, and increments the relevant 'storageUsedBytes' (user/workspace/team) by 'sizeBytes' within a transaction."
    },
    {
      "given": "A user requests an upload URL for a file of 'sizeBytes', and the 'sizeBytes' exceeds the determined effective quota.",
      "when": "The server receives a POST request to '/api/media/upload-url' with valid 'workspaceId', 'fileName', 'contentType', and 'sizeBytes'.",
      "then": "The server responds with a 422 status code, including 'quotaExceeded', 'availableBytes', and either 'upgradeUrl' or 'billingInfo'."
    },
    {
      "given": "A file was successfully uploaded to storage using a presigned URL, and an Image record exists in 'uploading' state with reserved 'storageUsedBytes'.",
      "when": "The client calls 'POST /api/media/confirm-upload' with the 'imageId' (or a storage webhook triggers confirmation).",
      "then": "The Image.state is updated to 'available', and the reserved 'storageUsedBytes' remains allocated."
    },
    {
      "given": "An Image record exists in 'uploading' state with reserved 'storageUsedBytes', but the actual upload to storage failed or timed out within its TTL.",
      "when": "A background job runs to clean stale uploading images.",
      "then": "The Image record is removed or marked as failed, and the reserved 'storageUsedBytes' is decremented from the relevant counter (user/workspace/team)."
    },
    {
      "given": "A user has permissions to delete 'imageId', and an Image record with 'imageId' exists, consuming storage from a user/workspace/team.",
      "when": "The user sends a DELETE request to '/api/media/:id' for that 'imageId'.",
      "then": "The system verifies permissions, initiates an asynchronous deletion from storage, marks 'Image.deleted = true', and decrements the relevant 'storageUsedBytes' (user/workspace/team) by the file's size, all within a transaction."
    },
    {
      "given": "A discrepancy exists between 'storageUsedBytes' in the database and the actual storage consumed (e.g., due to failed deletes or orphaned files).",
      "when": "A periodic background worker runs to reconcile storage usage.",
      "then": "The worker rescans storage or recomputes usage from the database, corrects the 'storageUsedBytes' counters to reflect actual usage, and alerts if the drift exceeds a predefined threshold."
    },
    {
      "given": "A user or team has a subscription that is upgraded, increasing their 'storageQuotaBytes'.",
      "when": "A Stripe webhook notifies the system of the subscription change.",
      "then": "User.storageQuotaBytes or Team.storageQuotaBytes is updated to the new, higher value."
    },
    {
      "given": "A user or team has a subscription that is downgraded, decreasing their 'storageQuotaBytes' below their current 'storageUsedBytes', and overage billing is not allowed. A grace period is in effect.",
      "when": "A Stripe webhook notifies the system of the subscription change, and the grace period expires.",
      "then": "Admins are notified, and new uploads for that user/team are disabled until usage is resolved."
    },
    {
      "given": "A user or team has a subscription that is downgraded, decreasing their 'storageQuotaBytes' below their current 'storageUsedBytes', and overage billing is allowed.",
      "when": "A Stripe webhook notifies the system of the subscription change.",
      "then": "Admins are notified, and the system automatically charges for the overage based on policy."
    },
    {
      "given": "A user is authenticated.",
      "when": "The user sends a GET request to '/api/usage/me'.",
      "then": "The system returns the user's total 'userUsedBytes' and 'userQuotaBytes', and a list of workspaces with their 'id', 'used' bytes, and 'quota' bytes. If applicable, 'teamUsedBytes' and 'teamQuotaBytes' are also included."
    },
    {
      "given": "An authenticated admin user.",
      "when": "The admin sends a GET request to '/api/teams/:teamId/usage'.",
      "then": "The system returns a usage breakdown for the specified team, including total usage, quota, and potentially top consumers within that team."
    },
    {
      "given": "Overage billing is allowed, and a user/team changes their subscription such that an overage charge is triggered.",
      "when": "The system detects the need for an overage charge or prorated charge for additional quota.",
      "then": "The system calls 'PATCH /api/billing/teams/:teamId/seats' or 'POST /api/billing/teams/:teamId/overage-charge' to create an invoice/charge in Stripe, and records the transaction in 'QuotaCharge'."
    },
    {
      "given": "A user initiates an image upload within a workspace.",
      "when": "The system attempts to reserve storage for the image.",
      "then": "An 'uploading' image record is created, and the workspace's 'storageUsedBytes' counter is incremented."
    },
    {
      "given": "A user initiates an image upload within a team, and the workspace does not have a specific storage quota.",
      "when": "The system attempts to reserve storage for the image.",
      "then": "An 'uploading' image record is created, and the team's 'storageUsedBytes' counter is incremented."
    },
    {
      "given": "A user initiates an image upload, and neither a workspace nor a team has a specific storage quota.",
      "when": "The system attempts to reserve storage for the image.",
      "then": "An 'uploading' image record is created, and the user's 'storageUsedBytes' counter is incremented."
    },
    {
      "given": "An image upload has been successfully completed and its storage reserved.",
      "when": "The system confirms the upload.",
      "then": "The image's state is updated to 'available', and 'uploadedAt' timestamp is set, with no changes to storage counters."
    },
    {
      "given": "An image upload was initiated and storage was reserved, but the upload needs to be canceled.",
      "when": "The user or system initiates an upload cancellation.",
      "then": "The image record is deleted, and the corresponding workspace, team, or user's 'storageUsedBytes' counter is decremented."
    },
    {
      "given": "A user is viewing 'My Space'.",
      "when": "The global chrome is displayed.",
      "then": "The quota meter shows \"You’ve used X of Y (My Space)\"."
    },
    {
      "given": "A user is viewing a 'Team Workspace'.",
      "when": "The global chrome is displayed.",
      "then": "The quota meter shows \"Team usage: X of Y (Team)\" and \"Workspace: a of b\"."
    },
    {
      "given": "A user's current scope has storage usage below 80% of its quota.",
      "when": "The global chrome quota meter is displayed.",
      "then": "The quota meter is color-coded green."
    },
    {
      "given": "A user's current scope has storage usage between 80% and 95% of its quota.",
      "when": "The global chrome quota meter is displayed.",
      "then": "The quota meter is color-coded yellow."
    },
    {
      "given": "A user's current scope has storage usage above 95% of its quota.",
      "when": "The global chrome quota meter is displayed.",
      "then": "The quota meter is color-coded red."
    },
    {
      "given": "A user has permission to upgrade storage.",
      "when": "The quota meter is displayed.",
      "then": "An 'Upgrade' CTA button is visible."
    },
    {
      "given": "A user does not have permission to upgrade storage directly.",
      "when": "The quota meter is displayed.",
      "then": "A 'Request more storage' CTA button is visible."
    },
    {
      "given": "A user picks an image to upload, and the server responds with 'quotaExceeded' when calling '/api/media/upload-url'.",
      "when": "The client receives the 'quotaExceeded' response.",
      "then": "A modal is displayed with the message \"Upload blocked — you have X available; file is Y. [Upgrade] [Optimize image & retry]\", offering options to compress or pick a smaller file."
    },
    {
      "given": "A user picks an image to upload, and the server allows the upload.",
      "when": "The client proceeds with the upload.",
      "then": "Upload progress is displayed, and upon success, the image appears in the editor."
    },
    {
      "given": "An upload reservation was created successfully, but the final upload confirmation fails (e.g., timeout).",
      "when": "The system detects the failed confirmation.",
      "then": "An error is shown to the user, and the UI is reverted to its state before the upload attempt."
    },
    {
      "given": "A team admin navigates to the 'Team Settings -> Usage & Billing' page.",
      "when": "The page loads.",
      "then": "The page displays a summary of seats used/purchased, team storage used/quota, a daily storage used trend chart, and a table of top storage consumers with management options."
    },
    {
      "given": "A team admin is on the 'Usage & Billing' page.",
      "when": "The admin clicks the 'Increase Storage' button.",
      "then": "The billing flow (Stripe checkout) prefilled with storage add-on options is opened."
    },
    {
      "given": "A team admin is on the 'Usage & Billing' page.",
      "when": "The admin clicks the 'Assign storage to workspace' button.",
      "then": "An interface for allocating per-workspace override quotas is displayed."
    },
    {
      "given": "A team admin is on the 'Usage & Billing' page.",
      "when": "The admin clicks the 'Force delete orphaned files' button.",
      "then": "The system initiates the process to delete orphaned files."
    },
    {
      "given": "Team storage usage exceeds 80% of the quota.",
      "when": "The system detects high storage usage.",
      "then": "The admin receives an alert notification."
    },
    {
      "given": "There is a high rate of upload failures caused by quota limits.",
      "when": "The system detects a high rate of quota-related upload failures.",
      "then": "The admin receives an alert notification."
    },
    {
      "given": "A user navigates to their 'My Space' page.",
      "when": "The page loads.",
      "then": "The page displays personal templates, content, images, a storage meter with used/quota and a 'Manage files' link, and an 'Optimize images' quick action."
    },
    {
      "given": "A user is viewing their 'My Space' page and is near their storage quota.",
      "when": "The page loads.",
      "then": "Tips such as 'delete drafts', 'compress images', or 'upgrade' are displayed."
    },
    {
      "given": "A user initiates an upgrade through the 'Upgrade' button.",
      "when": "The user completes the payment via the billing checkout.",
      "then": "A Stripe webhook updates the 'Team.storageQuotaBytes' or 'User.storageQuotaBytes' accordingly."
    },
    {
      "given": "A downgrade of storage quota is initiated, and the current storage used exceeds the new quota.",
      "when": "The system processes the downgrade.",
      "then": "The admin/user is notified with options to delete files, buy an add-on, or accept scheduled deletion, without automatic deletion unless policy dictates."
    },
    {
      "given": "A user attempts to read or write a resource within a workspace of type 'MY_SPACE'.",
      "when": "The authMiddleware validates the request.",
      "then": "The request is only authorized if 'ownerUserId' of the resource matches the 'currentUser.id'."
    },
    {
      "given": "A user attempts to read or write a resource within a workspace that has a 'teamId'.",
      "when": "The authMiddleware validates the request.",
      "then": "The request is only authorized if the user is a member of that team and has an appropriate role."
    },
    {
      "given": "A database connection is established for a user.",
      "when": "'app.current_team' and 'app.current_user' are set in the connection context.",
      "then": "RLS policies restrict access to data based on team, workspace, and owner, providing an extra layer of security."
    },
    {
      "given": "Existing images and files are stored in S3.",
      "when": "A batch job is executed.",
      "then": "storageUsedBytes columns for User, Team, and Workspace are populated with the sum of sizes for existing data."
    },
    {
      "given": "Users have existing plans and teams exist.",
      "when": "The system initializes storage quotas.",
      "then": "User.storageQuotaBytes is set per user plan, and Team.storageQuotaBytes is set for teams."
    },
    {
      "given": "Storage quota enforcement is deployed.",
      "when": "A user attempts to upload a file via the /api/media/upload-url endpoint.",
      "then": "The system checks the user's/team's quota and implements a \"reserve-on-upload\" behavior."
    },
    {
      "given": "A user's current storage usage plus the size of the new file exceeds their allocated quota.",
      "when": "The user attempts to upload the new file.",
      "then": "The upload attempt is blocked, and the system returns a 422 quotaExceeded response before generating a presigned URL."
    },
    {
      "given": "A user has remaining quota for a single file, but two parallel uploads would together exceed the quota.",
      "when": "Two uploads are initiated concurrently.",
      "then": "Only one reservation is successfully made, ensuring the final state correctly reflects the quota, and the other upload is blocked or fails atomically."
    },
    {
      "given": "A file is stored and its size contributes to a user's or team's storageUsedBytes counter.",
      "when": "The file is deleted via DELETE /api/media/:id.",
      "then": "The corresponding storageUsedBytes counter is atomically decremented."
    },
    {
      "given": "A user's current storage usage is greater than the quota of their new, downgraded plan.",
      "when": "The user downgrades their subscription plan.",
      "then": "An admin is notified of the quota overage for that user."
    },
    {
      "given": "A user is on an Individual plan (e.g., 5GB) and has uploaded files until their usage is near the quota.",
      "when": "The user attempts to upload a file larger than their remaining quota via the UI.",
      "then": "The UI blocks the upload and displays an \"upgrade CTA\" (Call To Action) to purchase more storage."
    },
    {
      "given": "A user is a member of an Enterprise team with a team workspace.",
      "when": "The user uploads a file to the team workspace.",
      "then": "The team's storageUsedBytes counter is incremented, and the user's individual storageUsedBytes counter remains unchanged."
    },
    {
      "given": "A file exists in a user's \"My Space\" and contributes to their individual storageUsedBytes.",
      "when": "The file is promoted from \"My Space\" to a \"Team Space\".",
      "then": "The user's storageUsedBytes is decremented, and the team's storageUsedBytes is incremented by the file's size, ensuring counters are moved accurately."
    },
    {
      "given": "Many users are performing simultaneous uploads to their respective spaces.",
      "when": "Multiple concurrent uploads are simulated across multiple users.",
      "then": "The storageUsedBytes counters for users and teams remain consistent, and no race conditions lead to incorrect usage totals."
    },
    {
      "given": "A team's storageUsedBytes exceeds 90% of its storageQuotaBytes.",
      "when": "The system monitors storage metrics.",
      "then": "An email alert is sent to the admin, and an in-app alert is displayed."
    },
    {
      "given": "The reconciliation_drift_bytes (difference between actual storage and DB counters) exceeds 5%.",
      "when": "The reconciliation job runs.",
      "then": "An alert is triggered for ops to investigate, and the reconciliation job corrects the mismatches to achieve less than 1% drift."
    },
    {
      "given": "A sudden increase (spike) is detected in upload_blocked_quota_exceeded events.",
      "when": "The system monitors upload event metrics.",
      "then": "An alert is triggered for product and ops teams to investigate potential pricing issues or unexpected user behavior."
    },
    {
      "given": "Content exists in both \"My Space\" and \"Team Space\".",
      "when": "A user views their content and team content.",
      "then": "\"My Space\" content is only visible to its owner (unless promoted), and \"Team Space\" content is clearly separated and visible to team members in both the UI and DB."
    },
    {
      "given": "An admin accesses the admin UI or the /api/teams/:teamId/usage endpoint.",
      "when": "The admin requests storage usage information for a team or workspace.",
      "then": "The UI or API displays accurate teamUsedBytes, teamQuotaBytes, and top consumers per team and per workspace."
    },
    {
      "given": "A team admin wants to increase their team's storage quota.",
      "when": "The team admin initiates a purchase for more storage (e.g., via POST /api/billing/teams/:teamId/add-storage) through Stripe.",
      "then": "A Stripe checkout/session is created, and after successful payment, the Stripe webhook handler updates the Team.storageQuotaBytes."
    },
    {
      "given": "A user is logged into their account.",
      "when": "The user navigates to their billing or subscription settings.",
      "then": "They can view their current subscription status, access invoices, and update their payment methods."
    },
    {
      "given": "A user is on a \"Normal\" subscription tier.",
      "when": "The user chooses to upgrade to a \"Pro\" plan.",
      "then": "Their subscription is upgraded with prorated billing applied, and new features (e.g., advanced analytics, unlimited AI, team collaboration) become available."
    },
    {
      "given": "A user is on a \"Pro\" subscription tier.",
      "when": "The user chooses to downgrade to a \"Normal\" plan.",
      "then": "Their subscription is downgraded with prorated billing applied, and features exclusive to the \"Pro\" plan are restricted."
    },
    {
      "given": "A user or team has changed their subscription plan or purchased additional storage.",
      "when": "A Stripe webhook notification is received for a billing event.",
      "then": "The system updates User.storageQuotaBytes or Team.storageQuotaBytes accordingly."
    },
    {
      "given": "A user selects a new subscription plan (e.g., Individual Pro).",
      "when": "The user completes the checkout process with a valid payment method.",
      "then": "A new subscription is created in Stripe, the corresponding BillingAccount and Subscription records are created in the local database, and the user's entitlements are activated."
    },
    {
      "given": "A user has an active subscription (e.g., Individual Normal).",
      "when": "The user selects to upgrade to a higher plan (e.g., Individual Pro) and confirms the change.",
      "then": "The subscription is updated in Stripe, proration is applied for the upgrade, the local Subscription record is updated, and the user's entitlements are adjusted immediately."
    },
    {
      "given": "A user has an active subscription (e.g., Individual Pro).",
      "when": "The user selects to downgrade to a lower plan (e.g., Individual Normal) and confirms the change.",
      "then": "The subscription is updated in Stripe to reflect the downgrade at the next billing period end, proration is applied if applicable, the local Subscription record is updated, and the user's entitlements reflect the current active plan until the next period."
    },
    {
      "given": "A user has an active BillingAccount.",
      "when": "The user updates their default payment method or adds a new one via the billing UI.",
      "then": "The payment method details are securely updated in Stripe, and the 'defaultPaymentMethod' field in the local BillingAccount record is updated."
    },
    {
      "given": "A Stripe webhook event (e.g., 'customer.subscription.updated' or 'invoice.payment_succeeded') is received.",
      "when": "The system processes the webhook event.",
      "then": "The local database's Subscription status, seat count, or QuotaOverrides are updated, and the user's or team's feature flags, quotas, and seat counts are automatically adjusted."
    },
    {
      "given": "A duplicate Stripe webhook event is received by the system.",
      "when": "The webhook processing logic attempts to handle the event.",
      "then": "The event is recognized as a duplicate and processed only once, preventing data inconsistencies or duplicate actions."
    },
    {
      "given": "A team has an active Enterprise plan with seat-based billing.",
      "when": "The team administrator adds additional seats to their subscription via the admin panel.",
      "then": "The subscription quantity is updated in Stripe, the team's BillingAccount is charged proratedly for the additional seats, and the 'seats' count in the local Subscription record is increased."
    },
    {
      "given": "A logged-in user with an active subscription.",
      "when": "The user navigates to the 'Billing' section of their account UI.",
      "then": "The user can view their current plan, change their plan, access past invoices, and update their payment card details."
    },
    {
      "given": "A logged-in team administrator.",
      "when": "The administrator navigates to their team's 'Billing' section.",
      "then": "The administrator can view the team's current seats, usage metrics (if applicable), and manage past invoices."
    },
    {
      "given": "A logged-in SaaS administrator.",
      "when": "The administrator accesses the global admin dashboard.",
      "then": "The administrator can view global revenue metrics, subscription counts, and other operational insights."
    },
    {
      "given": "A user or team has a subscription plan with specific quotas (e.g., 'Pro' plan allows 100 API calls/month).",
      "when": "The user/team attempts to perform an action that would exceed their defined quota.",
      "then": "The system prevents the action and provides a message indicating the quota limit."
    },
    {
      "given": "A user or administrator performs a significant billing-related action (e.g., plan change, payment method update, seat adjustment).",
      "when": "The action is successfully processed by the system.",
      "then": "An immutable audit log entry is created, detailing the action, the actor, the timestamp, and relevant changes for strong accountability."
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a GET request to /api/billing/account",
      "then": "The system returns the BillingAccount information for the current user/team context"
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a GET request to /api/billing/subscription",
      "then": "The system returns a list of current subscription(s) and associated entitlements for the user/team"
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a POST request to /api/billing/create-checkout-session with billingAccountId, planId, recurringInterval, and optional seats",
      "then": "The system creates a Stripe Checkout session and returns its checkoutUrl"
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a POST request to /api/billing/update-payment-method",
      "then": "The system initiates a Stripe SetupIntent or redirects to the Stripe Billing Portal for payment method update"
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a GET request to /api/billing/invoices",
      "then": "The system returns a list of invoices for their billing account"
    },
    {
      "given": "A user is authenticated and has the 'user' role",
      "when": "They make a GET request to /api/billing/invoices/:id/pdf for a specific invoice ID",
      "then": "The system returns the URL to the PDF version of the requested invoice"
    },
    {
      "given": "A user is authenticated, has the 'user' role, and an active subscription",
      "when": "They make a POST request to /api/billing/cancel-subscription",
      "then": "The system cancels the subscription either at the period end or immediately, as specified"
    },
    {
      "given": "A user is authenticated, has the 'user' role, and a seat-based subscription",
      "when": "They make a POST request to /api/billing/change-seats to modify the number of seats",
      "then": "The system updates the Stripe subscription with the new quantity, applying proration accordingly"
    },
    {
      "given": "A user is authenticated, has the 'user' role, and an active subscription",
      "when": "They make a POST request to /api/billing/change-plan to upgrade or downgrade their plan",
      "then": "The system updates the Stripe subscription with the new plan, applying proration behavior based on policy"
    },
    {
      "given": "An admin or SaaS admin is authenticated and has the correct role",
      "when": "They make a GET request to /api/admin/billing/tenants",
      "then": "The system returns a list of tenant billing accounts, their status, and MRR"
    },
    {
      "given": "An admin or SaaS admin is authenticated and has the correct role",
      "when": "They make a POST request to /api/admin/billing/create-override",
      "then": "The system creates a QuotaOverride for a specified account, granting storage or AI credits"
    },
    {
      "given": "An admin or SaaS admin is authenticated and has the correct role",
      "when": "They make a POST request to /api/admin/billing/reconcile",
      "then": "The system triggers a reconciliation run for billing data"
    },
    {
      "given": "A Stripe webhook event is received by the system",
      "when": "The system processes the POST request to /api/webhooks/stripe",
      "then": "The system processes the event idempotently and updates relevant billing records (e.g., BillingEvent, Subscription, BillingAccount)"
    },
    {
      "given": "A user initiates a checkout flow",
      "when": "A Stripe Checkout Session is created",
      "then": "The system creates a new Stripe Customer or reuses an existing one for the billing account"
    },
    {
      "given": "A Stripe Checkout Session is created",
      "when": "The checkout session is finalized",
      "then": "The system attaches metadata linking to the teamId or billingAccountId for traceability"
    },
    {
      "given": "The system receives a 'checkout.session.completed' webhook from Stripe",
      "when": "The webhook is processed",
      "then": "The system creates or updates the Subscription and BillingAccount based on the session details"
    },
    {
      "given": "A user requests a plan upgrade",
      "when": "The Stripe Subscription API is called to update the subscription",
      "then": "The system applies immediate proration, charging the prorated amount immediately"
    },
    {
      "given": "A user requests a plan downgrade",
      "when": "The Stripe Subscription API is called to update the subscription with proration_behavior",
      "then": "The system either applies proration and credit, or schedules the change at period end, based on the defined product policy"
    },
    {
      "given": "A user needs to update their payment method",
      "when": "The payment method update process is initiated",
      "then": "The system uses the Stripe Billing Portal or a SetupIntent, ensuring PCI-safety by not accepting raw card data on the server"
    },
    {
      "given": "The system receives 'invoice.created' or 'invoice.paid' webhook events from Stripe",
      "when": "These webhook events are processed",
      "then": "The system mirrors the Invoice objects in its database, storing the hosted invoice URL and PDF URL"
    },
    {
      "given": "A user has an active subscription.",
      "when": "Stripe sends an 'invoice.payment_failed' webhook event.",
      "then": "The subscription is marked as 'past_due'.",
      "and": "Admins and the user are notified."
    },
    {
      "given": "The application receives a Stripe webhook request.",
      "when": "The webhook signature is validated using the 'STRIPE_ENDPOINT_SECRET'.",
      "then": "The event processing proceeds if the signature is valid.",
      "and": "The request is rejected if the signature is invalid."
    },
    {
      "given": "The application receives a Stripe webhook event.",
      "when": "The 'stripeEvent.id' already exists in the 'BillingEvent' table.",
      "then": "The application responds with a 200 status code.",
      "and": "The event's business logic is skipped, ensuring idempotency."
    },
    {
      "given": "A valid, non-duplicate Stripe webhook event is received.",
      "when": "The webhook handler processes the event.",
      "then": "A 'BillingEvent' record is created for the 'stripeEvent.id'.",
      "and": "The transaction is committed upon successful execution."
    },
    {
      "given": "The application receives a 'checkout.session.completed' webhook event.",
      "when": "The event is processed.",
      "then": "The associated CheckoutSession is retrieved.",
      "and": "A new 'Subscription' is created."
    },
    {
      "given": "The application receives a 'customer.subscription.created', 'updated', or 'deleted' webhook event.",
      "when": "The event is processed.",
      "then": "The 'Subscription' table is updated to reflect the new state of the subscription."
    },
    {
      "given": "The application receives an 'invoice.created', 'invoice.finalized', or 'invoice.paid' webhook event.",
      "when": "The event is processed.",
      "then": "The 'Invoice' table is updated or a new invoice record is created.",
      "and": "Relevant notifications are sent (e.g., invoice created/paid)."
    },
    {
      "given": "The application receives an 'invoice.payment_failed' webhook event.",
      "when": "The event is processed.",
      "then": "The 'Invoice' table is updated to reflect the failed payment status.",
      "and": "Admins and the user are notified."
    },
    {
      "given": "The application receives a 'payment_method.attached' webhook event.",
      "when": "The event is processed.",
      "then": "The default payment method in the 'BillingAccount' is updated."
    },
    {
      "given": "The application receives a 'charge.refunded' webhook event.",
      "when": "The event is processed.",
      "then": "The associated 'Invoice' records are updated to reflect the refund.",
      "and": "A 'BillingAudit' entry is created."
    },
    {
      "given": "The application receives an 'invoice.payment_action_required' or 'payment_intent.requires_action' webhook event.",
      "when": "The event is processed.",
      "then": "The need for a payment action is surfaced in the UI to facilitate SCA flows."
    },
    {
      "given": "A subscription event has been successfully processed.",
      "when": "The system updates entitlements and caches.",
      "then": "Feature flags (e.g., AI credits, analytics depth, multi-workspace) are enabled/disabled based on 'planId'.",
      "and": "Changes are propagated to in-memory caches or Redis immediately."
    },
    {
      "given": "A user navigates to the '/settings/billing' route.",
      "when": "The Billing Dashboard page loads.",
      "then": "The current plan card is displayed, showing plan name, billing cadence, and next renewal date.",
      "and": "A 'Cancel subscription' button with confirmation options (cancel now vs. at period end) is displayed."
    },
    {
      "given": "An admin navigates to the '/team/:id/billing' route.",
      "when": "The Team Billing page loads.",
      "then": "The team's plan, seats, storage usage, and next billing date are displayed.",
      "and": "Billing contact and payment method management options are available."
    },
    {
      "given": "A user has opened the Plan Selector Modal.",
      "when": "The user selects a billing cadence and (for teams) adjusts seats, then confirms.",
      "then": "A POST request is made to '/api/billing/create-checkout-session'.",
      "and": "The user is redirected to the Stripe-hosted 'checkoutUrl' returned by the API."
    },
    {
      "given": "A user is viewing a list of invoices (e.g., on the Team Billing page).",
      "when": "The user clicks a link to view or download an invoice.",
      "then": "The invoice PDF is displayed or downloaded using 'invoice.invoicePdfUrl' or via a GET request to '/api/billing/invoices/:id/pdf'."
    },
    {
      "given": "A user is in the process of changing their plan (upgrade/downgrade).",
      "when": "The user selects new plan options.",
      "then": "A POST request is made to '/api/billing/proration-preview' with the intended changes.",
      "and": "The estimated immediate charge/refund and new recurring price are displayed to the user."
    },
    {
      "given": "an admin navigates to the upgrade page and selects an Enterprise plan",
      "when": "the admin enters the desired seat count and completes the payment via Stripe Checkout",
      "then": "a new Stripe Customer and Subscription are created, the Team's seatCount and storageQuotaBytes are set, and the admin receives a confirmation notification"
    },
    {
      "given": "an admin views the billing settings for an active subscription",
      "when": "the admin increases the seat number in the UI and confirms the change",
      "then": "the Stripe subscription is updated, a proration invoice is generated and processed, and the local Subscription.seats and Team.seatCount are updated"
    },
    {
      "given": "an admin requests a subscription downgrade",
      "when": "the admin opts to schedule the downgrade for the end of the current billing period",
      "then": "the Stripe subscription's cancel_at_period_end flag is set to true"
    },
    {
      "given": "an admin requests a subscription downgrade",
      "when": "the admin opts for an immediate downgrade with proration and the policy allows it",
      "then": "the POST /api/billing/change-plan endpoint is called, the subscription is updated, and prorated invoices are handled"
    },
    {
      "given": "a user needs to update their payment method or access past invoices",
      "when": "the user clicks 'Update payment method' or a similar link",
      "then": "the user is redirected to the Stripe Billing Portal, which handles card management and invoice viewing, and local database records are synchronized via webhooks"
    },
    {
      "given": "an invoice has been successfully paid in Stripe",
      "when": "the checkout.session.completed or invoice.paid webhook is received by the server",
      "then": "an email notification confirming payment is sent to the admin"
    },
    {
      "given": "an invoice payment has failed in Stripe",
      "when": "the invoice.payment_failed webhook is received by the server",
      "then": "an email notification of the failed payment is sent to the admin, the subscription is marked past_due, and an in-app option to retry payment is provided"
    },
    {
      "given": "a subscription has been canceled in Stripe",
      "when": "the relevant Stripe webhook (e.g., customer.subscription.deleted) is received by the server",
      "then": "an email notification confirming the subscription cancellation is sent to the admin"
    },
    {
      "given": "a team's current seat usage is close to its subscription limit",
      "when": "the system performs a routine check or a change triggers the condition",
      "then": "an email notification warning about the approaching seat limit is sent to the admin"
    },
    {
      "given": "a team's current storage usage is close to its subscription limit",
      "when": "the system performs a routine check or a change triggers the condition",
      "then": "an email notification warning about the approaching storage limit is sent to the admin"
    },
    {
      "given": "a payment transaction requires Strong Customer Authentication (SCA)",
      "when": "the user attempts to complete the payment",
      "then": "a modal is displayed, notifying the user of the required action and providing a direct link to resolve the SCA challenge"
    },
    {
      "given": "a Stripe webhook event is received by the server",
      "when": "the server processes the event",
      "then": "the event is deduplicated using its stripeEventId to ensure it is processed only once, even if received multiple times"
    },
    {
      "given": "a Stripe webhook processing job encounters an error",
      "when": "the error occurs",
      "then": "the job's status is marked as failed, and the system attempts to retry the job or escalates it for manual intervention"
    },
    {
      "given": "two different administrators simultaneously attempt to increase the team's seat count",
      "when": "both requests are sent to the system",
      "then": "Stripe's atomic subscription update correctly processes the changes, and the local database is updated only after webhook confirmation, ensuring Stripe remains the source of truth for the final seat count"
    },
    {
      "given": "an administrator attempts to downgrade the team's seats to a number below the currently used seats",
      "when": "the administrator confirms the downgrade in the UI",
      "then": "the system prevents immediate acceptance, displays an explicit warning message, and requires the administrator to reduce team members first or schedules the downgrade for the next billing cycle"
    },
    {
      "given": "an administrator is considering a change to their subscription plan or seat count",
      "when": "the administrator requests a proration preview",
      "then": "the system displays the exact immediate charge or refund amount, calculated using the Stripe upcoming_invoice API, before the changes are finalized"
    },
    {
      "given": "A user initiates a payment or billing update",
      "when": "The user provides payment information or manages their subscription",
      "then": "Stripe Checkout or Billing Portal is used, and the application does not directly handle card data"
    },
    {
      "given": "The application receives a Stripe webhook event",
      "when": "The webhook endpoint processes the event",
      "then": "The webhook endpoint verifies the 'stripe-signature' and is protected by network rules"
    },
    {
      "given": "A user's payment method is stored",
      "when": "The application persists payment method identifiers",
      "then": "Only Stripe IDs for payment methods are stored, and minimal PCI-sensitive information is retained"
    },
    {
      "given": "A user requests information about their billing data",
      "when": "The user inquires about data handling agreements",
      "then": "The application provides relevant user billing data handling agreements"
    },
    {
      "given": "A user requests an export of their data",
      "when": "The user initiates a data export request",
      "then": "The application provides data export according to policy"
    },
    {
      "given": "A user requests deletion of their data",
      "when": "The user initiates a data deletion request",
      "then": "The application performs data deletion according to policy"
    },
    {
      "given": "A billing action is performed (e.g., subscription creation, payment)",
      "when": "The action completes",
      "then": "An entry for the billing action is recorded in the 'BillingAudit' table"
    },
    {
      "given": "A user initiates the creation of a Stripe checkout session",
      "when": "The 'create-checkout-session' endpoint is called",
      "then": "A Stripe session with correct metadata is created, and a valid URL is returned"
    },
    {
      "given": "A user requests a proration preview for a plan change",
      "when": "The 'proration-preview' endpoint is called",
      "then": "An accurate proration preview is returned based on Stripe's upcoming invoice logic"
    },
    {
      "given": "A user completes a new subscription via Stripe Checkout",
      "when": "The 'checkout.session.completed' webhook is processed",
      "then": "A new subscription is successfully created and reflected in the database"
    },
    {
      "given": "A user updates the quantity of their subscription (e.g., adds seats)",
      "when": "The corresponding Stripe webhook is processed",
      "then": "The subscription quantity is updated, and the database (e.g., 'Team.seatCount') is updated accordingly"
    },
    {
      "given": "A user downgrades their subscription with a scheduled effective date",
      "when": "The downgrade request is processed",
      "then": "The subscription change is scheduled, and the database reflects the future change"
    },
    {
      "given": "A user downgrades their subscription with an immediate effective date",
      "when": "The downgrade request is processed",
      "then": "The subscription changes immediately, and the database reflects the current change"
    },
    {
      "given": "A user attempts to make a payment with a failing card (e.g., Stripe card 4000 0000 0000 9995)",
      "when": "The payment process completes",
      "then": "The UI displays a 'payment required' message to the user"
    },
    {
      "given": "A user attempts to make a payment requiring SCA (Strong Customer Authentication)",
      "when": "The payment process initiates",
      "then": "The user is directed to complete the authentication via Stripe's SCA flow"
    },
    {
      "given": "The system receives a high volume of duplicate webhook events",
      "when": "The webhook processing system is under spike load",
      "then": "Duplicate events are processed idempotently, and the system scales to handle the load"
    },
    {
      "given": "Subscriptions and payments are processed",
      "when": "The system operates",
      "then": "Monthly Recurring Revenue (MRR) is tracked"
    },
    {
      "given": "Subscriptions are created and canceled",
      "when": "The system operates",
      "then": "Churn rate is tracked"
    },
    {
      "given": "New subscriptions are created",
      "when": "The system operates",
      "then": "New subscriptions per day are tracked"
    },
    {
      "given": "Invoices are paid or fail to pay",
      "when": "The system processes invoice payments",
      "then": "Invoice payment success rate is tracked"
    },
    {
      "given": "Webhooks are processed",
      "when": "Webhook processing fails",
      "then": "The count of failed webhook processing attempts is tracked"
    },
    {
      "given": "Billing events are processed",
      "when": "The system processes billing events",
      "then": "Latency of billing event processing is tracked"
    },
    {
      "given": "Proration disputes or refunds occur",
      "when": "The system processes disputes or refunds",
      "then": "The volume of proration disputes and refunds is tracked"
    },
    {
      "given": "Storage add-ons exist and are used",
      "when": "The system operates",
      "then": "Storage costs versus revenue are tracked"
    },
    {
      "given": "Webhook events are being processed",
      "when": "The webhook processing failure rate exceeds a defined threshold (X)",
      "then": "An alert is triggered"
    },
    {
      "given": "Payments are being processed",
      "when": "The payment failure rate spikes above a defined threshold (X)",
      "then": "An alert is triggered"
    },
    {
      "given": "Stripe balance and database records are compared",
      "when": "The reconciliation drift between Stripe balance and DB records exceeds a defined threshold",
      "then": "An alert is triggered"
    },
    {
      "given": "A user successfully completes a new subscription via Stripe Checkout",
      "when": "The 'checkout.session.completed' webhook is processed",
      "then": "'BillingAccount' and 'Subscription' entries are created in the database"
    },
    {
      "given": "A user makes a seat change or plan change",
      "when": "The corresponding webhook is processed",
      "then": "The 'Team.seatCount' and 'Team.storageQuotaBytes' (if applicable) are updated in the database"
    },
    {
      "given": "A user is considering a plan change",
      "when": "The 'proration-preview' is displayed before change confirmation",
      "then": "The preview accurately shows the exact immediate charge or refund"
    },
    {
      "given": "An invoice is generated by Stripe",
      "when": "The corresponding webhook is processed",
      "then": "The invoice is created in the database, and its PDF or hosted URL is stored and available for download"
    },
    {
      "given": "The system receives a duplicate webhook event",
      "when": "The webhook processing handler receives the duplicate event",
      "then": "The duplicate event is ignored, and the system state remains consistent (idempotent)"
    },
    {
      "given": "A user updates their payment method",
      "when": "The user uses Stripe Billing Portal or a 'SetupIntent'",
      "then": "The updated payment method is reflected in the database"
    },
    {
      "given": "A user's payment fails",
      "when": "The payment failure is detected",
      "then": "The subscription status is set to 'past_due', and notifications are triggered"
    },
    {
      "given": "An authenticated user wants to subscribe to a plan and their billing account has an existing Stripe customer ID",
      "when": "They make a POST request to '/api/billing/create-checkout-session' with plan details (planId, interval, seats)",
      "then": "A new Stripe Checkout session is created using the existing customer ID, 'mode' is 'subscription', 'payment_method_types' is 'card', 'line_items' reflect the plan details, success and cancel URLs are set, metadata includes teamId, userId, and planId, and the API responds with the Stripe checkout session URL."
    },
    {
      "given": "An authenticated user wants to subscribe to a plan and their billing account does not have an existing Stripe customer ID",
      "when": "They make a POST request to '/api/billing/create-checkout-session' with plan details (planId, interval, seats)",
      "then": "A new Stripe customer is created using the user's email, a new Stripe Checkout session is created using the newly generated customer ID, 'mode' is 'subscription', 'payment_method_types' is 'card', 'line_items' reflect the plan details, success and cancel URLs are set, metadata includes teamId, userId, and planId, and the API responds with the Stripe checkout session URL."
    },
    {
      "given": "A Stripe webhook event is received that has been processed previously (existing 'stripeEventId')",
      "when": "The webhook handler at '/api/webhooks/stripe' processes the event",
      "then": "The handler validates the signature, identifies the event as already processed, and returns a '200 OK' response without re-processing the event, ensuring idempotency."
    },
    {
      "given": "A new and valid 'checkout.session.completed' Stripe webhook event is received",
      "when": "The webhook handler at '/api/webhooks/stripe' processes the event",
      "then": "The event signature is validated, a new 'billingEvent' record is created in the database, the 'team' is located from the session metadata, the 'BillingAccount' and 'Subscription' are created or updated in the database based on the session data, 'BillingAudit' records are created, and the API responds with 'received: true'."
    },
    {
      "given": "A new and valid Stripe webhook event (e.g., 'invoice.payment_succeeded', 'invoice.payment_failed', 'customer.subscription.updated') is received",
      "when": "The webhook handler at '/api/webhooks/stripe' processes the event",
      "then": "The event signature is validated, a new 'billingEvent' record is created in the database, and relevant local database entities (e.g., 'BillingAccount', 'Subscription') are updated according to the event type, and the API responds with 'received: true'."
    },
    {
      "given": "An authenticated user wants to preview a subscription change for an existing subscription",
      "when": "They make a POST request to '/api/billing/proration-preview' with 'subscriptionId', 'newPriceId', and 'newQuantity'",
      "then": "The system retrieves the existing subscription details, calls 'stripe.invoices.retrieveUpcoming' with the provided new details, and the API responds with a JSON object containing the 'upcoming' invoice preview, including its 'total' and 'lines' to show the immediate amount due."
    },
    {
      "given": "A user is on the frontend and initiates a checkout for a specific plan",
      "when": "The 'startCheckout' function is called with 'planId', 'interval', and optionally 'seats' and 'billingAccountId'",
      "then": "A POST API call is made to '/api/billing/create-checkout-session', the received URL from the response is extracted, and the user's browser is redirected to the Stripe checkout page at that URL."
    },
    {
      "given": "The daily reconciliation job is scheduled to run",
      "when": "The reconciliation job executes",
      "then": "It fetches Stripe subscriptions for customers, compares local 'Subscription' rows with their Stripe state, fixes any detected mismatches in the local database or flags them for human review, and reconciles invoices and payments, storing 'invoicePdfUrl' if available."
    },
    {
      "given": "The daily reconciliation job or webhook processing encounters an error",
      "when": "The system detects a critical failure such as webhook processing failure or repeated webhook signature errors",
      "then": "All errors are logged to Sentry, and PagerDuty alerts are created for critical failures."
    },
    {
      "given": "A user's team subscription has a specific number of seats configured",
      "when": "A Stripe event indicates a change in the number of subscribed seats",
      "then": "The Team.seatCount is updated to reflect the new number of seats"
    },
    {
      "given": "Multiple Stripe events indicating seat changes occur concurrently for a team's subscription",
      "when": "The system processes these simultaneous seat change events",
      "then": "Team.seatCount is updated accurately and consistently, handling concurrency gracefully"
    },
    {
      "given": "A user accesses their billing invoice listing",
      "when": "The invoice listing is displayed",
      "then": "Each entry shows an accurate link to the hosted invoice/PDF and its correct payment status"
    },
    {
      "given": "A user's subscription payment fails",
      "when": "The system detects the payment failure",
      "then": "The subscription status is set to 'past_due', the user is notified, and the admin is notified"
    },
    {
      "given": "A user's subscription payment has failed",
      "when": "The system attempts payment retries",
      "then": "Payment retries occur according to the configuration defined in Stripe settings"
    },
    {
      "given": "A billing webhook event is received by the system",
      "when": "The same billing webhook event is received again due to a retry or duplicate delivery",
      "then": "The system processes the event idempotently, preventing the creation of duplicate database rows"
    },
    {
      "given": "A user's subscription plan changes",
      "when": "The subscription change is processed by the system",
      "then": "The user's associated quotas (e.g., AI credits, storage) and enabled feature flags are updated accordingly"
    },
    {
      "given": "An administrator user needs to temporarily increase a user's quota",
      "when": "The administrator grants a 'QuotaOverride' for a specific user",
      "then": "The user's quota is temporarily increased without permanently altering their base subscription plan"
    },
    {
      "given": "A user is editing content in the Content Editor",
      "when": "The user saves their content changes",
      "then": "A new 'ContentVersion' record is created, the content blob is written to storage, and the UI is signaled for real-time updates"
    },
    {
      "given": "A user has completed drafting content",
      "when": "The user submits the content for approval",
      "then": "An 'ApprovalRequest' is created, and all relevant approvers are notified via in-app, email, and Slack"
    },
    {
      "given": "An approver has received an 'ApprovalRequest' for content",
      "when": "The approver approves the content",
      "then": "The content's status transitions to 'SCHEDULED' and it is moved into the Scheduling queue for eventual publishing"
    },
    {
      "given": "A user attempts to perform an action on content (e.g., edit, publish, approve)",
      "when": "The backend processes the user's request via tRPC resolvers",
      "then": "Role-Based Access Control (RBAC) is enforced through tRPC middlewares, ensuring the user has the necessary permissions based on their role"
    },
    {
      "given": "A significant action is performed on content (e.g., creation, update, approval, publication)",
      "when": "The action is successfully completed",
      "then": "An immutable record of the action, including user and timestamp, is saved to the 'audit_logs' table"
    },
    {
      "given": "A user wants to create new content.",
      "when": "The user calls `content.create` with a payload.",
      "then": "A new Content record is created, an initial ContentVersion (versionNum=1) is created, the content body is saved to storage, and `bodyUrl` is stored in the ContentVersion."
    },
    {
      "given": "An existing content item with a current version.",
      "when": "A user calls `content.update` with `contentId` and a new payload.",
      "then": "A new ContentVersion is created with an incremented `versionNum`, the `currentVersionId` of the Content is updated, and an audit log entry is recorded."
    },
    {
      "given": "An existing content item.",
      "when": "A user calls `content.get` with `contentId`.",
      "then": "The system returns the Content record, its current ContentVersion, and a minimal list of other versions."
    },
    {
      "given": "Multiple content items exist with various statuses, types, tags, and content.",
      "when": "A user calls `content.list` with filters (e.g., status, type, tags, search query) and pagination parameters.",
      "then": "The system returns a paginated list of content items that match the specified filters."
    },
    {
      "given": "An existing content item.",
      "when": "A user calls `content.delete` with `contentId`.",
      "then": "The content's status is changed to `ARCHIVED`, and an audit log entry is recorded."
    },
    {
      "given": "An existing content item.",
      "when": "A user calls `content.duplicate` with `contentId`.",
      "then": "A new content item is created with duplicated metadata, its content blob is copied, and an initial ContentVersion (versionNum=1) is created for the new content."
    },
    {
      "given": "A content item with multiple historical versions.",
      "when": "A user calls `version.list` with `contentId`.",
      "then": "The system returns a list of all ContentVersions associated with that content item."
    },
    {
      "given": "An existing content version.",
      "when": "A user calls `version.get` with `versionId`.",
      "then": "The system returns the specified ContentVersion record and its associated body content."
    },
    {
      "given": "A content item with multiple versions, and a user wants to revert to an older version.",
      "when": "A user calls `version.rollback` with `contentId` and `versionId` of the target version.",
      "then": "A new ContentVersion is created, copying the content from the specified `versionId`, the `versionNum` is incremented, and this new version becomes the `currentVersionId` for the content."
    },
    {
      "given": "A content item ready for approval.",
      "when": "A user calls `approval.submit` with `contentId`, an optional `approverId`, and a `message`.",
      "then": "A new Approval record is created with `status` set to `PENDING`, and notifications are sent to relevant parties."
    },
    {
      "given": "A content item with existing approval requests.",
      "when": "A user calls `approval.list` with `contentId`.",
      "then": "The system returns a list of all Approval records associated with that content item."
    },
    {
      "given": "An approval request for content with `status=PENDING`.",
      "when": "An approver calls `approval.act` with `approvalId`, `action='APPROVE'`, and an optional `message`.",
      "then": "The Approval record's status is updated to `APPROVED`, and the Content's status is updated to `SCHEDULED` (or remains for scheduler processing)."
    },
    {
      "given": "An approval request for content with `status=PENDING`.",
      "when": "An approver calls `approval.act` with `approvalId`, `action='REJECTED'`, and a `message`.",
      "then": "The Approval record's status is updated to `REJECTED`."
    },
    {
      "given": "An approval request for content with `status=PENDING`.",
      "when": "An approver calls `approval.act` with `approvalId`, `action='REQUEST_CHANGES'`, and a `message`.",
      "then": "The Approval record's status is updated to `REQUEST_CHANGES`."
    },
    {
      "given": "A content item.",
      "when": "A user calls `comment.create` with `contentId`, a `body`, and an optional `parentId` for threaded comments.",
      "then": "A new Comment record is created, an audit log entry is stored, and participants are notified."
    },
    {
      "given": "Multiple content items exist.",
      "when": "A user calls `content.bulk` with `action='delete'` and a list of `contentIds`.",
      "then": "A background job is enqueued to soft-delete (archive) each specified content item."
    },
    {
      "given": "Multiple content items exist.",
      "when": "A user calls `content.bulk` with `action='changeStatus'`, a new status, and a list of `contentIds`.",
      "then": "A background job is enqueued to update the status of each specified content item."
    },
    {
      "given": "Multiple content items exist.",
      "when": "A user calls `content.bulk` with `action='changeTags'`, new tags, and a list of `contentIds`.",
      "then": "A background job is enqueued to update the tags for each specified content item."
    },
    {
      "given": "A list of content items and a desired export format.",
      "when": "A user calls `export.generate` with `contentIds` and `format`.",
      "then": "An export job is enqueued, and a signed download URL is returned once the export is ready."
    },
    {
      "given": "A user attempts to perform an action on content.",
      "when": "The tRPC procedure is invoked.",
      "then": "The system checks the user's roles and permissions, and only authorized actions are allowed to proceed."
    },
    {
      "given": "A new content version is created or updated.",
      "when": "The system needs to persist the content body.",
      "then": "The content blob is saved to external storage (e.g., Supabase/S3) at a specific path, and its URL (`bodyUrl`) is stored in the `ContentVersion` record."
    },
    {
      "given": "A user is editing content in the Content Editor.",
      "when": "The user clicks the \"Save\" button.",
      "then": "The frontend posts the content for update, the backend stores the content blob in Supabase storage, a new ContentVersion record is created, the Content.currentVersionId and updatedAt fields are updated, an AuditLog entry is written for the save action, a realtime event content.updated is emitted to the relevant websocket channel, and the frontend optimistically updates the UI to show the saved state and new version number."
    },
    {
      "given": "An editor has finished editing content.",
      "when": "The editor clicks the \"Submit for approval\" button.",
      "then": "The frontend calls the approval.submit API, the backend creates an Approval row with a PENDING status, the Content.status is updated to PENDING_APPROVAL, an in-app notification is created, an email and/or Slack notification is sent to the approver via a background worker, and the approver receives the notification and can open the content."
    },
    {
      "given": "An approver has received a notification for pending content and views the approval request.",
      "when": "The approver performs approval.act('approve').",
      "then": "The Approval row status is updated to APPROVED, an AuditLog entry is written for the approval action, the Content.status is set to SCHEDULED (or PUBLISHED if publishing immediately), and a SchedulingJob is added to the queue for publication."
    },
    {
      "given": "An approver has received a notification for pending content and views the approval request.",
      "when": "The approver performs approval.act('request_changes') and provides a comment.",
      "then": "The Approval row status is updated to REQUESTED_CHANGES, an AuditLog entry is written for the 'request changes' action, the Content.status is set back to DRAFT, the approver's comment is associated with the content, and the user is routed back to the editor with the comment context."
    },
    {
      "given": "A user is viewing the version history of a content item.",
      "when": "The user selects a previous version and clicks \"Restore\" (rollback).",
      "then": "The frontend calls the version.rollback API, the backend reads the bodyUrl of the selected version, copies the content blob to a new storage path as the next versionNum, a new ContentVersion entry is created, the Content.currentVersionId is updated to the new version, and an AuditLog entry is written for the rollback action."
    },
    {
      "given": "A user is on the Content Library Page and has selected multiple content items.",
      "when": "The user clicks the \"Export\" button in the bulk action toolbar.",
      "then": "The frontend calls the export.generate API, the backend enqueues a background job, the background job fetches the content blobs for the selected items, collates them into a ZIP/PDF/CSV file, uploads the file to storage, produces a signed URL on successful upload, the worker stores the job status, the frontend polls or receives a realtime update when the export is ready, and a notification is shown in the Notifications Panel when the export is ready."
    },
    {
      "given": "A user is actively editing content in the Content Editor.",
      "when": "The user makes changes, and a debounce period of 1.5 seconds elapses without further input.",
      "then": "The frontend sends a patch to the content.update API, and the backend creates a new version snapshot (or partial snapshot) flagged as an ephemeral auto-draft, with version explosion mitigation in mind."
    },
    {
      "given": "A user is in the Content Editor.",
      "when": "The user clicks on the version indicator to open the \"Version History Modal\".",
      "then": "A list of versions is displayed showing versionNum, author, createdAt, and a short diff snippet, and the user can select two versions and click \"Compare\" to view a side-by-side diff highlighting changes using a text-diff library."
    },
    {
      "given": "A user is viewing content in the Content Editor.",
      "when": "The user selects text and creates an inline comment.",
      "then": "A comment anchor marker appears in the editor, and clicking the marker opens the comment thread in the side panel, which supports resolving and unresolving comments."
    },
    {
      "given": "A user is logged into the application.",
      "when": "An event occurs, such as an approval request, publish success, publish error, or export ready.",
      "then": "The Notifications Panel displays a relevant notification for the user."
    },
    {
      "given": "A user is editing content and the Optimistic UI is enabled.",
      "when": "The user saves the content.",
      "then": "The UI immediately shows 'Saving…', the version count updates optimistically, and the system handles the server response."
    },
    {
      "given": "Two users are editing the same content concurrently.",
      "when": "One user attempts to save their changes.",
      "then": "The system detects a conflict using `updatedAt` or a version token."
    },
    {
      "given": "A conflict is detected during concurrent content editing, and the 'last-write-wins with notice' policy is active.",
      "when": "A user saves their changes.",
      "then": "The system saves the latest changes, and a notice is displayed to the user."
    },
    {
      "given": "A conflict is detected during concurrent content editing, and the 'merge view' policy is active.",
      "when": "A user saves their changes.",
      "then": "A merge view is presented to the user to resolve the conflict."
    },
    {
      "given": "A conflict is detected during concurrent content editing, and the 'create branch version' policy is active.",
      "when": "A user saves their changes.",
      "then": "The user's changes are saved as a new branch version."
    },
    {
      "given": "A user initiates a heavy operation (e.g., exporting many items).",
      "when": "The operation is started.",
      "then": "The operation is processed as a background job, and its progress is shown in the notification center."
    },
    {
      "given": "A user has the 'creator' RBAC role.",
      "when": "The user attempts to create or update their own content.",
      "then": "The tRPC middleware allows the action."
    },
    {
      "given": "A user has the 'editor' RBAC role.",
      "when": "The user attempts to edit content within their assigned workspace.",
      "then": "The tRPC middleware allows the action."
    },
    {
      "given": "A user has the 'approver' RBAC role.",
      "when": "The user attempts to act on approvals.",
      "then": "The tRPC middleware allows the action."
    },
    {
      "given": "A user has the 'admin' RBAC role.",
      "when": "The user attempts to perform any action within the system.",
      "then": "The tRPC middleware allows the action."
    },
    {
      "given": "A user requests to view content items.",
      "when": "The system retrieves content items for the user.",
      "then": "The system only returns items for which the user has workspace membership."
    },
    {
      "given": "A request for a content blob is made.",
      "when": "The system provides access to the content blob.",
      "then": "A signed URL or temporary token with a short TTL is used for access."
    },
    {
      "given": "A user performs an action (create, update, approve, publish, export).",
      "when": "The action is successfully completed.",
      "then": "An immutable audit log record is created for that action."
    },
    {
      "given": "A user performs an action that generates AI usage.",
      "when": "The action is initiated.",
      "then": "The system rate-limits the user's actions to prevent excessive AI usage."
    },
    {
      "given": "A scheduled publish job or a retry for a publish job exists.",
      "when": "The `publishQueue` processes the job.",
      "then": "The job is executed to publish content via the LinkedIn API."
    },
    {
      "given": "An export job or a large duplication job exists.",
      "when": "The `exportQueue` processes the job.",
      "then": "The job is executed to handle exports or large duplications."
    },
    {
      "given": "A request for an email or Slack notification is made.",
      "when": "The `notificationQueue` processes the request.",
      "then": "The notification is sent to the intended recipient(s)."
    },
    {
      "given": "A request to remove old blobs exists.",
      "when": "The `cleanupQueue` processes the request.",
      "then": "The old blobs are removed according to the retention policy."
    },
    {
      "given": "A publish job is initiated for content available via a signed URL.",
      "when": "The LinkedIn API call to publish the content is successful.",
      "then": "The Content status is set to `PUBLISHED`, `publishedAt` is set, and an AuditLog is created."
    },
    {
      "given": "A publish job is initiated for content available via a signed URL, and the LinkedIn API call fails.",
      "when": "Retry attempts are ongoing.",
      "then": "The system retries the publication with exponential backoff."
    },
    {
      "given": "A publish job has exhausted its retry attempts after LinkedIn API call failures.",
      "when": "The LinkedIn API call ultimately fails.",
      "then": "The Content status is set to `ERROR`, and a notification is sent."
    },
    {
      "given": "An approver requests changes to content.",
      "when": "The editor views the content.",
      "then": "The editor sees a highlight of the requested change and a pinned comment."
    },
    {
      "given": "Content is scheduled for publication, and the system policy is to lock scheduled content.",
      "when": "The content's version is changed after it has been scheduled.",
      "then": "The scheduled content is locked, requiring new scheduling, and the user is notified."
    },
    {
      "given": "Auto-saves are generated for content.",
      "when": "Auto-saves accumulate over time.",
      "then": "Soft retention is implemented for auto-saves to manage storage."
    },
    {
      "given": "Manual versions of content are created.",
      "when": "Manual versions accumulate over time.",
      "then": "A retention policy is applied, keeping a specified number of versions (e.g., the last 100)."
    },
    {
      "given": "A user creates a new version of existing content",
      "when": "The version is successfully saved",
      "then": "The content's 'currentVersionId' is updated to the new version's ID, an audit log entry for 'VERSION_CREATE' is recorded with content and version IDs, and a 'content.version_created' realtime event is published to the workspace."
    },
    {
      "given": "Multiple users are concurrently editing the same content",
      "when": "A user attempts to save their changes after another user has saved theirs",
      "then": "The system presents a merge/3-way diff UI to resolve conflicts."
    },
    {
      "given": "A user wants to work on an experimental draft without affecting the main content",
      "when": "The user creates a new branch for the content",
      "then": "The user can work on a parallel draft, independent of the main version."
    },
    {
      "given": "A user creates or updates content",
      "when": "The content is saved",
      "then": "The system suggests relevant tags based on the content using AI."
    },
    {
      "given": "A user is working with templates across different workspaces",
      "when": "The user wants to manage versions of a template or reuse a template from another workspace",
      "then": "The system supports template versioning and allows template reuse across workspaces."
    },
    {
      "given": "Content has been inactive for a predefined period (X days)",
      "when": "The system periodically checks for inactive content",
      "then": "The system automatically archives the inactive content based on content lifecycle rules."
    },
    {
      "given": "A user attempts to perform a write operation via a tRPC endpoint",
      "when": "The tRPC endpoint is invoked",
      "then": "The system enforces Role-Based Access Control (RBAC) middleware to verify the user's permissions before proceeding."
    },
    {
      "given": "A user requests to access a stored attachment or content asset",
      "when": "The system provides a URL for the asset",
      "then": "The URL is a signed URL with a Time-To-Live (TTL) to ensure secure and temporary access."
    },
    {
      "given": "A user initiates an export or publishing operation for content",
      "when": "The operation is requested",
      "then": "The system adds the operation to a job queue for asynchronous processing."
    },
    {
      "given": "A user navigates to the Content Library",
      "when": "The Content Library UI loads",
      "then": "The user can view a list of content, apply filters, access a version history modal, and view an approvals drawer."
    },
    {
      "given": "A user performs any write operation (create, update, delete) on content",
      "when": "The write operation is successfully completed",
      "then": "An audit log entry is recorded, detailing the specific action, the user who performed it, and the affected content."
    },
    {
      "given": "A content item is scheduled for publishing",
      "when": "A user edits the scheduled content item",
      "then": "The system automatically re-queues the content item for approval or republishing based on the new edits, following the defined policy."
    },
    {
      "given": "An administrator is logged into the SaaS Admin Module.",
      "when": "The administrator navigates to the 'Customers' section.",
      "then": "The administrator can view, search, and manage all customer accounts and their associated details."
    },
    {
      "given": "An administrator is logged into the SaaS Admin Module.",
      "when": "The administrator accesses the 'Usage Reports' section.",
      "then": "The administrator can monitor AI tokens consumed and API calls per user."
    },
    {
      "given": "An administrator is logged into the SaaS Admin Module.",
      "when": "The administrator processes a customer's request related to billing (e.g., dispute, refund, cancellation).",
      "then": "The system allows the administrator to perform the necessary billing adjustments and update the customer's subscription status."
    },
    {
      "given": "An administrator is logged into the SaaS Admin Module.",
      "when": "The administrator modifies a feature flag setting for a specific customer or customer segment.",
      "then": "The feature flag changes are applied, controlling the availability of features for the designated users."
    },
    {
      "given": "An enterprise user attempts to log in to Scribl.",
      "when": "The user authenticates using their corporate Single Sign-On (SSO) credentials (e.g., SAML, SCIM).",
      "then": "The user is successfully authenticated and granted access to their Scribl workspace."
    },
    {
      "given": "An enterprise customer has configured custom domain and branding settings.",
      "when": "Their users access Scribl via the configured custom domain.",
      "then": "Scribl displays with the enterprise's custom branding and domain."
    },
    {
      "given": "An enterprise user with appropriate permissions has generated API credentials.",
      "when": "The user makes a request to the Scribl public API (e.g., to integrate with CRM).",
      "then": "The API responds with the requested data or successfully performs the specified action, adhering to security protocols."
    },
    {
      "given": "An enterprise user has configured a webhook to receive notifications for specific events (e.g., content status change).",
      "when": "The configured event occurs within Scribl.",
      "then": "Scribl automatically sends a formatted payload to the specified webhook URL."
    },
    {
      "given": "A user wants to discover new content templates.",
      "when": "The user accesses the Scribl Template Marketplace.",
      "then": "The user can browse, preview, and select user-created or official templates."
    },
    {
      "given": "A user wants to extend Scribl's functionality.",
      "when": "The user accesses the Plugin Ecosystem section.",
      "then": "The user can discover, install, and manage plugins for analytics, workflows, or other integrations."
    },
    {
      "given": "A user is consuming resources (e.g., AI tokens, storage) under a plan with defined limits.",
      "when": "The user's resource usage approaches or exceeds their plan's quota.",
      "then": "The system accurately tracks the usage and notifies the user about their consumption and limits."
    },
    {
      "given": "A user has reached their plan's usage quota for a specific resource (e.g., AI tokens).",
      "when": "The user attempts to perform an action that would exceed the quota.",
      "then": "The system prevents the action and prompts the user with options to upgrade their plan or manage their usage."
    },
    {
      "given": "A new user is registering for a Scribl account.",
      "when": "The user attempts to finalize their account creation.",
      "then": "The user is presented with the Terms of Service and Privacy Policy and must acknowledge them before gaining full access."
    },
    {
      "given": "An enterprise administrator is setting up a new Scribl account or managing existing settings.",
      "when": "The administrator specifies a preferred data residency region (e.g., EU, US).",
      "then": "All relevant data for that enterprise account is stored and processed within the chosen geographical region."
    },
    {
      "given": "An authorized user attempts to perform an action (e.g., export, share) involving sensitive content.",
      "when": "The Data Loss Prevention (DLP) system detects the action and evaluates it against defined policies.",
      "then": "The system either blocks the action, redacts the sensitive content, or logs the event for audit purposes."
    },
    {
      "given": "A user has received an AI-generated output.",
      "when": "The user interacts with the feedback mechanism (e.g., thumbs up/down icon) associated with the output.",
      "then": "The user's feedback is captured and submitted without leaving the current workflow."
    },
    {
      "given": "A user wants to provide general product feedback, suggest a feature, or report an issue.",
      "when": "The user accesses the in-app feedback tool (e.g., from settings or a dedicated widget).",
      "then": "The user can submit their feedback, which is routed to the product team for review."
    },
    {
      "given": "a SaaS administrator",
      "when": "they access the back-office panel",
      "then": "they should be able to perform operational tasks and manage users."
    },
    {
      "given": "an enterprise user with SSO enabled",
      "when": "they attempt to log in",
      "then": "they should be authenticated via their enterprise identity provider."
    },
    {
      "given": "an enterprise customer with specific data residency requirements",
      "when": "they configure their account",
      "then": "their content and data should be stored in the specified geographic region."
    },
    {
      "given": "a prospect inquiring about compliance",
      "when": "they request information on certifications",
      "then": "the system should provide evidence of relevant compliance certifications."
    },
    {
      "given": "a user consuming AI features",
      "when": "their usage exceeds allocated AI tokens",
      "then": "the system should meter the usage and apply enforcement logic (e.g., alert, stop service, prompt for top-up)."
    },
    {
      "given": "a developer integrating with Scribl",
      "when": "they use the public API or set up webhooks",
      "then": "they should be able to programmatically interact with Scribl functionalities and receive real-time updates."
    },
    {
      "given": "a user encountering an issue or having a suggestion",
      "when": "they submit feedback via the integrated module",
      "then": "their feedback should be captured and routed for continuous improvement."
    },
    {
      "given": "a new user",
      "when": "they choose to sign up using LinkedIn OAuth",
      "then": "they should be authenticated and logged into Scribl using their LinkedIn credentials."
    },
    {
      "given": "a newly registered user",
      "when": "they complete the guided onboarding flow",
      "then": "their account should be configured with their goals, brand voice, frequency, and niche preferences."
    },
    {
      "given": "a user selecting a subscription plan",
      "when": "they proceed to checkout for seat selection",
      "then": "they should be able to complete the payment via Stripe and activate their subscription."
    },
    {
      "given": "a user provides a prompt to the AI assistant",
      "when": "the AI processes the prompt",
      "then": "it should generate multiple content variations for the user to choose from."
    },
    {
      "given": "a user creating content",
      "when": "they use the chat and canvas editor",
      "then": "they should be able to edit text, add visuals, and preview their content in real-time."
    },
    {
      "given": "a user wants to create new content",
      "when": "they select a template from an industry category",
      "then": "a pre-formatted structure for a post, article, or carousel should be loaded for editing."
    },
    {
      "given": "a user wants to create a multi-slide carousel",
      "when": "they use the carousel builder",
      "then": "they should be able to create multiple slides, preview them, and ensure compliance."
    },
    {
      "given": "a user browsing the Template Marketplace",
      "when": "they search for a specific type of template",
      "then": "they should be able to find and utilize community or premium templates, with options for sharing and monetization."
    },
    {
      "given": "a user wants to find past content",
      "when": "they access the content library",
      "then": "they should see a centralized repository of all their created and managed content."
    },
    {
      "given": "a content creator submits content for approval",
      "when": "an approver reviews the content",
      "then": "the approver should be able to approve or reject the content, triggering notifications."
    },
    {
      "given": "a user modifies a piece of content multiple times",
      "when": "they need to revert to a previous state",
      "then": "they should be able to view content versions and roll back to any prior version."
    },
    {
      "given": "a user wants to schedule content",
      "when": "they use the calendar interface",
      "then": "they should be able to drag-and-drop posts, set recurring posts, and manage timezones for publishing."
    },
    {
      "given": "a post is scheduled for automated publishing",
      "when": "an initial publishing attempt fails",
      "then": "the system should automatically retry publishing and alert the user if it continues to fail."
    },
    {
      "given": "a post has been published",
      "when": "the publishing process completes",
      "then": "the user should receive a notification confirming success or failure."
    },
    {
      "given": "a user wants to interact with their network",
      "when": "they view their engagement feed",
      "then": "they should see a prioritized list of posts requiring their interaction."
    },
    {
      "given": "a user is viewing a post in the engagement feed",
      "when": "they click on the like, comment, or share icon",
      "then": "the respective action should be performed instantly."
    },
    {
      "given": "a user is about to comment on a post",
      "when": "they open the comment box",
      "then": "the AI should provide relevant comment or reply suggestions."
    },
    {
      "given": "a user wants to understand their network's activity",
      "when": "they access networking metrics",
      "then": "they should see tracking data on connection engagement."
    },
    {
      "given": "a user wants to find new content ideas",
      "when": "they view the discovery section",
      "then": "they should see trending topics identified by AI and LinkedIn signals."
    },
    {
      "given": "a user wants to analyze their market position",
      "when": "they request a competitor and gap analysis",
      "then": "the system should provide insights into their competitors' performance and content gaps."
    },
    {
      "given": "a user creates a new piece of content",
      "when": "they request a performance forecast",
      "then": "the AI should predict the content's potential reach and engagement before it's published."
    },
    {
      "given": "a user wants to review their performance",
      "when": "they access the analytics dashboards",
      "then": "they should see metrics like impressions, clicks, engagement, and follower growth."
    },
    {
      "given": "a user wants optimized strategies",
      "when": "they review AI insights",
      "then": "they should receive recommendations on best posting times and high-performing content types."
    },
    {
      "given": "a user wants to share their reports",
      "when": "they select an export option from a dashboard",
      "then": "they should be able to export data in CSV, PDF, or JSON formats."
    },
    {
      "given": "an administrator managing a team",
      "when": "they assign roles to team members",
      "then": "users should have access permissions aligned with their assigned role (admin, editor, approver, analyst)."
    },
    {
      "given": "an enterprise client with multiple brands or regions",
      "when": "they configure their account",
      "then": "they should be able to set up and manage multiple workspaces."
    },
    {
      "given": "an administrator needs to review system activity",
      "when": "they access the audit and activity logs",
      "then": "they should see a detailed record of all user actions and system events."
    },
    {
      "given": "an administrator needs precise access control",
      "when": "they configure user permissions",
      "then": "they should be able to grant granular rights for actions like create, edit, approve, publish, or analytics-only access."
    },
    {
      "given": "an organization with multi-step review requirements",
      "when": "content is submitted for approval",
      "then": "it should follow a defined approval hierarchy for multi-step reviews."
    },
    {
      "given": "a compliance officer setting data policies",
      "when": "they configure content and data retention policies",
      "then": "content and data should be automatically managed and deleted according to the defined rules."
    },
    {
      "given": "an enterprise requiring data localization",
      "when": "they define data storage preferences for different regions (e.g., EU, APAC)",
      "then": "their content and user data should be segregated and stored according to these regional requirements."
    },
    {
      "given": "a user selecting a subscription",
      "when": "they choose between Normal, Pro, or Enterprise plans",
      "then": "their account features and credit limits should align with the selected tier."
    },
    {
      "given": "a user wants to review their billing information",
      "when": "they access the billing dashboard",
      "then": "they should see their subscription status, invoices, and managed payment methods."
    },
    {
      "given": "a user changes their subscription plan",
      "when": "they upgrade or downgrade",
      "then": "their billing should be prorated automatically based on the change."
    },
    {
      "given": "a user is on a specific subscription tier",
      "when": "they use AI features",
      "then": "their AI credit consumption should be deducted from the allocation corresponding to their tier."
    },
    {
      "given": "a user creates different types of content using AI",
      "when": "AI credits are consumed",
      "then": "the credit calculation should vary based on the content type (e.g., post, article, carousel)."
    },
    {
      "given": "a user or admin wants to monitor AI usage",
      "when": "they access the usage tracking dashboard",
      "then": "they should see detailed AI credit usage per user and per team."
    },
    {
      "given": "a user's AI credit balance is low",
      "when": "their usage approaches the limit",
      "then": "they should receive alerts and be presented with options to purchase extra credit packs or enable auto top-ups."
    },
    {
      "given": "an administrator managing AI credits for a team",
      "when": "they access credit management settings",
      "then": "they should be able to allocate and reallocate AI credits among team members."
    },
    {
      "given": "a significant event occurs (e.g., content approval, publishing failure)",
      "when": "the event triggers a notification",
      "then": "the user should receive an alert via in-app, email, or integrated channels like Slack/Teams."
    },
    {
      "given": "a user wants to personalize their experience",
      "when": "they navigate to Profile & Settings",
      "then": "they should be able to define their brand voice, preferences, and manage GDPR-related export/deletion requests."
    },
    {
      "given": "a user is adding visuals to their content",
      "when": "they access the stock image library",
      "then": "they should be able to search for and use images from Unsplash/Pexels, with proper attribution and caching."
    },
    {
      "given": "a user is looking for specific content or features",
      "when": "they use the global search bar or advanced filters",
      "then": "they should be able to quickly locate relevant items within the platform."
    },
    {
      "given": "a user accesses Scribl on a mobile device",
      "when": "they use the responsive PWA",
      "then": "they should experience a streamlined interface for quick content creation, approval, and publishing."
    },
    {
      "given": "an enterprise user needing to manage large datasets",
      "when": "they perform data import or export operations",
      "then": "they should be able to bulk import/export data in CSV or JSON formats for setup or migration."
    },
    {
      "given": "a user needs assistance",
      "when": "they access the help resources",
      "then": "they should find a help center, onboarding tours, and options to submit support tickets."
    },
    {
      "given": "a user prefers a different language",
      "when": "they change the language settings",
      "then": "the UI and AI-generated content should be displayed in the selected language."
    },
    {
      "given": "a user wants to connect Scribl with other tools",
      "when": "they access the integration management section",
      "then": "they should be able to configure and manage integrations with platforms like Slack, CRM, email, calendar, Salesforce, or HubSpot."
    },
    {
      "given": "a developer wants to build custom solutions",
      "when": "they access the API documentation and developer portal",
      "then": "they should be able to obtain API keys, use REST/GraphQL APIs, set up webhooks, and understand rate limits."
    },
    {
      "given": "a user creates content",
      "when": "the content is analyzed for compliance",
      "then": "the system should perform uniqueness checks and AI safety checks to prevent plagiarism and ensure ethical content."
    },
    {
      "given": "a system administrator reviews security measures",
      "when": "they inspect the security implementation",
      "then": "they should confirm that RBAC, audit logs, data encryption, and GDPR compliance are effectively implemented to protect data."
    },
    {
      "given": "an enterprise customer subscribes to the Enterprise plan",
      "when": "they leverage the advanced features",
      "then": "they should have access to SSO, custom reporting capabilities, and specialized compliance packs."
    },
    {
      "given": "a user manages content for various social platforms",
      "when": "they schedule content",
      "then": "the system should support publishing to LinkedIn, and be ready for future integration with X, Instagram, and YouTube."
    },
    {
      "given": "A registered user with a valid username and password",
      "when": "The user attempts to log in using their credentials",
      "then": "The system should verify their identity and grant access."
    },
    {
      "given": "An administrator is logged into the system",
      "when": "The administrator creates a new user account with required details",
      "then": "The new user account should be successfully created and be in an 'active' or 'pending invitation' state."
    },
    {
      "given": "An administrator has defined a set of roles and permissions",
      "when": "The administrator assigns a specific role to a user",
      "then": "The user should inherit all permissions associated with that role."
    },
    {
      "given": "A user is authenticated with an external identity provider integrated via SSO",
      "when": "The user attempts to access an application connected to the SSO system",
      "then": "The user should be automatically logged into the application without needing to re-enter credentials."
    },
    {
      "given": "Two distinct tenants, Tenant A and Tenant B, exist within the system",
      "when": "A user from Tenant A attempts to access data belonging to Tenant B",
      "then": "The system should prevent access and ensure data isolation between tenants."
    },
    {
      "given": "An organization administrator is logged in",
      "when": "The administrator updates the organization's profile settings, such as domains or contacts",
      "then": "The organization's profile should be successfully updated and saved."
    },
    {
      "given": "A user with appropriate permissions is logged in",
      "when": "The user creates a new team and adds initial members",
      "then": "The team should be successfully created, and members should have access to team-specific resources."
    },
    {
      "given": "A customer is subscribed to a Basic plan",
      "when": "The customer initiates an upgrade to the Premium plan",
      "then": "The system should process the upgrade, apply proration if applicable, and update the customer's subscription."
    },
    {
      "given": "A customer has provided valid payment information (e.g., tokenized card details) for a service",
      "when": "The system attempts to process a payment via the configured payment gateway",
      "then": "The payment should be successfully processed, and the customer should receive a confirmation."
    },
    {
      "given": "A customer has consumed resources (e.g., API calls) that are subject to usage-based billing rules",
      "when": "The billing period ends and the system calculates the charges",
      "then": "The system should accurately meter the usage, apply the rating engine rules, and generate a billable amount."
    },
    {
      "given": "A customer has an outstanding balance for services rendered",
      "when": "The system generates an invoice for the customer",
      "then": "The invoice should accurately reflect the services, applied taxes (e.g., VAT/GST), and total amount due."
    },
    {
      "given": "An important system event occurs (e.g., password reset request)",
      "when": "The system is configured to send an email notification for this event",
      "then": "An email containing the relevant information should be sent to the user's registered email address."
    },
    {
      "given": "A user with marketing permissions is logged in",
      "when": "The user creates a new email template using the WYSIWYG editor and adds templating variables",
      "then": "The email template should be saved successfully and ready for use in campaigns or transactional emails."
    },
    {
      "given": "A user performs an action within the application (e.g., updates a record)",
      "when": "The action is successfully completed",
      "then": "An immutable audit log entry should be recorded, detailing who, what, and when the action occurred."
    },
    {
      "given": "The system has collected necessary data for compliance",
      "when": "An administrator requests a SOC2 compliance report",
      "then": "The system should generate an accurate report detailing adherence to SOC2 requirements."
    },
    {
      "given": "A user is accessing the application via a web browser",
      "when": "Data is transmitted between the user's browser and the application server",
      "then": "All data should be encrypted using TLS enforcement to protect against eavesdropping."
    },
    {
      "given": "A data loss event has occurred due to a system failure",
      "when": "A recovery operation is initiated to restore data from the latest backup",
      "then": "The system should restore data to a recent point-in-time, minimizing data loss according to RPO SLAs."
    },
    {
      "given": "The system is under normal operation",
      "when": "A key performance metric (e.g., CPU utilization) exceeds a predefined threshold",
      "then": "An alert should be triggered and sent to the operations team for investigation."
    },
    {
      "given": "A user with analytics permissions has defined criteria for a custom report",
      "when": "The user generates the custom report",
      "then": "The system should compile and display the report data, with an option to export it in CSV or PDF format."
    },
    {
      "given": "A user is viewing their personalized dashboard",
      "when": "The user adds a new widget from the library and rearranges the dashboard layout",
      "then": "The dashboard layout should be saved, and the new widget should display live data."
    },
    {
      "given": "A user is on any page within the application",
      "when": "The user enters a search query into the global search bar",
      "then": "The system should display relevant results from across different data entities, with options for faceted filtering."
    },
    {
      "given": "A developer is registered on the developer portal",
      "when": "The developer requests a new API key for their application",
      "then": "The system should generate a unique API key, assign appropriate permissions, and display it to the developer."
    },
    {
      "given": "An external system has subscribed to a specific event (e.g., 'user.created') via a webhook",
      "when": "The 'user.created' event occurs within the application",
      "then": "The system should send an HTTP POST request containing the event payload to the subscribed external system's webhook URL, with appropriate retry logic."
    },
    {
      "given": "An administrator wants to integrate with an external CRM system",
      "when": "The administrator selects the CRM connector, configures data mapping, and schedules a sync",
      "then": "The system should establish the connection, and data should synchronize according to the mapping and schedule."
    },
    {
      "given": "A visual workflow for expense approvals has been configured with a human-in-the-loop step",
      "when": "A user submits an expense report that meets the workflow's trigger conditions",
      "then": "The workflow should automatically route the report to the designated approver for review and action."
    },
    {
      "given": "A user needs to track a new work item",
      "when": "The user creates a new task, assigns it, sets a priority, and adds a description",
      "then": "The new task should be created and visible in the task list, with its initial status set."
    },
    {
      "given": "A sales representative wants to add a new prospect to the CRM",
      "when": "The representative creates a new contact record with details like name, company, and contact info",
      "then": "The new contact record should be successfully created and associated with their organization or lead."
    },
    {
      "given": "A customer encounters an issue and needs support",
      "when": "The customer submits a new support ticket via the helpdesk portal",
      "then": "A new ticket should be created, automatically routed to the appropriate support agent, and the customer should receive a confirmation."
    },
    {
      "given": "A user needs immediate assistance",
      "when": "The user initiates a live chat session via the in-app chat widget",
      "then": "A chat window should open, connecting the user with a support agent or chatbot, and the conversation history should be recorded."
    },
    {
      "given": "A user wants to store a new document in the system",
      "when": "The user uploads a document to a specific folder",
      "then": "The document should be securely stored, and its initial version should be recorded."
    },
    {
      "given": "A public asset is stored in the system and configured for CDN delivery",
      "when": "A user requests the asset via its CDN-enabled URL",
      "then": "The asset should be quickly delivered from the nearest CDN edge location, improving load times."
    },
    {
      "given": "An administrator has a CSV file containing new user data",
      "when": "The administrator uses the import utility, maps the CSV columns to system fields, and initiates the import",
      "then": "The system should validate the data, import the new users, and provide an audit report of the import job."
    },
    {
      "given": "A new feature is hidden behind a feature flag for a specific user segment",
      "when": "An administrator enables the feature flag for all users",
      "then": "All users should immediately see and have access to the new feature without requiring a new deployment."
    },
    {
      "given": "A new UI variant (B) needs to be tested against the current UI (A) for a specific user segment",
      "when": "An experiment is configured to show variant B to 50% of the target users",
      "then": "The system should assign users to variants A or B, track their behavior, and provide statistical reporting on the outcomes."
    },
    {
      "given": "A user's browser language is set to French (fr-FR) or the user explicitly selects French",
      "when": "The user accesses the application",
      "then": "The application UI and content should be displayed in French, with appropriate date and number formats."
    },
    {
      "given": "A user wants to change their notification settings",
      "when": "The user navigates to their personal preferences and updates their email notification frequency",
      "then": "The new notification setting should be saved and applied to future notifications."
    },
    {
      "given": "A user is viewing a document or record",
      "when": "The user adds a comment and uses an \"@mention\" to tag another user",
      "then": "The comment should be posted, the mentioned user should receive a notification, and the comment should be part of a threaded discussion."
    },
    {
      "given": "A service provider has configured their availability slots on a public booking widget",
      "when": "A customer selects an available slot and books an appointment",
      "then": "The appointment should be added to the service provider's calendar, the slot marked as unavailable, and both parties should receive a confirmation."
    },
    {
      "given": "An item in the inventory has a current stock level",
      "when": "A new batch of items is received and recorded",
      "then": "The system should update the stock level for that item, reflecting the increased quantity."
    },
    {
      "given": "A sales team has negotiated a deal with a customer",
      "when": "The sales team generates a quote for the customer based on selected products/services",
      "then": "A formal quote document should be generated from a template, reflecting the agreed-upon terms and pricing."
    },
    {
      "given": "An authorized user needs to order goods from a supplier",
      "when": "The user creates a new purchase order (PO) for the required items and submits it for approval",
      "then": "The PO should be generated, routed through the approval workflow, and recorded in the system upon approval."
    },
    {
      "given": "An HR administrator is logged in",
      "when": "The administrator updates an employee's profile information (e.g., department, contact details)",
      "then": "The employee's profile should be successfully updated in the system, reflecting the changes."
    },
    {
      "given": "An employee has logged their work hours for the week",
      "when": "The employee submits their timesheet for approval",
      "then": "The timesheet should be recorded, marked as \"pending approval,\" and routed to their manager."
    },
    {
      "given": "An employee has approved timesheets and salary information for a pay period",
      "when": "The system processes payroll for that period",
      "then": "A payslip detailing gross pay, deductions, and net pay should be generated for the employee."
    },
    {
      "given": "A user's plan has an API rate limit of 100 requests per minute",
      "when": "The user attempts to make more than 100 API requests within a single minute",
      "then": "The system should reject subsequent requests exceeding the limit and return a rate limit error message."
    },
    {
      "given": "A critical service is covered by an SLA defining a maximum downtime",
      "when": "The service experiences an outage that exceeds the defined SLA downtime",
      "then": "The system should trigger an SLA breach alert and potentially initiate a credit calculation process."
    },
    {
      "given": "A new user is signing up for the service",
      "when": "The user explicitly accepts the Terms of Service and Privacy Policy",
      "then": "The system should record the user's consent, including the date and version of the accepted policies."
    },
    {
      "given": "A GRC administrator wants to establish a new security policy",
      "when": "The administrator creates a new policy document within the policy library",
      "then": "The new policy should be stored, versioned, and available for review and enforcement."
    },
    {
      "given": "An application is running with autoscaling policies configured",
      "when": "The application's CPU utilization consistently exceeds a predefined threshold due to increased load",
      "then": "The autoscaling system should automatically provision additional resources (e.g., servers) to handle the increased demand."
    },
    {
      "given": "A developer is looking to integrate with the platform's API",
      "when": "The developer accesses the interactive API documentation (Swagger/OpenAPI) on the developer portal",
      "then": "The developer should be able to browse API endpoints, view request/response schemas, and test API calls directly."
    },
    {
      "given": "A user discovers a useful third-party app in the marketplace",
      "when": "The user installs the app and grants it the necessary permissions",
      "then": "The app should be successfully integrated into the platform, and its functionality should be available to the user, respecting permission isolation."
    },
    {
      "given": "An administrator needs to review user access logs for compliance",
      "when": "The administrator generates a user access report for a specific period",
      "then": "The report should list all user access events (login, logout, failed attempts) and be exportable for auditing."
    },
    {
      "given": "A user has completed a significant action in the application",
      "when": "The user is prompted to provide NPS feedback and submits their rating",
      "then": "The NPS score and any comments should be recorded, contributing to overall satisfaction analytics."
    },
    {
      "given": "A new user logs into the application for the first time",
      "when": "The user starts and completes an interactive guided tour of the core features",
      "then": "The user's onboarding progress should be updated, and contextual help should become available for future reference."
    },
    {
      "given": "A user interacts with a specific feature within the application (e.g., clicks a button)",
      "when": "The user successfully uses the feature",
      "then": "An event representing the feature usage should be recorded in the product telemetry system for analytics and potential billing."
    },
    {
      "given": "A user wishes to export their personal data for portability reasons",
      "when": "The user initiates a data export request for their account data",
      "then": "The system should generate an export file in a standard format, ensuring data privacy and encrypting the data during transit."
    },
    {
      "given": "A customer is purchasing a subscription",
      "when": "The customer enters a valid coupon code during checkout",
      "then": "The pricing engine should apply the discount defined by the coupon code to the total price, and the customer should see the updated amount."
    },
    {
      "given": "A platform operator is monitoring the system",
      "when": "The operator views the global health status dashboard in the superadmin console",
      "then": "The dashboard should display real-time metrics and alerts indicating the overall health and status of the platform and its services."
    },
    {
      "given": "A service outage has been detected and an incident has been created",
      "when": "An incident manager updates the public status page to reflect the ongoing incident",
      "then": "The status page should display the incident details, and subscribers should receive notifications about the update."
    },
    {
      "given": "A user submits a request (e.g., a spend request) that requires multi-step approval",
      "when": "The request is submitted and enters the approval workflow",
      "then": "The system should route the request to the first designated approver, and an audit trail of its status should be maintained."
    }
  ]
}